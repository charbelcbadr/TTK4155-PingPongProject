
PingPongProject.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         000001b2  00800100  00002f3a  00002fce  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00002f3a  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000030  008002b2  008002b2  00003180  2**0
                  ALLOC
  3 .comment      0000005c  00000000  00000000  00003180  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 0000003c  00000000  00000000  000031dc  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000340  00000000  00000000  00003218  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   000041a2  00000000  00000000  00003558  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 0000191e  00000000  00000000  000076fa  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00002037  00000000  00000000  00009018  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000978  00000000  00000000  0000b050  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00000ab6  00000000  00000000  0000b9c8  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00002ae0  00000000  00000000  0000c47e  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000290  00000000  00000000  0000ef5e  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 60 03 	jmp	0x6c0	; 0x6c0 <__ctors_end>
       4:	0c 94 9d 04 	jmp	0x93a	; 0x93a <__vector_1>
       8:	0c 94 7d 03 	jmp	0x6fa	; 0x6fa <__bad_interrupt>
       c:	0c 94 7d 03 	jmp	0x6fa	; 0x6fa <__bad_interrupt>
      10:	0c 94 7d 03 	jmp	0x6fa	; 0x6fa <__bad_interrupt>
      14:	0c 94 7d 03 	jmp	0x6fa	; 0x6fa <__bad_interrupt>
      18:	0c 94 7d 03 	jmp	0x6fa	; 0x6fa <__bad_interrupt>
      1c:	0c 94 7d 03 	jmp	0x6fa	; 0x6fa <__bad_interrupt>
      20:	0c 94 7d 03 	jmp	0x6fa	; 0x6fa <__bad_interrupt>
      24:	0c 94 7d 03 	jmp	0x6fa	; 0x6fa <__bad_interrupt>
      28:	0c 94 7d 03 	jmp	0x6fa	; 0x6fa <__bad_interrupt>
      2c:	0c 94 7d 03 	jmp	0x6fa	; 0x6fa <__bad_interrupt>
      30:	0c 94 7d 03 	jmp	0x6fa	; 0x6fa <__bad_interrupt>
      34:	0c 94 7d 03 	jmp	0x6fa	; 0x6fa <__bad_interrupt>
      38:	0c 94 7d 03 	jmp	0x6fa	; 0x6fa <__bad_interrupt>
      3c:	0c 94 7d 03 	jmp	0x6fa	; 0x6fa <__bad_interrupt>
      40:	0c 94 7d 03 	jmp	0x6fa	; 0x6fa <__bad_interrupt>
      44:	0c 94 7d 03 	jmp	0x6fa	; 0x6fa <__bad_interrupt>
      48:	0c 94 7d 03 	jmp	0x6fa	; 0x6fa <__bad_interrupt>
      4c:	0c 94 7d 03 	jmp	0x6fa	; 0x6fa <__bad_interrupt>
      50:	0c 94 7d 03 	jmp	0x6fa	; 0x6fa <__bad_interrupt>
      54:	0c 94 7d 03 	jmp	0x6fa	; 0x6fa <__bad_interrupt>
      58:	0c 94 7d 03 	jmp	0x6fa	; 0x6fa <__bad_interrupt>
      5c:	0c 94 7d 03 	jmp	0x6fa	; 0x6fa <__bad_interrupt>
      60:	0c 94 7d 03 	jmp	0x6fa	; 0x6fa <__bad_interrupt>
      64:	0c 94 7d 03 	jmp	0x6fa	; 0x6fa <__bad_interrupt>
      68:	0c 94 7d 03 	jmp	0x6fa	; 0x6fa <__bad_interrupt>
      6c:	0c 94 7d 03 	jmp	0x6fa	; 0x6fa <__bad_interrupt>

00000070 <__trampolines_end>:
      70:	00 00       	nop
      72:	00 00       	nop
      74:	00 5c       	subi	r16, 0xC0	; 192
      76:	00 00       	nop
      78:	0c 00       	.word	0x000c	; ????
      7a:	0c 00       	.word	0x000c	; ????
      7c:	7c 28       	or	r7, r12
      7e:	7c 28       	or	r7, r12
      80:	58 dc       	rcall	.-1872   	; 0xfffff932 <__eeprom_end+0xff7ef932>
      82:	68 00       	.word	0x0068	; ????
      84:	24 10       	cpse	r2, r4
      86:	48 00       	.word	0x0048	; ????
      88:	28 54       	subi	r18, 0x48	; 72
      8a:	28 40       	sbci	r18, 0x08	; 8
      8c:	00 0c       	add	r0, r0
      8e:	00 00       	nop
      90:	00 78       	andi	r16, 0x80	; 128
      92:	84 00       	.word	0x0084	; ????
      94:	84 78       	andi	r24, 0x84	; 132
      96:	00 00       	nop
      98:	54 38       	cpi	r21, 0x84	; 132
      9a:	54 00       	.word	0x0054	; ????
      9c:	10 7c       	andi	r17, 0xC0	; 192
      9e:	10 00       	.word	0x0010	; ????
      a0:	80 40       	sbci	r24, 0x00	; 0
      a2:	00 00       	nop
      a4:	10 10       	cpse	r1, r0
      a6:	10 00       	.word	0x0010	; ????
      a8:	00 40       	sbci	r16, 0x00	; 0
      aa:	00 00       	nop
      ac:	60 10       	cpse	r6, r0
      ae:	0c 00       	.word	0x000c	; ????
      b0:	38 54       	subi	r19, 0x48	; 72
      b2:	38 00       	.word	0x0038	; ????
      b4:	48 7c       	andi	r20, 0xC8	; 200
      b6:	40 00       	.word	0x0040	; ????
      b8:	48 64       	ori	r20, 0x48	; 72
      ba:	58 00       	.word	0x0058	; ????
      bc:	44 54       	subi	r20, 0x44	; 68
      be:	2c 00       	.word	0x002c	; ????
      c0:	1c 10       	cpse	r1, r12
      c2:	7c 00       	.word	0x007c	; ????
      c4:	5c 54       	subi	r21, 0x4C	; 76
      c6:	24 00       	.word	0x0024	; ????
      c8:	38 54       	subi	r19, 0x48	; 72
      ca:	24 00       	.word	0x0024	; ????
      cc:	64 14       	cp	r6, r4
      ce:	0c 00       	.word	0x000c	; ????
      d0:	68 54       	subi	r22, 0x48	; 72
      d2:	2c 00       	.word	0x002c	; ????
      d4:	48 54       	subi	r20, 0x48	; 72
      d6:	38 00       	.word	0x0038	; ????
      d8:	00 48       	sbci	r16, 0x80	; 128
      da:	00 00       	nop
      dc:	80 48       	sbci	r24, 0x80	; 128
      de:	00 00       	nop
      e0:	10 28       	or	r1, r0
      e2:	44 00       	.word	0x0044	; ????
      e4:	28 28       	or	r2, r8
      e6:	28 00       	.word	0x0028	; ????
      e8:	44 28       	or	r4, r4
      ea:	10 00       	.word	0x0010	; ????
      ec:	04 54       	subi	r16, 0x44	; 68
      ee:	08 00       	.word	0x0008	; ????
      f0:	38 44       	sbci	r19, 0x48	; 72
      f2:	5c 00       	.word	0x005c	; ????
      f4:	78 14       	cp	r7, r8
      f6:	78 00       	.word	0x0078	; ????
      f8:	7c 54       	subi	r23, 0x4C	; 76
      fa:	28 00       	.word	0x0028	; ????
      fc:	38 44       	sbci	r19, 0x48	; 72
      fe:	28 00       	.word	0x0028	; ????
     100:	7c 44       	sbci	r23, 0x4C	; 76
     102:	38 00       	.word	0x0038	; ????
     104:	7c 54       	subi	r23, 0x4C	; 76
     106:	44 00       	.word	0x0044	; ????
     108:	7c 14       	cp	r7, r12
     10a:	04 00       	.word	0x0004	; ????
     10c:	38 44       	sbci	r19, 0x48	; 72
     10e:	74 00       	.word	0x0074	; ????
     110:	7c 10       	cpse	r7, r12
     112:	7c 00       	.word	0x007c	; ????
     114:	44 7c       	andi	r20, 0xC4	; 196
     116:	44 00       	.word	0x0044	; ????
     118:	20 40       	sbci	r18, 0x00	; 0
     11a:	3c 00       	.word	0x003c	; ????
     11c:	7c 10       	cpse	r7, r12
     11e:	6c 00       	.word	0x006c	; ????
     120:	7c 40       	sbci	r23, 0x0C	; 12
     122:	40 00       	.word	0x0040	; ????
     124:	7c 18       	sub	r7, r12
     126:	7c 00       	.word	0x007c	; ????
     128:	78 10       	cpse	r7, r8
     12a:	3c 00       	.word	0x003c	; ????
     12c:	38 44       	sbci	r19, 0x48	; 72
     12e:	38 00       	.word	0x0038	; ????
     130:	7c 14       	cp	r7, r12
     132:	08 00       	.word	0x0008	; ????
     134:	38 44       	sbci	r19, 0x48	; 72
     136:	b8 00       	.word	0x00b8	; ????
     138:	7c 14       	cp	r7, r12
     13a:	68 00       	.word	0x0068	; ????
     13c:	48 54       	subi	r20, 0x48	; 72
     13e:	24 00       	.word	0x0024	; ????
     140:	04 7c       	andi	r16, 0xC4	; 196
     142:	04 00       	.word	0x0004	; ????
     144:	7c 40       	sbci	r23, 0x0C	; 12
     146:	7c 00       	.word	0x007c	; ????
     148:	3c 60       	ori	r19, 0x0C	; 12
     14a:	3c 00       	.word	0x003c	; ????
     14c:	7c 30       	cpi	r23, 0x0C	; 12
     14e:	7c 00       	.word	0x007c	; ????
     150:	6c 10       	cpse	r6, r12
     152:	6c 00       	.word	0x006c	; ????
     154:	0c 70       	andi	r16, 0x0C	; 12
     156:	0c 00       	.word	0x000c	; ????
     158:	64 54       	subi	r22, 0x44	; 68
     15a:	4c 00       	.word	0x004c	; ????
     15c:	00 7c       	andi	r16, 0xC0	; 192
     15e:	44 00       	.word	0x0044	; ????
     160:	0c 10       	cpse	r0, r12
     162:	60 00       	.word	0x0060	; ????
     164:	44 7c       	andi	r20, 0xC4	; 196
     166:	00 00       	nop
     168:	08 04       	cpc	r0, r8
     16a:	08 00       	.word	0x0008	; ????
     16c:	80 80       	ld	r8, Z
     16e:	80 00       	.word	0x0080	; ????
     170:	00 04       	cpc	r0, r0
     172:	08 00       	.word	0x0008	; ????
     174:	30 48       	sbci	r19, 0x80	; 128
     176:	78 00       	.word	0x0078	; ????
     178:	7c 48       	sbci	r23, 0x8C	; 140
     17a:	30 00       	.word	0x0030	; ????
     17c:	30 48       	sbci	r19, 0x80	; 128
     17e:	48 00       	.word	0x0048	; ????
     180:	30 48       	sbci	r19, 0x80	; 128
     182:	7c 00       	.word	0x007c	; ????
     184:	30 68       	ori	r19, 0x80	; 128
     186:	50 00       	.word	0x0050	; ????
     188:	10 78       	andi	r17, 0x80	; 128
     18a:	14 00       	.word	0x0014	; ????
     18c:	90 a8       	ldd	r9, Z+48	; 0x30
     18e:	78 00       	.word	0x0078	; ????
     190:	7c 08       	sbc	r7, r12
     192:	70 00       	.word	0x0070	; ????
     194:	50 74       	andi	r21, 0x40	; 64
     196:	40 00       	.word	0x0040	; ????
     198:	80 80       	ld	r8, Z
     19a:	74 00       	.word	0x0074	; ????
     19c:	7c 10       	cpse	r7, r12
     19e:	68 00       	.word	0x0068	; ????
     1a0:	44 7c       	andi	r20, 0xC4	; 196
     1a2:	40 00       	.word	0x0040	; ????
     1a4:	78 10       	cpse	r7, r8
     1a6:	78 00       	.word	0x0078	; ????
     1a8:	78 08       	sbc	r7, r8
     1aa:	70 00       	.word	0x0070	; ????
     1ac:	30 48       	sbci	r19, 0x80	; 128
     1ae:	30 00       	.word	0x0030	; ????
     1b0:	f8 28       	or	r15, r8
     1b2:	10 00       	.word	0x0010	; ????
     1b4:	30 48       	sbci	r19, 0x80	; 128
     1b6:	f8 00       	.word	0x00f8	; ????
     1b8:	78 10       	cpse	r7, r8
     1ba:	08 00       	.word	0x0008	; ????
     1bc:	50 58       	subi	r21, 0x80	; 128
     1be:	28 00       	.word	0x0028	; ????
     1c0:	08 3c       	cpi	r16, 0xC8	; 200
     1c2:	48 00       	.word	0x0048	; ????
     1c4:	38 40       	sbci	r19, 0x08	; 8
     1c6:	78 00       	.word	0x0078	; ????
     1c8:	38 40       	sbci	r19, 0x08	; 8
     1ca:	38 00       	.word	0x0038	; ????
     1cc:	78 20       	and	r7, r8
     1ce:	78 00       	.word	0x0078	; ????
     1d0:	48 30       	cpi	r20, 0x08	; 8
     1d2:	48 00       	.word	0x0048	; ????
     1d4:	98 a0       	ldd	r9, Y+32	; 0x20
     1d6:	78 00       	.word	0x0078	; ????
     1d8:	48 68       	ori	r20, 0x88	; 136
     1da:	58 00       	.word	0x0058	; ????
     1dc:	10 78       	andi	r17, 0x80	; 128
     1de:	84 00       	.word	0x0084	; ????
     1e0:	00 7c       	andi	r16, 0xC0	; 192
     1e2:	00 00       	nop
     1e4:	84 78       	andi	r24, 0x84	; 132
     1e6:	10 00       	.word	0x0010	; ????
     1e8:	08 04       	cpc	r0, r8
     1ea:	08 04       	cpc	r0, r8

000001ec <font5>:
     1ec:	00 00 00 00 00 00 00 5f 00 00 00 07 00 07 00 14     ......._........
     1fc:	7f 14 7f 14 24 2a 7f 2a 12 23 13 08 64 62 36 49     ....$*.*.#..db6I
     20c:	55 22 50 00 05 03 00 00 00 1c 22 41 00 00 41 22     U"P......."A..A"
     21c:	1c 00 08 2a 1c 2a 08 08 08 3e 08 08 00 50 30 00     ...*.*...>...P0.
     22c:	00 08 08 08 08 08 00 60 60 00 00 20 10 08 04 02     .......``.. ....
     23c:	3e 51 49 45 3e 00 42 7f 40 00 42 61 51 49 46 21     >QIE>.B.@.BaQIF!
     24c:	41 45 4b 31 18 14 12 7f 10 27 45 45 45 39 3c 4a     AEK1.....'EEE9<J
     25c:	49 49 30 01 71 09 05 03 36 49 49 49 36 06 49 49     II0.q...6III6.II
     26c:	29 1e 00 36 36 00 00 00 56 36 00 00 00 08 14 22     )..66...V6....."
     27c:	41 14 14 14 14 14 41 22 14 08 00 02 01 51 09 06     A.....A".....Q..
     28c:	32 49 79 41 3e 7e 11 11 11 7e 7f 49 49 49 36 3e     2IyA>~...~.III6>
     29c:	41 41 41 22 7f 41 41 22 1c 7f 49 49 49 41 7f 09     AAA".AA"..IIIA..
     2ac:	09 01 01 3e 41 41 51 32 7f 08 08 08 7f 00 41 7f     ...>AAQ2......A.
     2bc:	41 00 20 40 41 3f 01 7f 08 14 22 41 7f 40 40 40     A. @A?...."A.@@@
     2cc:	40 7f 02 04 02 7f 7f 04 08 10 7f 3e 41 41 41 3e     @..........>AAA>
     2dc:	7f 09 09 09 06 3e 41 51 21 5e 7f 09 19 29 46 46     .....>AQ!^...)FF
     2ec:	49 49 49 31 01 01 7f 01 01 3f 40 40 40 3f 1f 20     III1.....?@@@?. 
     2fc:	40 20 1f 7f 20 18 20 7f 63 14 08 14 63 03 04 78     @ .. . .c...c..x
     30c:	04 03 61 51 49 45 43 00 00 7f 41 41 02 04 08 10     ..aQIEC...AA....
     31c:	20 41 41 7f 00 00 04 02 01 02 04 40 40 40 40 40      AA........@@@@@
     32c:	00 01 02 04 00 20 54 54 54 78 7f 48 44 44 38 38     ..... TTTx.HDD88
     33c:	44 44 44 20 38 44 44 48 7f 38 54 54 54 18 08 7e     DDD 8DDH.8TTT..~
     34c:	09 01 02 08 14 54 54 3c 7f 08 04 04 78 00 44 7d     .....TT<....x.D}
     35c:	40 00 20 40 44 3d 00 00 7f 10 28 44 00 41 7f 40     @. @D=....(D.A.@
     36c:	00 7c 04 18 04 78 7c 08 04 04 78 38 44 44 44 38     .|...x|...x8DDD8
     37c:	7c 14 14 14 08 08 14 14 18 7c 7c 08 04 04 08 48     |........||....H
     38c:	54 54 54 20 04 3f 44 40 20 3c 40 40 20 7c 1c 20     TTT .?D@ <@@ |. 
     39c:	40 20 1c 3c 40 30 40 3c 44 28 10 28 44 0c 50 50     @ .<@0@<D(.(D.PP
     3ac:	50 3c 44 64 54 4c 44 00 08 36 41 00 00 00 7f 00     P<DdTLD..6A.....
     3bc:	00 00 41 36 08 00 02 01 03 02 01                    ..A6.......

000003c7 <font8>:
	...
     3cf:	00 06 5f 5f 06 00 00 00 00 07 07 00 07 07 00 00     ..__............
     3df:	14 7f 7f 14 7f 7f 14 00 24 2e 6b 6b 3a 12 00 00     ........$.kk:...
     3ef:	46 66 30 18 0c 66 62 00 30 7a 4f 5d 37 7a 48 00     Ff0..fb.0zO]7zH.
     3ff:	04 07 03 00 00 00 00 00 00 1c 3e 63 41 00 00 00     ..........>cA...
     40f:	00 41 63 3e 1c 00 00 00 08 2a 3e 1c 1c 3e 2a 08     .Ac>.....*>..>*.
     41f:	08 08 3e 3e 08 08 00 00 00 a0 e0 60 00 00 00 00     ..>>.......`....
     42f:	08 08 08 08 08 08 00 00 00 00 60 60 00 00 00 00     ..........``....
     43f:	60 30 18 0c 06 03 01 00 3e 7f 59 4d 7f 3e 00 00     `0......>.YM.>..
     44f:	42 42 7f 7f 40 40 00 00 62 73 59 49 6f 66 00 00     BB..@@..bsYIof..
     45f:	22 63 49 49 7f 36 00 00 18 1c 16 13 7f 7f 10 00     "cII.6..........
     46f:	27 67 45 45 7d 39 00 00 3c 7e 4b 49 79 30 00 00     'gEE}9..<~KIy0..
     47f:	03 63 71 19 0f 07 00 00 36 7f 49 49 7f 36 00 00     .cq.....6.II.6..
     48f:	06 4f 49 69 3f 1e 00 00 00 00 6c 6c 00 00 00 00     .OIi?.....ll....
     49f:	00 a0 ec 6c 00 00 00 00 08 1c 36 63 41 00 00 00     ...l......6cA...
     4af:	14 14 14 14 14 14 00 00 00 41 63 36 1c 08 00 00     .........Ac6....
     4bf:	02 03 51 59 0f 06 00 00 3e 7f 41 5d 5d 1f 1e 00     ..QY....>.A]]...
     4cf:	7c 7e 13 13 7e 7c 00 00 41 7f 7f 49 49 7f 36 00     |~..~|..A..II.6.
     4df:	1c 3e 63 41 41 63 22 00 41 7f 7f 41 63 7f 1c 00     .>cAAc".A..Ac...
     4ef:	41 7f 7f 49 5d 41 63 00 41 7f 7f 49 1d 01 03 00     A..I]Ac.A..I....
     4ff:	1c 3e 63 41 51 73 72 00 7f 7f 08 08 7f 7f 00 00     .>cAQsr.........
     50f:	00 41 7f 7f 41 00 00 00 30 70 40 41 7f 3f 01 00     .A..A...0p@A.?..
     51f:	41 7f 7f 08 1c 77 63 00 41 7f 7f 41 40 60 70 00     A....wc.A..A@`p.
     52f:	7f 7f 06 0c 06 7f 7f 00 7f 7f 06 0c 18 7f 7f 00     ................
     53f:	1c 3e 63 41 63 3e 1c 00 41 7f 7f 49 09 0f 06 00     .>cAc>..A..I....
     54f:	1e 3f 21 71 7f 5e 00 00 41 7f 7f 19 39 6f 46 00     .?!q.^..A...9oF.
     55f:	26 67 4d 59 7b 32 00 00 03 41 7f 7f 41 03 00 00     &gMY{2...A..A...
     56f:	7f 7f 40 40 7f 7f 00 00 1f 3f 60 60 3f 1f 00 00     ..@@.....?``?...
     57f:	7f 7f 30 18 30 7f 7f 00 63 77 1c 08 1c 77 63 00     ..0.0...cw...wc.
     58f:	07 4f 78 78 4f 07 00 00 67 73 59 4d 47 63 71 00     .OxxO...gsYMGcq.
     59f:	00 7f 7f 41 41 00 00 00 01 03 06 0c 18 30 60 00     ...AA........0`.
     5af:	00 41 41 7f 7f 00 00 00 08 0c 06 03 06 0c 08 00     .AA.............
     5bf:	80 80 80 80 80 80 80 80 00 00 03 07 04 00 00 00     ................
     5cf:	20 74 54 54 3c 78 40 00 41 3f 7f 44 44 7c 38 00      tTT<x@.A?.DD|8.
     5df:	38 7c 44 44 6c 28 00 00 30 78 48 49 3f 7f 40 00     8|DDl(..0xHI?.@.
     5ef:	38 7c 54 54 5c 18 00 00 48 7e 7f 49 03 02 00 00     8|TT\...H~.I....
     5ff:	98 bc a4 a4 f8 7c 04 00 41 7f 7f 08 04 7c 78 00     .....|..A....|x.
     60f:	00 44 7d 7d 40 00 00 00 40 c4 84 fd 7d 00 00 00     .D}}@...@...}...
     61f:	41 7f 7f 10 38 6c 44 00 00 41 7f 7f 40 00 00 00     A...8lD..A..@...
     62f:	7c 7c 0c 18 0c 7c 78 00 7c 7c 04 04 7c 78 00 00     ||...|x.||..|x..
     63f:	38 7c 44 44 7c 38 00 00 84 fc f8 a4 24 3c 18 00     8|DD|8......$<..
     64f:	18 3c 24 a4 f8 fc 84 00 44 7c 78 44 1c 18 00 00     .<$.....D|xD....
     65f:	48 5c 54 54 74 24 00 00 00 04 3e 7f 44 24 00 00     H\TTt$....>.D$..
     66f:	3c 7c 40 40 3c 7c 40 00 1c 3c 60 60 3c 1c 00 00     <|@@<|@..<``<...
     67f:	3c 7c 60 30 60 7c 3c 00 44 6c 38 10 38 6c 44 00     <|`0`|<.Dl8.8lD.
     68f:	9c bc a0 a0 fc 7c 00 00 4c 64 74 5c 4c 64 00 00     .....|..Ldt\Ld..
     69f:	08 08 3e 77 41 41 00 00 00 00 00 77 77 00 00 00     ..>wAA.....ww...
     6af:	41 41 77 3e 08 08 00 00 02 03 01 03 02 03 01 00     AAw>............
	...

000006c0 <__ctors_end>:
     6c0:	11 24       	eor	r1, r1
     6c2:	1f be       	out	0x3f, r1	; 63
     6c4:	cf ef       	ldi	r28, 0xFF	; 255
     6c6:	d4 e0       	ldi	r29, 0x04	; 4
     6c8:	de bf       	out	0x3e, r29	; 62
     6ca:	cd bf       	out	0x3d, r28	; 61

000006cc <__do_copy_data>:
     6cc:	12 e0       	ldi	r17, 0x02	; 2
     6ce:	a0 e0       	ldi	r26, 0x00	; 0
     6d0:	b1 e0       	ldi	r27, 0x01	; 1
     6d2:	ea e3       	ldi	r30, 0x3A	; 58
     6d4:	ff e2       	ldi	r31, 0x2F	; 47
     6d6:	02 c0       	rjmp	.+4      	; 0x6dc <__do_copy_data+0x10>
     6d8:	05 90       	lpm	r0, Z+
     6da:	0d 92       	st	X+, r0
     6dc:	a2 3b       	cpi	r26, 0xB2	; 178
     6de:	b1 07       	cpc	r27, r17
     6e0:	d9 f7       	brne	.-10     	; 0x6d8 <__do_copy_data+0xc>

000006e2 <__do_clear_bss>:
     6e2:	22 e0       	ldi	r18, 0x02	; 2
     6e4:	a2 eb       	ldi	r26, 0xB2	; 178
     6e6:	b2 e0       	ldi	r27, 0x02	; 2
     6e8:	01 c0       	rjmp	.+2      	; 0x6ec <.do_clear_bss_start>

000006ea <.do_clear_bss_loop>:
     6ea:	1d 92       	st	X+, r1

000006ec <.do_clear_bss_start>:
     6ec:	a2 3e       	cpi	r26, 0xE2	; 226
     6ee:	b2 07       	cpc	r27, r18
     6f0:	e1 f7       	brne	.-8      	; 0x6ea <.do_clear_bss_loop>
     6f2:	0e 94 c2 0f 	call	0x1f84	; 0x1f84 <main>
     6f6:	0c 94 9b 17 	jmp	0x2f36	; 0x2f36 <_exit>

000006fa <__bad_interrupt>:
     6fa:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000006fe <initialize_clock_adc>:
Input: Nothing
Output: Nothing
*/
void initialize_clock_adc() {
	//Initialising the Port D pin as output
 	DDRD |= (1<<PD5);
     6fe:	8d 9a       	sbi	0x11, 5	; 17
	//Generating the timer register and setting Compare Output Mode for channel A
 	TCCR1A |= (1<<COM1A0);
     700:	8f b5       	in	r24, 0x2f	; 47
     702:	80 64       	ori	r24, 0x40	; 64
     704:	8f bd       	out	0x2f, r24	; 47
	//No prescaler and 
 	TCCR1B |= (1<<WGM12)|(1<<CS10);
     706:	8e b5       	in	r24, 0x2e	; 46
     708:	89 60       	ori	r24, 0x09	; 9
     70a:	8e bd       	out	0x2e, r24	; 46
	//The flag is set after the counter is matched with the value in OCR1A 
 	OCR1A = 0b00000000;
     70c:	1b bc       	out	0x2b, r1	; 43
     70e:	1a bc       	out	0x2a, r1	; 42
     710:	08 95       	ret

00000712 <read_adc>:
Input: Reads the value of the channel specified
Output: Retruns the value of the channel
*/
 uint8_t read_adc(uint8_t channelNum) {
	int16_t ADC_wait = ((9*4*2)/2450000);	
 	adc_ext[0]=0;
     712:	e0 91 06 01 	lds	r30, 0x0106	; 0x800106 <adc_ext>
     716:	f0 91 07 01 	lds	r31, 0x0107	; 0x800107 <adc_ext+0x1>
     71a:	10 82       	st	Z, r1
	_delay_us(ADC_wait);
	int i=0;
	uint8_t toReturn;
	
	while(i<=channelNum)
     71c:	48 2f       	mov	r20, r24
     71e:	50 e0       	ldi	r21, 0x00	; 0
	{
		toReturn=adc_ext[0];
     720:	e0 91 06 01 	lds	r30, 0x0106	; 0x800106 <adc_ext>
     724:	f0 91 07 01 	lds	r31, 0x0107	; 0x800107 <adc_ext+0x1>
     728:	20 e0       	ldi	r18, 0x00	; 0
     72a:	30 e0       	ldi	r19, 0x00	; 0
     72c:	80 81       	ld	r24, Z
		i++;
     72e:	2f 5f       	subi	r18, 0xFF	; 255
     730:	3f 4f       	sbci	r19, 0xFF	; 255
 	adc_ext[0]=0;
	_delay_us(ADC_wait);
	int i=0;
	uint8_t toReturn;
	
	while(i<=channelNum)
     732:	42 17       	cp	r20, r18
     734:	53 07       	cpc	r21, r19
     736:	d4 f7       	brge	.-12     	; 0x72c <read_adc+0x1a>
	{
		toReturn=adc_ext[0];
		i++;
	}
	return toReturn;
     738:	08 95       	ret

0000073a <CAN_init>:
Description: Initialisation function for CAN
Input: Nothing
Output: Nothing
*/
void CAN_init(){
	mcp2515_init();
     73a:	0e 94 9e 05 	call	0xb3c	; 0xb3c <mcp2515_init>
	// enable interrupt generation for successful reception
	mcp2515_write(MCP_CANINTE,MCP_RX_INT_B0);
     73e:	61 e0       	ldi	r22, 0x01	; 1
     740:	8b e2       	ldi	r24, 0x2B	; 43
     742:	0e 94 3b 05 	call	0xa76	; 0xa76 <mcp2515_write>
	//Clear the global interrupts
	cli();
     746:	f8 94       	cli
	//The falling edge of INT0 generates an interrupt request
	MCUCR = (1<<ISC01)|(0<<ISC00);
     748:	82 e0       	ldi	r24, 0x02	; 2
     74a:	85 bf       	out	0x35, r24	; 53
	//Set INT0 interrupts through the GICR register
	GICR = (1<<INT0);
     74c:	80 e4       	ldi	r24, 0x40	; 64
     74e:	8b bf       	out	0x3b, r24	; 59
	//Set the global interrupts
	sei();
     750:	78 94       	sei
     752:	08 95       	ret

00000754 <can_transmit>:
/* 
Description: The function is used to send the CAN messages
Input: CAN message which needs to be transmitted
Output: Nothing
*/
void can_transmit(CAN_Msg msg){
     754:	8f 92       	push	r8
     756:	9f 92       	push	r9
     758:	af 92       	push	r10
     75a:	bf 92       	push	r11
     75c:	cf 92       	push	r12
     75e:	df 92       	push	r13
     760:	ef 92       	push	r14
     762:	ff 92       	push	r15
     764:	0f 93       	push	r16
     766:	1f 93       	push	r17
     768:	cf 93       	push	r28
     76a:	df 93       	push	r29
     76c:	cd b7       	in	r28, 0x3d	; 61
     76e:	de b7       	in	r29, 0x3e	; 62
     770:	2b 97       	sbiw	r28, 0x0b	; 11
     772:	0f b6       	in	r0, 0x3f	; 63
     774:	f8 94       	cli
     776:	de bf       	out	0x3e, r29	; 62
     778:	0f be       	out	0x3f, r0	; 63
     77a:	cd bf       	out	0x3d, r28	; 61
     77c:	e9 82       	std	Y+1, r14	; 0x01
     77e:	fa 82       	std	Y+2, r15	; 0x02
     780:	0b 83       	std	Y+3, r16	; 0x03
     782:	1c 83       	std	Y+4, r17	; 0x04
     784:	2d 83       	std	Y+5, r18	; 0x05
     786:	3e 83       	std	Y+6, r19	; 0x06
     788:	4f 83       	std	Y+7, r20	; 0x07
     78a:	58 87       	std	Y+8, r21	; 0x08
     78c:	69 87       	std	Y+9, r22	; 0x09
     78e:	7a 87       	std	Y+10, r23	; 0x0a
     790:	8b 87       	std	Y+11, r24	; 0x0b
     792:	89 80       	ldd	r8, Y+1	; 0x01
     794:	9a 80       	ldd	r9, Y+2	; 0x02
	//Classifying the High byte and low byte of Message ID of 16 bits by right shifting high byte and left shifting the low byte and writing to the MCP Tx Buffer 
	int msg_ID = msg.Msg_ID;
	uint8_t ID_High = msg_ID>>3;
	uint8_t ID_Low = msg_ID<<5;
	mcp2515_write(MCP_TXB0SIDH, ID_High);
     796:	b4 01       	movw	r22, r8
     798:	75 95       	asr	r23
     79a:	67 95       	ror	r22
     79c:	75 95       	asr	r23
     79e:	67 95       	ror	r22
     7a0:	75 95       	asr	r23
     7a2:	67 95       	ror	r22
     7a4:	81 e3       	ldi	r24, 0x31	; 49
     7a6:	0e 94 3b 05 	call	0xa76	; 0xa76 <mcp2515_write>
	mcp2515_write(MCP_TXB0SIDL, ID_Low);
     7aa:	68 2d       	mov	r22, r8
     7ac:	62 95       	swap	r22
     7ae:	66 0f       	add	r22, r22
     7b0:	60 7e       	andi	r22, 0xE0	; 224
     7b2:	82 e3       	ldi	r24, 0x32	; 50
     7b4:	0e 94 3b 05 	call	0xa76	; 0xa76 <mcp2515_write>
	// Writing the Message Length to the MCP Tx DLC
	int length = msg.Msg_length;
     7b8:	a0 2e       	mov	r10, r16
     7ba:	b1 2c       	mov	r11, r1
	mcp2515_write(MCP_TXB0DLC, length);
     7bc:	60 2f       	mov	r22, r16
     7be:	85 e3       	ldi	r24, 0x35	; 53
     7c0:	0e 94 3b 05 	call	0xa76	; 0xa76 <mcp2515_write>
     7c4:	6e 01       	movw	r12, r28
     7c6:	84 e0       	ldi	r24, 0x04	; 4
     7c8:	c8 0e       	add	r12, r24
     7ca:	d1 1c       	adc	r13, r1
     7cc:	16 e3       	ldi	r17, 0x36	; 54
     7ce:	e1 2c       	mov	r14, r1
     7d0:	f1 2c       	mov	r15, r1
	//Writing the Data to the MCP Tx
	for(int i=0; i<=length; i++){
		mcp2515_write (MCP_TXB0D0+i, msg.Data[i]);
     7d2:	f6 01       	movw	r30, r12
     7d4:	61 91       	ld	r22, Z+
     7d6:	6f 01       	movw	r12, r30
     7d8:	81 2f       	mov	r24, r17
     7da:	0e 94 3b 05 	call	0xa76	; 0xa76 <mcp2515_write>
	mcp2515_write(MCP_TXB0SIDL, ID_Low);
	// Writing the Message Length to the MCP Tx DLC
	int length = msg.Msg_length;
	mcp2515_write(MCP_TXB0DLC, length);
	//Writing the Data to the MCP Tx
	for(int i=0; i<=length; i++){
     7de:	ff ef       	ldi	r31, 0xFF	; 255
     7e0:	ef 1a       	sub	r14, r31
     7e2:	ff 0a       	sbc	r15, r31
     7e4:	1f 5f       	subi	r17, 0xFF	; 255
     7e6:	ae 14       	cp	r10, r14
     7e8:	bf 04       	cpc	r11, r15
     7ea:	9c f7       	brge	.-26     	; 0x7d2 <can_transmit+0x7e>
		mcp2515_write (MCP_TXB0D0+i, msg.Data[i]);
	}
	printf("Transmitting the Data\n");
     7ec:	8e e0       	ldi	r24, 0x0E	; 14
     7ee:	91 e0       	ldi	r25, 0x01	; 1
     7f0:	0e 94 80 14 	call	0x2900	; 0x2900 <puts>
	printf("ID: %d,\t Length:%d,\t Data[0]:%d,\t Data[1]:%d,\t Data[2]:%d \n",msg.Msg_ID,msg.Msg_length,msg.Data[0],msg.Data[1],msg.Data[2]);	
     7f4:	8e 81       	ldd	r24, Y+6	; 0x06
     7f6:	1f 92       	push	r1
     7f8:	8f 93       	push	r24
     7fa:	8d 81       	ldd	r24, Y+5	; 0x05
     7fc:	1f 92       	push	r1
     7fe:	8f 93       	push	r24
     800:	8c 81       	ldd	r24, Y+4	; 0x04
     802:	1f 92       	push	r1
     804:	8f 93       	push	r24
     806:	1f 92       	push	r1
     808:	0f 93       	push	r16
     80a:	9f 92       	push	r9
     80c:	8f 92       	push	r8
     80e:	84 e2       	ldi	r24, 0x24	; 36
     810:	91 e0       	ldi	r25, 0x01	; 1
     812:	9f 93       	push	r25
     814:	8f 93       	push	r24
     816:	0e 94 6a 14 	call	0x28d4	; 0x28d4 <printf>
	//Requesting to send the data
	mcp2515_request_to_send(MCP_RTS_TX0);
     81a:	81 e8       	ldi	r24, 0x81	; 129
     81c:	90 e0       	ldi	r25, 0x00	; 0
     81e:	0e 94 67 05 	call	0xace	; 0xace <mcp2515_request_to_send>
}
     822:	0f b6       	in	r0, 0x3f	; 63
     824:	f8 94       	cli
     826:	de bf       	out	0x3e, r29	; 62
     828:	0f be       	out	0x3f, r0	; 63
     82a:	cd bf       	out	0x3d, r28	; 61
     82c:	2b 96       	adiw	r28, 0x0b	; 11
     82e:	0f b6       	in	r0, 0x3f	; 63
     830:	f8 94       	cli
     832:	de bf       	out	0x3e, r29	; 62
     834:	0f be       	out	0x3f, r0	; 63
     836:	cd bf       	out	0x3d, r28	; 61
     838:	df 91       	pop	r29
     83a:	cf 91       	pop	r28
     83c:	1f 91       	pop	r17
     83e:	0f 91       	pop	r16
     840:	ff 90       	pop	r15
     842:	ef 90       	pop	r14
     844:	df 90       	pop	r13
     846:	cf 90       	pop	r12
     848:	bf 90       	pop	r11
     84a:	af 90       	pop	r10
     84c:	9f 90       	pop	r9
     84e:	8f 90       	pop	r8
     850:	08 95       	ret

00000852 <can_receive>:
/* 
Description: The function is used to receive the CAN messages
Input: Nothing
Output: Returns the CAN Message structure received by reading the Buffers
*/
CAN_Msg can_receive(){
     852:	6f 92       	push	r6
     854:	7f 92       	push	r7
     856:	8f 92       	push	r8
     858:	9f 92       	push	r9
     85a:	af 92       	push	r10
     85c:	bf 92       	push	r11
     85e:	cf 92       	push	r12
     860:	df 92       	push	r13
     862:	ef 92       	push	r14
     864:	ff 92       	push	r15
     866:	0f 93       	push	r16
     868:	1f 93       	push	r17
     86a:	cf 93       	push	r28
     86c:	df 93       	push	r29
     86e:	cd b7       	in	r28, 0x3d	; 61
     870:	de b7       	in	r29, 0x3e	; 62
     872:	2b 97       	sbiw	r28, 0x0b	; 11
     874:	0f b6       	in	r0, 0x3f	; 63
     876:	f8 94       	cli
     878:	de bf       	out	0x3e, r29	; 62
     87a:	0f be       	out	0x3f, r0	; 63
     87c:	cd bf       	out	0x3d, r28	; 61
     87e:	4c 01       	movw	r8, r24
	CAN_Msg msg;
	//Reading the Message ID from the MCP Rx
	int msg_ID_High = mcp2515_read(MCP_RXB0SIDH);
     880:	81 e6       	ldi	r24, 0x61	; 97
     882:	0e 94 27 05 	call	0xa4e	; 0xa4e <mcp2515_read>
     886:	a8 2e       	mov	r10, r24
	int msg_ID_Low = mcp2515_read(MCP_RXB0SIDL);
     888:	82 e6       	ldi	r24, 0x62	; 98
     88a:	0e 94 27 05 	call	0xa4e	; 0xa4e <mcp2515_read>
	msg.Msg_ID= (msg_ID_High<<3)| (msg_ID_Low>>5);
     88e:	b1 2c       	mov	r11, r1
     890:	aa 0c       	add	r10, r10
     892:	bb 1c       	adc	r11, r11
     894:	aa 0c       	add	r10, r10
     896:	bb 1c       	adc	r11, r11
     898:	aa 0c       	add	r10, r10
     89a:	bb 1c       	adc	r11, r11
     89c:	90 e0       	ldi	r25, 0x00	; 0
     89e:	95 95       	asr	r25
     8a0:	87 95       	ror	r24
     8a2:	95 95       	asr	r25
     8a4:	87 95       	ror	r24
     8a6:	95 95       	asr	r25
     8a8:	87 95       	ror	r24
     8aa:	95 95       	asr	r25
     8ac:	87 95       	ror	r24
     8ae:	95 95       	asr	r25
     8b0:	87 95       	ror	r24
     8b2:	a8 2a       	or	r10, r24
     8b4:	b9 2a       	or	r11, r25
	//Reading the Message Length from the MCP Rx
	int length = mcp2515_read(MCP_RXB0DLC);
     8b6:	85 e6       	ldi	r24, 0x65	; 101
     8b8:	0e 94 27 05 	call	0xa4e	; 0xa4e <mcp2515_read>
     8bc:	68 2e       	mov	r6, r24
     8be:	c8 2e       	mov	r12, r24
     8c0:	d1 2c       	mov	r13, r1
     8c2:	7e 01       	movw	r14, r28
     8c4:	84 e0       	ldi	r24, 0x04	; 4
     8c6:	e8 0e       	add	r14, r24
     8c8:	f1 1c       	adc	r15, r1
     8ca:	0f 2e       	mov	r0, r31
     8cc:	f6 e6       	ldi	r31, 0x66	; 102
     8ce:	7f 2e       	mov	r7, r31
     8d0:	f0 2d       	mov	r31, r0
     8d2:	00 e0       	ldi	r16, 0x00	; 0
     8d4:	10 e0       	ldi	r17, 0x00	; 0
	msg.Msg_length=length;
	//Reading the Data from the MCP Rx
	for(int i=0; i<=length; i++){
		msg.Data[i]=mcp2515_read(MCP_RXB0D0+i);
     8d6:	87 2d       	mov	r24, r7
     8d8:	0e 94 27 05 	call	0xa4e	; 0xa4e <mcp2515_read>
     8dc:	f7 01       	movw	r30, r14
     8de:	81 93       	st	Z+, r24
     8e0:	7f 01       	movw	r14, r30
	msg.Msg_ID= (msg_ID_High<<3)| (msg_ID_Low>>5);
	//Reading the Message Length from the MCP Rx
	int length = mcp2515_read(MCP_RXB0DLC);
	msg.Msg_length=length;
	//Reading the Data from the MCP Rx
	for(int i=0; i<=length; i++){
     8e2:	0f 5f       	subi	r16, 0xFF	; 255
     8e4:	1f 4f       	sbci	r17, 0xFF	; 255
     8e6:	73 94       	inc	r7
     8e8:	c0 16       	cp	r12, r16
     8ea:	d1 06       	cpc	r13, r17
     8ec:	a4 f7       	brge	.-24     	; 0x8d6 <can_receive+0x84>
		msg.Data[i]=mcp2515_read(MCP_RXB0D0+i);
	}
	mcp2515_bit_modify(MCP_CANINTF, MCP_RX0IF, 0);
     8ee:	40 e0       	ldi	r20, 0x00	; 0
     8f0:	61 e0       	ldi	r22, 0x01	; 1
     8f2:	8c e2       	ldi	r24, 0x2C	; 44
     8f4:	0e 94 7a 05 	call	0xaf4	; 0xaf4 <mcp2515_bit_modify>
	return msg;
     8f8:	ba 82       	std	Y+2, r11	; 0x02
     8fa:	a9 82       	std	Y+1, r10	; 0x01
     8fc:	6b 82       	std	Y+3, r6	; 0x03
     8fe:	8b e0       	ldi	r24, 0x0B	; 11
     900:	fe 01       	movw	r30, r28
     902:	31 96       	adiw	r30, 0x01	; 1
     904:	d4 01       	movw	r26, r8
     906:	01 90       	ld	r0, Z+
     908:	0d 92       	st	X+, r0
     90a:	8a 95       	dec	r24
     90c:	e1 f7       	brne	.-8      	; 0x906 <can_receive+0xb4>
     90e:	c4 01       	movw	r24, r8
     910:	2b 96       	adiw	r28, 0x0b	; 11
     912:	0f b6       	in	r0, 0x3f	; 63
     914:	f8 94       	cli
     916:	de bf       	out	0x3e, r29	; 62
     918:	0f be       	out	0x3f, r0	; 63
     91a:	cd bf       	out	0x3d, r28	; 61
     91c:	df 91       	pop	r29
     91e:	cf 91       	pop	r28
     920:	1f 91       	pop	r17
     922:	0f 91       	pop	r16
     924:	ff 90       	pop	r15
     926:	ef 90       	pop	r14
     928:	df 90       	pop	r13
     92a:	cf 90       	pop	r12
     92c:	bf 90       	pop	r11
     92e:	af 90       	pop	r10
     930:	9f 90       	pop	r9
     932:	8f 90       	pop	r8
     934:	7f 90       	pop	r7
     936:	6f 90       	pop	r6
     938:	08 95       	ret

0000093a <__vector_1>:
extern int default_mode;
extern int default_mode_end;
extern int replay_status;

//Interrupt hanlde INT0 is called when new CAN recieve messages arrives from the other nodes
ISR (INT0_vect){
     93a:	1f 92       	push	r1
     93c:	0f 92       	push	r0
     93e:	0f b6       	in	r0, 0x3f	; 63
     940:	0f 92       	push	r0
     942:	11 24       	eor	r1, r1
     944:	0f 93       	push	r16
     946:	1f 93       	push	r17
     948:	2f 93       	push	r18
     94a:	3f 93       	push	r19
     94c:	4f 93       	push	r20
     94e:	5f 93       	push	r21
     950:	6f 93       	push	r22
     952:	7f 93       	push	r23
     954:	8f 93       	push	r24
     956:	9f 93       	push	r25
     958:	af 93       	push	r26
     95a:	bf 93       	push	r27
     95c:	ef 93       	push	r30
     95e:	ff 93       	push	r31
     960:	cf 93       	push	r28
     962:	df 93       	push	r29
     964:	cd b7       	in	r28, 0x3d	; 61
     966:	de b7       	in	r29, 0x3e	; 62
     968:	2b 97       	sbiw	r28, 0x0b	; 11
     96a:	de bf       	out	0x3e, r29	; 62
     96c:	cd bf       	out	0x3d, r28	; 61
	CAN_Msg msg=can_receive();
     96e:	ce 01       	movw	r24, r28
     970:	01 96       	adiw	r24, 0x01	; 1
     972:	0e 94 29 04 	call	0x852	; 0x852 <can_receive>
	//If the message ID from Node 2 is 2, process the request otherwise no
	if(msg.Msg_ID == 2){
     976:	89 81       	ldd	r24, Y+1	; 0x01
     978:	9a 81       	ldd	r25, Y+2	; 0x02
     97a:	02 97       	sbiw	r24, 0x02	; 2
     97c:	09 f0       	breq	.+2      	; 0x980 <__vector_1+0x46>
     97e:	4c c0       	rjmp	.+152    	; 0xa18 <__vector_1+0xde>
		state =2;
     980:	82 e0       	ldi	r24, 0x02	; 2
     982:	90 e0       	ldi	r25, 0x00	; 0
     984:	90 93 d1 02 	sts	0x02D1, r25	; 0x8002d1 <state+0x1>
     988:	80 93 d0 02 	sts	0x02D0, r24	; 0x8002d0 <state>
		printf("ID: %d, Length:%d, Data:%d receive \n",msg.Msg_ID,msg.Msg_length,msg.Data[0]);
     98c:	8c 81       	ldd	r24, Y+4	; 0x04
     98e:	1f 92       	push	r1
     990:	8f 93       	push	r24
     992:	8b 81       	ldd	r24, Y+3	; 0x03
     994:	1f 92       	push	r1
     996:	8f 93       	push	r24
     998:	1f 92       	push	r1
     99a:	82 e0       	ldi	r24, 0x02	; 2
     99c:	8f 93       	push	r24
     99e:	80 e6       	ldi	r24, 0x60	; 96
     9a0:	91 e0       	ldi	r25, 0x01	; 1
     9a2:	9f 93       	push	r25
     9a4:	8f 93       	push	r24
     9a6:	0e 94 6a 14 	call	0x28d4	; 0x28d4 <printf>
		if(replay_status ==0)
     9aa:	0f b6       	in	r0, 0x3f	; 63
     9ac:	f8 94       	cli
     9ae:	de bf       	out	0x3e, r29	; 62
     9b0:	0f be       	out	0x3f, r0	; 63
     9b2:	cd bf       	out	0x3d, r28	; 61
     9b4:	80 91 be 02 	lds	r24, 0x02BE	; 0x8002be <replay_status>
     9b8:	90 91 bf 02 	lds	r25, 0x02BF	; 0x8002bf <replay_status+0x1>
     9bc:	89 2b       	or	r24, r25
     9be:	11 f4       	brne	.+4      	; 0x9c4 <__vector_1+0x8a>
		{
			update_HighScore();
     9c0:	0e 94 ee 05 	call	0xbdc	; 0xbdc <update_HighScore>
		}
		
		reset_oled();
     9c4:	0e 94 3f 0c 	call	0x187e	; 0x187e <reset_oled>
		oled_goto_line(3);
     9c8:	83 e0       	ldi	r24, 0x03	; 3
     9ca:	90 e0       	ldi	r25, 0x00	; 0
     9cc:	0e 94 01 0c 	call	0x1802	; 0x1802 <oled_goto_line>
		oled_goto_column(20);
     9d0:	84 e1       	ldi	r24, 0x14	; 20
     9d2:	90 e0       	ldi	r25, 0x00	; 0
     9d4:	0e 94 f8 0c 	call	0x19f0	; 0x19f0 <oled_goto_column>
		oled_print("GAME OVER",LARGE);
     9d8:	62 e0       	ldi	r22, 0x02	; 2
     9da:	85 e8       	ldi	r24, 0x85	; 133
     9dc:	91 e0       	ldi	r25, 0x01	; 1
     9de:	0e 94 20 0d 	call	0x1a40	; 0x1a40 <oled_print>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     9e2:	9f e3       	ldi	r25, 0x3F	; 63
     9e4:	22 e4       	ldi	r18, 0x42	; 66
     9e6:	8f e0       	ldi	r24, 0x0F	; 15
     9e8:	91 50       	subi	r25, 0x01	; 1
     9ea:	20 40       	sbci	r18, 0x00	; 0
     9ec:	80 40       	sbci	r24, 0x00	; 0
     9ee:	e1 f7       	brne	.-8      	; 0x9e8 <__vector_1+0xae>
     9f0:	00 c0       	rjmp	.+0      	; 0x9f2 <__vector_1+0xb8>
     9f2:	00 00       	nop
		_delay_ms(5000);
		//Reseting the score and mode
		present_score = 0;
     9f4:	10 92 c7 02 	sts	0x02C7, r1	; 0x8002c7 <present_score+0x1>
     9f8:	10 92 c6 02 	sts	0x02C6, r1	; 0x8002c6 <present_score>
		default_mode_end = 1;
     9fc:	01 e0       	ldi	r16, 0x01	; 1
     9fe:	10 e0       	ldi	r17, 0x00	; 0
     a00:	10 93 b3 02 	sts	0x02B3, r17	; 0x8002b3 <__data_end+0x1>
     a04:	00 93 b2 02 	sts	0x02B2, r16	; 0x8002b2 <__data_end>
		reset_oled();
     a08:	0e 94 3f 0c 	call	0x187e	; 0x187e <reset_oled>
		displayMenu();
     a0c:	0e 94 15 0b 	call	0x162a	; 0x162a <displayMenu>
		replay_status=1;
     a10:	10 93 bf 02 	sts	0x02BF, r17	; 0x8002bf <replay_status+0x1>
     a14:	00 93 be 02 	sts	0x02BE, r16	; 0x8002be <replay_status>
	}
}
     a18:	2b 96       	adiw	r28, 0x0b	; 11
     a1a:	0f b6       	in	r0, 0x3f	; 63
     a1c:	f8 94       	cli
     a1e:	de bf       	out	0x3e, r29	; 62
     a20:	0f be       	out	0x3f, r0	; 63
     a22:	cd bf       	out	0x3d, r28	; 61
     a24:	df 91       	pop	r29
     a26:	cf 91       	pop	r28
     a28:	ff 91       	pop	r31
     a2a:	ef 91       	pop	r30
     a2c:	bf 91       	pop	r27
     a2e:	af 91       	pop	r26
     a30:	9f 91       	pop	r25
     a32:	8f 91       	pop	r24
     a34:	7f 91       	pop	r23
     a36:	6f 91       	pop	r22
     a38:	5f 91       	pop	r21
     a3a:	4f 91       	pop	r20
     a3c:	3f 91       	pop	r19
     a3e:	2f 91       	pop	r18
     a40:	1f 91       	pop	r17
     a42:	0f 91       	pop	r16
     a44:	0f 90       	pop	r0
     a46:	0f be       	out	0x3f, r0	; 63
     a48:	0f 90       	pop	r0
     a4a:	1f 90       	pop	r1
     a4c:	18 95       	reti

00000a4e <mcp2515_read>:
Description: Reading the values from MCP2515
Input: Address from where it has to be read through SPI
Output: The value read from the SPI commands
*/
uint8_t mcp2515_read(uint8_t address)
{
     a4e:	cf 93       	push	r28
     a50:	c8 2f       	mov	r28, r24
	uint8_t result;
	//Select the slave
	slave_select();
     a52:	0e 94 45 0f 	call	0x1e8a	; 0x1e8a <slave_select>
	spi_write(MCP_READ);
     a56:	83 e0       	ldi	r24, 0x03	; 3
     a58:	90 e0       	ldi	r25, 0x00	; 0
     a5a:	0e 94 41 0f 	call	0x1e82	; 0x1e82 <spi_write>
	spi_write(address);
     a5e:	8c 2f       	mov	r24, r28
     a60:	90 e0       	ldi	r25, 0x00	; 0
     a62:	0e 94 41 0f 	call	0x1e82	; 0x1e82 <spi_write>
	result = spi_read();
     a66:	0e 94 3c 0f 	call	0x1e78	; 0x1e78 <spi_read>
     a6a:	c8 2f       	mov	r28, r24
	//De select the slave after reading
	slave_deselect();
     a6c:	0e 94 47 0f 	call	0x1e8e	; 0x1e8e <slave_deselect>
	return result;
}
     a70:	8c 2f       	mov	r24, r28
     a72:	cf 91       	pop	r28
     a74:	08 95       	ret

00000a76 <mcp2515_write>:
Description: Writing the values to MCP2515
Input: Data and address where it has to be written through SPI
Output: Nothing
*/
void mcp2515_write(uint8_t address, uint8_t data)
{
     a76:	cf 93       	push	r28
     a78:	df 93       	push	r29
     a7a:	d8 2f       	mov	r29, r24
     a7c:	c6 2f       	mov	r28, r22
	//Select the slave
	slave_select();
     a7e:	0e 94 45 0f 	call	0x1e8a	; 0x1e8a <slave_select>
	spi_write(MCP_WRITE);
     a82:	82 e0       	ldi	r24, 0x02	; 2
     a84:	90 e0       	ldi	r25, 0x00	; 0
     a86:	0e 94 41 0f 	call	0x1e82	; 0x1e82 <spi_write>
	spi_write(address);
     a8a:	8d 2f       	mov	r24, r29
     a8c:	90 e0       	ldi	r25, 0x00	; 0
     a8e:	0e 94 41 0f 	call	0x1e82	; 0x1e82 <spi_write>
	spi_write(data);
     a92:	8c 2f       	mov	r24, r28
     a94:	90 e0       	ldi	r25, 0x00	; 0
     a96:	0e 94 41 0f 	call	0x1e82	; 0x1e82 <spi_write>
	//De select the slave after writing
	slave_deselect();
     a9a:	0e 94 47 0f 	call	0x1e8e	; 0x1e8e <slave_deselect>
     a9e:	89 ef       	ldi	r24, 0xF9	; 249
     aa0:	90 e0       	ldi	r25, 0x00	; 0
     aa2:	01 97       	sbiw	r24, 0x01	; 1
     aa4:	f1 f7       	brne	.-4      	; 0xaa2 <mcp2515_write+0x2c>
     aa6:	00 c0       	rjmp	.+0      	; 0xaa8 <mcp2515_write+0x32>
     aa8:	00 00       	nop
	_delay_ms(1);
}
     aaa:	df 91       	pop	r29
     aac:	cf 91       	pop	r28
     aae:	08 95       	ret

00000ab0 <mcp2515_reset>:
Input: Nothing
Output: Nothing
*/
void mcp2515_reset()
{
	slave_select();
     ab0:	0e 94 45 0f 	call	0x1e8a	; 0x1e8a <slave_select>
	spi_write(MCP_RESET);
     ab4:	80 ec       	ldi	r24, 0xC0	; 192
     ab6:	90 e0       	ldi	r25, 0x00	; 0
     ab8:	0e 94 41 0f 	call	0x1e82	; 0x1e82 <spi_write>
	slave_deselect();
     abc:	0e 94 47 0f 	call	0x1e8e	; 0x1e8e <slave_deselect>
     ac0:	89 ef       	ldi	r24, 0xF9	; 249
     ac2:	90 e0       	ldi	r25, 0x00	; 0
     ac4:	01 97       	sbiw	r24, 0x01	; 1
     ac6:	f1 f7       	brne	.-4      	; 0xac4 <mcp2515_reset+0x14>
     ac8:	00 c0       	rjmp	.+0      	; 0xaca <mcp2515_reset+0x1a>
     aca:	00 00       	nop
     acc:	08 95       	ret

00000ace <mcp2515_request_to_send>:
Description:Request to send from the address
Input: Address
Output: Nothing
*/
void mcp2515_request_to_send(int address)
{
     ace:	cf 93       	push	r28
     ad0:	df 93       	push	r29
     ad2:	ec 01       	movw	r28, r24
	slave_select();
     ad4:	0e 94 45 0f 	call	0x1e8a	; 0x1e8a <slave_select>
	spi_write(address);
     ad8:	ce 01       	movw	r24, r28
     ada:	0e 94 41 0f 	call	0x1e82	; 0x1e82 <spi_write>
	slave_deselect();
     ade:	0e 94 47 0f 	call	0x1e8e	; 0x1e8e <slave_deselect>
     ae2:	89 ef       	ldi	r24, 0xF9	; 249
     ae4:	90 e0       	ldi	r25, 0x00	; 0
     ae6:	01 97       	sbiw	r24, 0x01	; 1
     ae8:	f1 f7       	brne	.-4      	; 0xae6 <mcp2515_request_to_send+0x18>
     aea:	00 c0       	rjmp	.+0      	; 0xaec <mcp2515_request_to_send+0x1e>
     aec:	00 00       	nop
	_delay_ms(1);
}
     aee:	df 91       	pop	r29
     af0:	cf 91       	pop	r28
     af2:	08 95       	ret

00000af4 <mcp2515_bit_modify>:
Description: Modfiying the bit 
Input: Nothing
Output: Nothing
*/
void mcp2515_bit_modify(uint8_t address,uint8_t mask, uint8_t data)
{
     af4:	1f 93       	push	r17
     af6:	cf 93       	push	r28
     af8:	df 93       	push	r29
     afa:	18 2f       	mov	r17, r24
     afc:	d6 2f       	mov	r29, r22
     afe:	c4 2f       	mov	r28, r20
	slave_select();
     b00:	0e 94 45 0f 	call	0x1e8a	; 0x1e8a <slave_select>
	spi_write(MCP_BITMOD);
     b04:	85 e0       	ldi	r24, 0x05	; 5
     b06:	90 e0       	ldi	r25, 0x00	; 0
     b08:	0e 94 41 0f 	call	0x1e82	; 0x1e82 <spi_write>
	spi_write(address);
     b0c:	81 2f       	mov	r24, r17
     b0e:	90 e0       	ldi	r25, 0x00	; 0
     b10:	0e 94 41 0f 	call	0x1e82	; 0x1e82 <spi_write>
	spi_write(mask);
     b14:	8d 2f       	mov	r24, r29
     b16:	90 e0       	ldi	r25, 0x00	; 0
     b18:	0e 94 41 0f 	call	0x1e82	; 0x1e82 <spi_write>
	spi_write(data);
     b1c:	8c 2f       	mov	r24, r28
     b1e:	90 e0       	ldi	r25, 0x00	; 0
     b20:	0e 94 41 0f 	call	0x1e82	; 0x1e82 <spi_write>
	slave_deselect();
     b24:	0e 94 47 0f 	call	0x1e8e	; 0x1e8e <slave_deselect>
     b28:	89 ef       	ldi	r24, 0xF9	; 249
     b2a:	90 e0       	ldi	r25, 0x00	; 0
     b2c:	01 97       	sbiw	r24, 0x01	; 1
     b2e:	f1 f7       	brne	.-4      	; 0xb2c <mcp2515_bit_modify+0x38>
     b30:	00 c0       	rjmp	.+0      	; 0xb32 <mcp2515_bit_modify+0x3e>
     b32:	00 00       	nop
	_delay_ms(1);
}
     b34:	df 91       	pop	r29
     b36:	cf 91       	pop	r28
     b38:	1f 91       	pop	r17
     b3a:	08 95       	ret

00000b3c <mcp2515_init>:
uint8_t mcp2515_init()
{
	uint8_t value;
	uint8_t BRP = ((CAN_F_CPU/(2 * TQ * BAUD_RATE)))-1;
	// Initialize SPI
	spi_init (); 
     b3c:	0e 94 34 0f 	call	0x1e68	; 0x1e68 <spi_init>
	// Send reset -command
	mcp2515_reset (); 
     b40:	0e 94 58 05 	call	0xab0	; 0xab0 <mcp2515_reset>
	// Self -test
	value = mcp2515_read(MCP_CANSTAT);
     b44:	8e e0       	ldi	r24, 0x0E	; 14
     b46:	0e 94 27 05 	call	0xa4e	; 0xa4e <mcp2515_read>
	if ((value & MODE_MASK) != MODE_CONFIG) {
     b4a:	80 7e       	andi	r24, 0xE0	; 224
     b4c:	80 38       	cpi	r24, 0x80	; 128
     b4e:	31 f0       	breq	.+12     	; 0xb5c <mcp2515_init+0x20>
		printf("MCP2515 is NOT in configuration mode after reset!\n");
     b50:	8f e8       	ldi	r24, 0x8F	; 143
     b52:	91 e0       	ldi	r25, 0x01	; 1
     b54:	0e 94 80 14 	call	0x2900	; 0x2900 <puts>
		return 1;
     b58:	81 e0       	ldi	r24, 0x01	; 1
     b5a:	08 95       	ret
	}	
	// Configuring CNF registers with 250kbps
	mcp2515_write(MCP_CNF1,SJW2|BRP);
     b5c:	61 e4       	ldi	r22, 0x41	; 65
     b5e:	8a e2       	ldi	r24, 0x2A	; 42
     b60:	0e 94 3b 05 	call	0xa76	; 0xa76 <mcp2515_write>
	mcp2515_write(MCP_CNF2,BTLMODE|PS1<<3|propagation_delay);
     b64:	65 eb       	ldi	r22, 0xB5	; 181
     b66:	89 e2       	ldi	r24, 0x29	; 41
     b68:	0e 94 3b 05 	call	0xa76	; 0xa76 <mcp2515_write>
	mcp2515_write(MCP_CNF3,PS2);
     b6c:	61 e0       	ldi	r22, 0x01	; 1
     b6e:	88 e2       	ldi	r24, 0x28	; 40
     b70:	0e 94 3b 05 	call	0xa76	; 0xa76 <mcp2515_write>
	
	// Settiing the MCP2515 to Normal mode for sending the data to other nodes
	mcp2515_write(MCP_CANCTRL,MODE_NORMAL);
     b74:	60 e0       	ldi	r22, 0x00	; 0
     b76:	8f e0       	ldi	r24, 0x0F	; 15
     b78:	0e 94 3b 05 	call	0xa76	; 0xa76 <mcp2515_write>
	value = mcp2515_read(MCP_CANSTAT);
     b7c:	8e e0       	ldi	r24, 0x0E	; 14
     b7e:	0e 94 27 05 	call	0xa4e	; 0xa4e <mcp2515_read>
	//Checking if the mode is in LoopBack mode or not
	if ((value & MODE_MASK) == MODE_LOOPBACK) {
     b82:	80 7e       	andi	r24, 0xE0	; 224
     b84:	80 34       	cpi	r24, 0x40	; 64
     b86:	71 f4       	brne	.+28     	; 0xba4 <mcp2515_init+0x68>
		printf("MCP2515 is in LoopBack configuration mode after %d reset!\n",(value & MODE_MASK));
     b88:	1f 92       	push	r1
     b8a:	8f 93       	push	r24
     b8c:	81 ec       	ldi	r24, 0xC1	; 193
     b8e:	91 e0       	ldi	r25, 0x01	; 1
     b90:	9f 93       	push	r25
     b92:	8f 93       	push	r24
     b94:	0e 94 6a 14 	call	0x28d4	; 0x28d4 <printf>
     b98:	0f 90       	pop	r0
     b9a:	0f 90       	pop	r0
     b9c:	0f 90       	pop	r0
     b9e:	0f 90       	pop	r0
	}
	return 0;
     ba0:	80 e0       	ldi	r24, 0x00	; 0
     ba2:	08 95       	ret
     ba4:	80 e0       	ldi	r24, 0x00	; 0
}
     ba6:	08 95       	ret

00000ba8 <EEPROM_write>:
(the reference for the source code is from Atmega162) 
*/
void EEPROM_write( int Address, int Data)
{
	/* Wait for completion of previous write */
	while(EECR & (1<<EEWE));
     ba8:	e1 99       	sbic	0x1c, 1	; 28
     baa:	fe cf       	rjmp	.-4      	; 0xba8 <EEPROM_write>
	/* Set up address and data registers */
	EEAR = Address;
     bac:	9f bb       	out	0x1f, r25	; 31
     bae:	8e bb       	out	0x1e, r24	; 30
	EEDR = Data;
     bb0:	6d bb       	out	0x1d, r22	; 29
	/* Write logical one to EEMWE */
	EECR |= (1<<EEMWE);
     bb2:	e2 9a       	sbi	0x1c, 2	; 28
	/* Start eeprom write by setting EEWE */
	EECR |= (1<<EEWE);
     bb4:	e1 9a       	sbi	0x1c, 1	; 28
     bb6:	08 95       	ret

00000bb8 <EEPROM_read>:
(the reference for the source code is from Atmega162) 
*/
int EEPROM_read(int Address)
{
	/* Wait for completion of previous write */
	while(EECR & (1<<EEWE));
     bb8:	e1 99       	sbic	0x1c, 1	; 28
     bba:	fe cf       	rjmp	.-4      	; 0xbb8 <EEPROM_read>
	/* Set up address register */
	EEAR = Address;
     bbc:	9f bb       	out	0x1f, r25	; 31
     bbe:	8e bb       	out	0x1e, r24	; 30
	/* Start eeprom read by writing EERE */
	EECR |= (1<<EERE);
     bc0:	e0 9a       	sbi	0x1c, 0	; 28
	/* Return data from data register */
	return EEDR;
     bc2:	8d b3       	in	r24, 0x1d	; 29
     bc4:	90 e0       	ldi	r25, 0x00	; 0
     bc6:	08 95       	ret

00000bc8 <update_present_score>:
Input: Nothing
Output: Nothing
*/
void update_present_score()
{
	present_score+= 1;
     bc8:	80 91 c6 02 	lds	r24, 0x02C6	; 0x8002c6 <present_score>
     bcc:	90 91 c7 02 	lds	r25, 0x02C7	; 0x8002c7 <present_score+0x1>
     bd0:	01 96       	adiw	r24, 0x01	; 1
     bd2:	90 93 c7 02 	sts	0x02C7, r25	; 0x8002c7 <present_score+0x1>
     bd6:	80 93 c6 02 	sts	0x02C6, r24	; 0x8002c6 <present_score>
     bda:	08 95       	ret

00000bdc <update_HighScore>:
/* 
Description: Updates the HighScore in EEPROM after the game has ended
Input: Nothing
Output: Nothing
*/
void update_HighScore(){
     bdc:	0f 93       	push	r16
     bde:	1f 93       	push	r17
     be0:	cf 93       	push	r28
     be2:	df 93       	push	r29
	if(Highscore_data[2] < present_score)
     be4:	20 91 cc 02 	lds	r18, 0x02CC	; 0x8002cc <Highscore_data+0x4>
     be8:	30 91 cd 02 	lds	r19, 0x02CD	; 0x8002cd <Highscore_data+0x5>
     bec:	80 91 c6 02 	lds	r24, 0x02C6	; 0x8002c6 <present_score>
     bf0:	90 91 c7 02 	lds	r25, 0x02C7	; 0x8002c7 <present_score+0x1>
     bf4:	28 17       	cp	r18, r24
     bf6:	39 07       	cpc	r19, r25
     bf8:	5c f4       	brge	.+22     	; 0xc10 <update_HighScore+0x34>
	{
		Highscore_data[0]=Highscore_data[1];
     bfa:	e8 ec       	ldi	r30, 0xC8	; 200
     bfc:	f2 e0       	ldi	r31, 0x02	; 2
     bfe:	42 81       	ldd	r20, Z+2	; 0x02
     c00:	53 81       	ldd	r21, Z+3	; 0x03
     c02:	51 83       	std	Z+1, r21	; 0x01
     c04:	40 83       	st	Z, r20
		Highscore_data[1]=Highscore_data[2];
     c06:	33 83       	std	Z+3, r19	; 0x03
     c08:	22 83       	std	Z+2, r18	; 0x02
		Highscore_data[2]=present_score;		
     c0a:	95 83       	std	Z+5, r25	; 0x05
     c0c:	84 83       	std	Z+4, r24	; 0x04
     c0e:	26 c0       	rjmp	.+76     	; 0xc5c <update_HighScore+0x80>
	}
	else if(Highscore_data[1] < present_score)
     c10:	20 91 ca 02 	lds	r18, 0x02CA	; 0x8002ca <Highscore_data+0x2>
     c14:	30 91 cb 02 	lds	r19, 0x02CB	; 0x8002cb <Highscore_data+0x3>
     c18:	28 17       	cp	r18, r24
     c1a:	39 07       	cpc	r19, r25
     c1c:	3c f4       	brge	.+14     	; 0xc2c <update_HighScore+0x50>
	{
		Highscore_data[0]=Highscore_data[1];
     c1e:	e8 ec       	ldi	r30, 0xC8	; 200
     c20:	f2 e0       	ldi	r31, 0x02	; 2
     c22:	31 83       	std	Z+1, r19	; 0x01
     c24:	20 83       	st	Z, r18
		Highscore_data[1]=present_score;		
     c26:	93 83       	std	Z+3, r25	; 0x03
     c28:	82 83       	std	Z+2, r24	; 0x02
     c2a:	18 c0       	rjmp	.+48     	; 0xc5c <update_HighScore+0x80>
	}
	else if(Highscore_data[0] < present_score)
     c2c:	20 91 c8 02 	lds	r18, 0x02C8	; 0x8002c8 <Highscore_data>
     c30:	30 91 c9 02 	lds	r19, 0x02C9	; 0x8002c9 <Highscore_data+0x1>
     c34:	28 17       	cp	r18, r24
     c36:	39 07       	cpc	r19, r25
     c38:	8c f4       	brge	.+34     	; 0xc5c <update_HighScore+0x80>
	{
		Highscore_data[0]=present_score;		
     c3a:	90 93 c9 02 	sts	0x02C9, r25	; 0x8002c9 <Highscore_data+0x1>
     c3e:	80 93 c8 02 	sts	0x02C8, r24	; 0x8002c8 <Highscore_data>
     c42:	0c c0       	rjmp	.+24     	; 0xc5c <update_HighScore+0x80>
	}
	for (int i = 0; i < MAX_HighScore;i++)
	{
		EEPROM_write(i,Highscore_data[i]);
     c44:	f8 01       	movw	r30, r16
     c46:	61 91       	ld	r22, Z+
     c48:	71 91       	ld	r23, Z+
     c4a:	8f 01       	movw	r16, r30
     c4c:	ce 01       	movw	r24, r28
     c4e:	0e 94 d4 05 	call	0xba8	; 0xba8 <EEPROM_write>
	}
	else if(Highscore_data[0] < present_score)
	{
		Highscore_data[0]=present_score;		
	}
	for (int i = 0; i < MAX_HighScore;i++)
     c52:	21 96       	adiw	r28, 0x01	; 1
     c54:	c3 30       	cpi	r28, 0x03	; 3
     c56:	d1 05       	cpc	r29, r1
     c58:	a9 f7       	brne	.-22     	; 0xc44 <update_HighScore+0x68>
     c5a:	05 c0       	rjmp	.+10     	; 0xc66 <update_HighScore+0x8a>
     c5c:	08 ec       	ldi	r16, 0xC8	; 200
     c5e:	12 e0       	ldi	r17, 0x02	; 2
/* 
Description: Updates the HighScore in EEPROM after the game has ended
Input: Nothing
Output: Nothing
*/
void update_HighScore(){
     c60:	c0 e0       	ldi	r28, 0x00	; 0
     c62:	d0 e0       	ldi	r29, 0x00	; 0
     c64:	ef cf       	rjmp	.-34     	; 0xc44 <update_HighScore+0x68>
	}
	for (int i = 0; i < MAX_HighScore;i++)
	{
		EEPROM_write(i,Highscore_data[i]);
	}
}
     c66:	df 91       	pop	r29
     c68:	cf 91       	pop	r28
     c6a:	1f 91       	pop	r17
     c6c:	0f 91       	pop	r16
     c6e:	08 95       	ret

00000c70 <read_HighScore>:
Description: Reads the HighScore from EEPROM
Input: Nothing
Output: Nothing
*/
void read_HighScore()
{
     c70:	0f 93       	push	r16
     c72:	1f 93       	push	r17
     c74:	cf 93       	push	r28
     c76:	df 93       	push	r29
     c78:	08 ec       	ldi	r16, 0xC8	; 200
     c7a:	12 e0       	ldi	r17, 0x02	; 2
	for (int i =MAX_HighScore; i>=0;i--)
     c7c:	c3 e0       	ldi	r28, 0x03	; 3
     c7e:	d0 e0       	ldi	r29, 0x00	; 0
	{
		current_HighScore[i] = EEPROM_read(i);
     c80:	ce 01       	movw	r24, r28
     c82:	0e 94 dc 05 	call	0xbb8	; 0xbb8 <EEPROM_read>
     c86:	f8 01       	movw	r30, r16
     c88:	92 93       	st	-Z, r25
     c8a:	82 93       	st	-Z, r24
     c8c:	8f 01       	movw	r16, r30
Input: Nothing
Output: Nothing
*/
void read_HighScore()
{
	for (int i =MAX_HighScore; i>=0;i--)
     c8e:	21 97       	sbiw	r28, 0x01	; 1
     c90:	b8 f7       	brcc	.-18     	; 0xc80 <read_HighScore+0x10>
	{
		current_HighScore[i] = EEPROM_read(i);
	}
     c92:	df 91       	pop	r29
     c94:	cf 91       	pop	r28
     c96:	1f 91       	pop	r17
     c98:	0f 91       	pop	r16
     c9a:	08 95       	ret

00000c9c <read_out_adc>:
/* 
Description: Reads the values from the ADC from the Multifunction board
Input: Nothing
Output: Returns the values of Joystick and Sliders from the Multifunction board
*/
Joystick read_out_adc(){
     c9c:	ff 92       	push	r15
     c9e:	0f 93       	push	r16
     ca0:	1f 93       	push	r17
     ca2:	cf 93       	push	r28
     ca4:	df 93       	push	r29
     ca6:	cd b7       	in	r28, 0x3d	; 61
     ca8:	de b7       	in	r29, 0x3e	; 62
     caa:	28 97       	sbiw	r28, 0x08	; 8
     cac:	0f b6       	in	r0, 0x3f	; 63
     cae:	f8 94       	cli
     cb0:	de bf       	out	0x3e, r29	; 62
     cb2:	0f be       	out	0x3f, r0	; 63
     cb4:	cd bf       	out	0x3d, r28	; 61
	Joystick toReturn;
	toReturn.Joystick_Y=read_adc(0);
     cb6:	80 e0       	ldi	r24, 0x00	; 0
     cb8:	0e 94 89 03 	call	0x712	; 0x712 <read_adc>
     cbc:	18 2f       	mov	r17, r24
	toReturn.Joystick_X=read_adc(1);
     cbe:	81 e0       	ldi	r24, 0x01	; 1
     cc0:	0e 94 89 03 	call	0x712	; 0x712 <read_adc>
     cc4:	08 2f       	mov	r16, r24
	toReturn.Slider_R=read_adc(2);
     cc6:	82 e0       	ldi	r24, 0x02	; 2
     cc8:	0e 94 89 03 	call	0x712	; 0x712 <read_adc>
     ccc:	f8 2e       	mov	r15, r24
	toReturn.Slider_L=read_adc(3);
     cce:	83 e0       	ldi	r24, 0x03	; 3
     cd0:	0e 94 89 03 	call	0x712	; 0x712 <read_adc>
	return toReturn;
     cd4:	20 2f       	mov	r18, r16
     cd6:	30 e0       	ldi	r19, 0x00	; 0
     cd8:	3a 83       	std	Y+2, r19	; 0x02
     cda:	29 83       	std	Y+1, r18	; 0x01
     cdc:	41 2f       	mov	r20, r17
     cde:	50 e0       	ldi	r21, 0x00	; 0
     ce0:	5c 83       	std	Y+4, r21	; 0x04
     ce2:	4b 83       	std	Y+3, r20	; 0x03
     ce4:	68 2f       	mov	r22, r24
     ce6:	70 e0       	ldi	r23, 0x00	; 0
     ce8:	7e 83       	std	Y+6, r23	; 0x06
     cea:	6d 83       	std	Y+5, r22	; 0x05
     cec:	8f 2d       	mov	r24, r15
     cee:	90 e0       	ldi	r25, 0x00	; 0
     cf0:	98 87       	std	Y+8, r25	; 0x08
     cf2:	8f 83       	std	Y+7, r24	; 0x07
     cf4:	3a 81       	ldd	r19, Y+2	; 0x02
     cf6:	5c 81       	ldd	r21, Y+4	; 0x04
     cf8:	7e 81       	ldd	r23, Y+6	; 0x06
}
     cfa:	98 85       	ldd	r25, Y+8	; 0x08
     cfc:	28 96       	adiw	r28, 0x08	; 8
     cfe:	0f b6       	in	r0, 0x3f	; 63
     d00:	f8 94       	cli
     d02:	de bf       	out	0x3e, r29	; 62
     d04:	0f be       	out	0x3f, r0	; 63
     d06:	cd bf       	out	0x3d, r28	; 61
     d08:	df 91       	pop	r29
     d0a:	cf 91       	pop	r28
     d0c:	1f 91       	pop	r17
     d0e:	0f 91       	pop	r16
     d10:	ff 90       	pop	r15
     d12:	08 95       	ret

00000d14 <Joystick_init>:
Description: The function is called during the Initialization where the offset values are read from the Multifunction board to make it to zero
Input: Nothing
Output: Nothing
*/
void Joystick_init(){
		intial_X=read_adc(1);
     d14:	81 e0       	ldi	r24, 0x01	; 1
     d16:	0e 94 89 03 	call	0x712	; 0x712 <read_adc>
     d1a:	90 e0       	ldi	r25, 0x00	; 0
     d1c:	90 93 d3 02 	sts	0x02D3, r25	; 0x8002d3 <intial_X+0x1>
     d20:	80 93 d2 02 	sts	0x02D2, r24	; 0x8002d2 <intial_X>
		intial_Y=read_adc(0);
     d24:	80 e0       	ldi	r24, 0x00	; 0
     d26:	0e 94 89 03 	call	0x712	; 0x712 <read_adc>
     d2a:	90 e0       	ldi	r25, 0x00	; 0
     d2c:	90 93 cf 02 	sts	0x02CF, r25	; 0x8002cf <intial_Y+0x1>
     d30:	80 93 ce 02 	sts	0x02CE, r24	; 0x8002ce <intial_Y>
     d34:	08 95       	ret

00000d36 <apply_transform>:
/* 
Description: Applying the transform function to recieve the values in specified range
Input: Nothing
Output: Returns the values of Joystick and Sliders after the transformation
*/
Joystick apply_transform (Joystick initial){
     d36:	ef 92       	push	r14
     d38:	ff 92       	push	r15
     d3a:	0f 93       	push	r16
     d3c:	1f 93       	push	r17
     d3e:	cf 93       	push	r28
     d40:	df 93       	push	r29
     d42:	cd b7       	in	r28, 0x3d	; 61
     d44:	de b7       	in	r29, 0x3e	; 62
     d46:	60 97       	sbiw	r28, 0x10	; 16
     d48:	0f b6       	in	r0, 0x3f	; 63
     d4a:	f8 94       	cli
     d4c:	de bf       	out	0x3e, r29	; 62
     d4e:	0f be       	out	0x3f, r0	; 63
     d50:	cd bf       	out	0x3d, r28	; 61
     d52:	29 87       	std	Y+9, r18	; 0x09
     d54:	3a 87       	std	Y+10, r19	; 0x0a
     d56:	4b 87       	std	Y+11, r20	; 0x0b
     d58:	5c 87       	std	Y+12, r21	; 0x0c
     d5a:	6d 87       	std	Y+13, r22	; 0x0d
     d5c:	7e 87       	std	Y+14, r23	; 0x0e
     d5e:	8f 87       	std	Y+15, r24	; 0x0f
     d60:	98 8b       	std	Y+16, r25	; 0x10
	 Joystick result;
	 result.Joystick_X=(initial.Joystick_X-intial_X);
	 result.Joystick_Y=(initial.Joystick_Y-intial_Y);
     d62:	0b 85       	ldd	r16, Y+11	; 0x0b
     d64:	1c 85       	ldd	r17, Y+12	; 0x0c
     d66:	80 91 ce 02 	lds	r24, 0x02CE	; 0x8002ce <intial_Y>
     d6a:	90 91 cf 02 	lds	r25, 0x02CF	; 0x8002cf <intial_Y+0x1>
     d6e:	08 1b       	sub	r16, r24
     d70:	19 0b       	sbc	r17, r25
	 result.Slider_L=(int)((initial.Slider_L-127.5)*200/255.0);
     d72:	6d 85       	ldd	r22, Y+13	; 0x0d
     d74:	7e 85       	ldd	r23, Y+14	; 0x0e
     d76:	07 2e       	mov	r0, r23
     d78:	00 0c       	add	r0, r0
     d7a:	88 0b       	sbc	r24, r24
     d7c:	99 0b       	sbc	r25, r25
     d7e:	0e 94 d4 11 	call	0x23a8	; 0x23a8 <__floatsisf>
     d82:	20 e0       	ldi	r18, 0x00	; 0
     d84:	30 e0       	ldi	r19, 0x00	; 0
     d86:	4f ef       	ldi	r20, 0xFF	; 255
     d88:	52 e4       	ldi	r21, 0x42	; 66
     d8a:	0e 94 bd 10 	call	0x217a	; 0x217a <__subsf3>
     d8e:	20 e0       	ldi	r18, 0x00	; 0
     d90:	30 e0       	ldi	r19, 0x00	; 0
     d92:	48 e4       	ldi	r20, 0x48	; 72
     d94:	53 e4       	ldi	r21, 0x43	; 67
     d96:	0e 94 60 12 	call	0x24c0	; 0x24c0 <__mulsf3>
     d9a:	20 e0       	ldi	r18, 0x00	; 0
     d9c:	30 e0       	ldi	r19, 0x00	; 0
     d9e:	4f e7       	ldi	r20, 0x7F	; 127
     da0:	53 e4       	ldi	r21, 0x43	; 67
     da2:	0e 94 2a 11 	call	0x2254	; 0x2254 <__divsf3>
     da6:	0e 94 9c 11 	call	0x2338	; 0x2338 <__fixsfsi>
     daa:	f6 2e       	mov	r15, r22
     dac:	e7 2e       	mov	r14, r23
	 result.Slider_R=(int)((initial.Slider_R-127.5)*200/255.0);
     dae:	6f 85       	ldd	r22, Y+15	; 0x0f
     db0:	78 89       	ldd	r23, Y+16	; 0x10
     db2:	07 2e       	mov	r0, r23
     db4:	00 0c       	add	r0, r0
     db6:	88 0b       	sbc	r24, r24
     db8:	99 0b       	sbc	r25, r25
     dba:	0e 94 d4 11 	call	0x23a8	; 0x23a8 <__floatsisf>
     dbe:	20 e0       	ldi	r18, 0x00	; 0
     dc0:	30 e0       	ldi	r19, 0x00	; 0
     dc2:	4f ef       	ldi	r20, 0xFF	; 255
     dc4:	52 e4       	ldi	r21, 0x42	; 66
     dc6:	0e 94 bd 10 	call	0x217a	; 0x217a <__subsf3>
     dca:	20 e0       	ldi	r18, 0x00	; 0
     dcc:	30 e0       	ldi	r19, 0x00	; 0
     dce:	48 e4       	ldi	r20, 0x48	; 72
     dd0:	53 e4       	ldi	r21, 0x43	; 67
     dd2:	0e 94 60 12 	call	0x24c0	; 0x24c0 <__mulsf3>
     dd6:	20 e0       	ldi	r18, 0x00	; 0
     dd8:	30 e0       	ldi	r19, 0x00	; 0
     dda:	4f e7       	ldi	r20, 0x7F	; 127
     ddc:	53 e4       	ldi	r21, 0x43	; 67
     dde:	0e 94 2a 11 	call	0x2254	; 0x2254 <__divsf3>
     de2:	0e 94 9c 11 	call	0x2338	; 0x2338 <__fixsfsi>
     de6:	86 2f       	mov	r24, r22
	 return result;
     de8:	29 85       	ldd	r18, Y+9	; 0x09
     dea:	3a 85       	ldd	r19, Y+10	; 0x0a
     dec:	40 91 d2 02 	lds	r20, 0x02D2	; 0x8002d2 <intial_X>
     df0:	50 91 d3 02 	lds	r21, 0x02D3	; 0x8002d3 <intial_X+0x1>
     df4:	24 1b       	sub	r18, r20
     df6:	35 0b       	sbc	r19, r21
     df8:	3a 83       	std	Y+2, r19	; 0x02
     dfa:	29 83       	std	Y+1, r18	; 0x01
     dfc:	1c 83       	std	Y+4, r17	; 0x04
     dfe:	0b 83       	std	Y+3, r16	; 0x03
     e00:	4f 2d       	mov	r20, r15
     e02:	5e 2d       	mov	r21, r14
     e04:	5e 83       	std	Y+6, r21	; 0x06
     e06:	4d 83       	std	Y+5, r20	; 0x05
     e08:	46 2f       	mov	r20, r22
     e0a:	57 2f       	mov	r21, r23
     e0c:	58 87       	std	Y+8, r21	; 0x08
     e0e:	4f 83       	std	Y+7, r20	; 0x07
     e10:	3a 81       	ldd	r19, Y+2	; 0x02
     e12:	40 2f       	mov	r20, r16
     e14:	5c 81       	ldd	r21, Y+4	; 0x04
     e16:	6f 2d       	mov	r22, r15
     e18:	7e 81       	ldd	r23, Y+6	; 0x06
}
     e1a:	98 85       	ldd	r25, Y+8	; 0x08
     e1c:	60 96       	adiw	r28, 0x10	; 16
     e1e:	0f b6       	in	r0, 0x3f	; 63
     e20:	f8 94       	cli
     e22:	de bf       	out	0x3e, r29	; 62
     e24:	0f be       	out	0x3f, r0	; 63
     e26:	cd bf       	out	0x3d, r28	; 61
     e28:	df 91       	pop	r29
     e2a:	cf 91       	pop	r28
     e2c:	1f 91       	pop	r17
     e2e:	0f 91       	pop	r16
     e30:	ff 90       	pop	r15
     e32:	ef 90       	pop	r14
     e34:	08 95       	ret

00000e36 <Direction_Joystick>:
/* 
Description: Function is used to determine the direction from the JoyStick
Input: Current values from the Joystick 
Output: Returns the direction of the JoyStick
*/
char* Direction_Joystick(Joystick current){
     e36:	cf 93       	push	r28
     e38:	df 93       	push	r29
     e3a:	cd b7       	in	r28, 0x3d	; 61
     e3c:	de b7       	in	r29, 0x3e	; 62
     e3e:	28 97       	sbiw	r28, 0x08	; 8
     e40:	0f b6       	in	r0, 0x3f	; 63
     e42:	f8 94       	cli
     e44:	de bf       	out	0x3e, r29	; 62
     e46:	0f be       	out	0x3f, r0	; 63
     e48:	cd bf       	out	0x3d, r28	; 61
     e4a:	29 83       	std	Y+1, r18	; 0x01
     e4c:	3a 83       	std	Y+2, r19	; 0x02
     e4e:	4b 83       	std	Y+3, r20	; 0x03
     e50:	5c 83       	std	Y+4, r21	; 0x04
     e52:	29 81       	ldd	r18, Y+1	; 0x01
     e54:	3a 81       	ldd	r19, Y+2	; 0x02
     e56:	8b 81       	ldd	r24, Y+3	; 0x03
     e58:	9c 81       	ldd	r25, Y+4	; 0x04
	if (current.Joystick_X>NOP && current.Joystick_X>=current.Joystick_Y)
     e5a:	26 30       	cpi	r18, 0x06	; 6
     e5c:	31 05       	cpc	r19, r1
     e5e:	24 f0       	brlt	.+8      	; 0xe68 <Direction_Joystick+0x32>
     e60:	28 17       	cp	r18, r24
     e62:	39 07       	cpc	r19, r25
     e64:	94 f1       	brlt	.+100    	; 0xeca <Direction_Joystick+0x94>
     e66:	19 c0       	rjmp	.+50     	; 0xe9a <Direction_Joystick+0x64>
		return "RIGHT";
	else if (current.Joystick_Y>NOP && current.Joystick_X<current.Joystick_Y)
     e68:	86 30       	cpi	r24, 0x06	; 6
     e6a:	91 05       	cpc	r25, r1
     e6c:	24 f0       	brlt	.+8      	; 0xe76 <Direction_Joystick+0x40>
     e6e:	28 17       	cp	r18, r24
     e70:	39 07       	cpc	r19, r25
     e72:	7c f5       	brge	.+94     	; 0xed2 <Direction_Joystick+0x9c>
     e74:	15 c0       	rjmp	.+42     	; 0xea0 <Direction_Joystick+0x6a>
		return "UP";
	else if (current.Joystick_Y<-NOP && current.Joystick_X>=current.Joystick_Y)
     e76:	8b 3f       	cpi	r24, 0xFB	; 251
     e78:	4f ef       	ldi	r20, 0xFF	; 255
     e7a:	94 07       	cpc	r25, r20
     e7c:	24 f4       	brge	.+8      	; 0xe86 <Direction_Joystick+0x50>
     e7e:	28 17       	cp	r18, r24
     e80:	39 07       	cpc	r19, r25
     e82:	6c f1       	brlt	.+90     	; 0xede <Direction_Joystick+0xa8>
     e84:	10 c0       	rjmp	.+32     	; 0xea6 <Direction_Joystick+0x70>
		return "DOWN";
	else if (current.Joystick_X<-NOP && current.Joystick_X<current.Joystick_Y)
     e86:	2b 3f       	cpi	r18, 0xFB	; 251
     e88:	4f ef       	ldi	r20, 0xFF	; 255
     e8a:	34 07       	cpc	r19, r20
     e8c:	7c f4       	brge	.+30     	; 0xeac <Direction_Joystick+0x76>
     e8e:	28 17       	cp	r18, r24
     e90:	39 07       	cpc	r19, r25
     e92:	7c f4       	brge	.+30     	; 0xeb2 <Direction_Joystick+0x7c>
		return "LEFT";
     e94:	84 e0       	ldi	r24, 0x04	; 4
     e96:	92 e0       	ldi	r25, 0x02	; 2
     e98:	2d c0       	rjmp	.+90     	; 0xef4 <Direction_Joystick+0xbe>
Input: Current values from the Joystick 
Output: Returns the direction of the JoyStick
*/
char* Direction_Joystick(Joystick current){
	if (current.Joystick_X>NOP && current.Joystick_X>=current.Joystick_Y)
		return "RIGHT";
     e9a:	8d e8       	ldi	r24, 0x8D	; 141
     e9c:	92 e0       	ldi	r25, 0x02	; 2
     e9e:	2a c0       	rjmp	.+84     	; 0xef4 <Direction_Joystick+0xbe>
	else if (current.Joystick_Y>NOP && current.Joystick_X<current.Joystick_Y)
		return "UP";
     ea0:	8c ef       	ldi	r24, 0xFC	; 252
     ea2:	91 e0       	ldi	r25, 0x01	; 1
     ea4:	27 c0       	rjmp	.+78     	; 0xef4 <Direction_Joystick+0xbe>
	else if (current.Joystick_Y<-NOP && current.Joystick_X>=current.Joystick_Y)
		return "DOWN";
     ea6:	8f ef       	ldi	r24, 0xFF	; 255
     ea8:	91 e0       	ldi	r25, 0x01	; 1
     eaa:	24 c0       	rjmp	.+72     	; 0xef4 <Direction_Joystick+0xbe>
	else if (current.Joystick_X<-NOP && current.Joystick_X<current.Joystick_Y)
		return "LEFT";
	else
		return "NEUTRAL";
     eac:	89 e0       	ldi	r24, 0x09	; 9
     eae:	92 e0       	ldi	r25, 0x02	; 2
     eb0:	21 c0       	rjmp	.+66     	; 0xef4 <Direction_Joystick+0xbe>
     eb2:	89 e0       	ldi	r24, 0x09	; 9
     eb4:	92 e0       	ldi	r25, 0x02	; 2
     eb6:	1e c0       	rjmp	.+60     	; 0xef4 <Direction_Joystick+0xbe>
*/
char* Direction_Joystick(Joystick current){
	if (current.Joystick_X>NOP && current.Joystick_X>=current.Joystick_Y)
		return "RIGHT";
	else if (current.Joystick_Y>NOP && current.Joystick_X<current.Joystick_Y)
		return "UP";
     eb8:	8c ef       	ldi	r24, 0xFC	; 252
     eba:	91 e0       	ldi	r25, 0x01	; 1
     ebc:	1b c0       	rjmp	.+54     	; 0xef4 <Direction_Joystick+0xbe>
	else if (current.Joystick_Y<-NOP && current.Joystick_X>=current.Joystick_Y)
		return "DOWN";
	else if (current.Joystick_X<-NOP && current.Joystick_X<current.Joystick_Y)
		return "LEFT";
	else
		return "NEUTRAL";
     ebe:	89 e0       	ldi	r24, 0x09	; 9
     ec0:	92 e0       	ldi	r25, 0x02	; 2
     ec2:	18 c0       	rjmp	.+48     	; 0xef4 <Direction_Joystick+0xbe>
     ec4:	89 e0       	ldi	r24, 0x09	; 9
     ec6:	92 e0       	ldi	r25, 0x02	; 2
     ec8:	15 c0       	rjmp	.+42     	; 0xef4 <Direction_Joystick+0xbe>
Output: Returns the direction of the JoyStick
*/
char* Direction_Joystick(Joystick current){
	if (current.Joystick_X>NOP && current.Joystick_X>=current.Joystick_Y)
		return "RIGHT";
	else if (current.Joystick_Y>NOP && current.Joystick_X<current.Joystick_Y)
     eca:	86 30       	cpi	r24, 0x06	; 6
     ecc:	91 05       	cpc	r25, r1
     ece:	a4 f7       	brge	.-24     	; 0xeb8 <Direction_Joystick+0x82>
     ed0:	0c c0       	rjmp	.+24     	; 0xeea <Direction_Joystick+0xb4>
		return "UP";
	else if (current.Joystick_Y<-NOP && current.Joystick_X>=current.Joystick_Y)
     ed2:	8b 3f       	cpi	r24, 0xFB	; 251
     ed4:	9f 4f       	sbci	r25, 0xFF	; 255
     ed6:	9c f7       	brge	.-26     	; 0xebe <Direction_Joystick+0x88>
		return "DOWN";
     ed8:	8f ef       	ldi	r24, 0xFF	; 255
     eda:	91 e0       	ldi	r25, 0x01	; 1
     edc:	0b c0       	rjmp	.+22     	; 0xef4 <Direction_Joystick+0xbe>
	else if (current.Joystick_X<-NOP && current.Joystick_X<current.Joystick_Y)
     ede:	2b 3f       	cpi	r18, 0xFB	; 251
     ee0:	3f 4f       	sbci	r19, 0xFF	; 255
     ee2:	84 f7       	brge	.-32     	; 0xec4 <Direction_Joystick+0x8e>
		return "LEFT";
     ee4:	84 e0       	ldi	r24, 0x04	; 4
     ee6:	92 e0       	ldi	r25, 0x02	; 2
     ee8:	05 c0       	rjmp	.+10     	; 0xef4 <Direction_Joystick+0xbe>
char* Direction_Joystick(Joystick current){
	if (current.Joystick_X>NOP && current.Joystick_X>=current.Joystick_Y)
		return "RIGHT";
	else if (current.Joystick_Y>NOP && current.Joystick_X<current.Joystick_Y)
		return "UP";
	else if (current.Joystick_Y<-NOP && current.Joystick_X>=current.Joystick_Y)
     eea:	8b 3f       	cpi	r24, 0xFB	; 251
     eec:	4f ef       	ldi	r20, 0xFF	; 255
     eee:	94 07       	cpc	r25, r20
     ef0:	b4 f3       	brlt	.-20     	; 0xede <Direction_Joystick+0xa8>
     ef2:	c9 cf       	rjmp	.-110    	; 0xe86 <Direction_Joystick+0x50>
		return "DOWN";
	else if (current.Joystick_X<-NOP && current.Joystick_X<current.Joystick_Y)
		return "LEFT";
	else
		return "NEUTRAL";
	}
     ef4:	28 96       	adiw	r28, 0x08	; 8
     ef6:	0f b6       	in	r0, 0x3f	; 63
     ef8:	f8 94       	cli
     efa:	de bf       	out	0x3e, r29	; 62
     efc:	0f be       	out	0x3f, r0	; 63
     efe:	cd bf       	out	0x3d, r28	; 61
     f00:	df 91       	pop	r29
     f02:	cf 91       	pop	r28
     f04:	08 95       	ret

00000f06 <Joystick_values>:
/* 
Description: Function is used to determine the JoyStick values 
Input: Current values from the Joystick 
Output: Returns the values of the JoyStick after transformation
*/
Joystick Joystick_values(Joystick current){
     f06:	8f 92       	push	r8
     f08:	9f 92       	push	r9
     f0a:	af 92       	push	r10
     f0c:	bf 92       	push	r11
     f0e:	cf 92       	push	r12
     f10:	df 92       	push	r13
     f12:	ef 92       	push	r14
     f14:	ff 92       	push	r15
     f16:	0f 93       	push	r16
     f18:	1f 93       	push	r17
     f1a:	cf 93       	push	r28
     f1c:	df 93       	push	r29
     f1e:	cd b7       	in	r28, 0x3d	; 61
     f20:	de b7       	in	r29, 0x3e	; 62
     f22:	60 97       	sbiw	r28, 0x10	; 16
     f24:	0f b6       	in	r0, 0x3f	; 63
     f26:	f8 94       	cli
     f28:	de bf       	out	0x3e, r29	; 62
     f2a:	0f be       	out	0x3f, r0	; 63
     f2c:	cd bf       	out	0x3d, r28	; 61
	current = read_out_adc();
     f2e:	0e 94 4e 06 	call	0xc9c	; 0xc9c <read_out_adc>
	current = apply_transform(current);
     f32:	0e 94 9b 06 	call	0xd36	; 0xd36 <apply_transform>
     f36:	29 87       	std	Y+9, r18	; 0x09
     f38:	3a 87       	std	Y+10, r19	; 0x0a
     f3a:	4b 87       	std	Y+11, r20	; 0x0b
     f3c:	5c 87       	std	Y+12, r21	; 0x0c
     f3e:	6d 87       	std	Y+13, r22	; 0x0d
     f40:	7e 87       	std	Y+14, r23	; 0x0e
     f42:	8f 87       	std	Y+15, r24	; 0x0f
     f44:	98 8b       	std	Y+16, r25	; 0x10
     f46:	69 85       	ldd	r22, Y+9	; 0x09
     f48:	7a 85       	ldd	r23, Y+10	; 0x0a
     f4a:	0b 85       	ldd	r16, Y+11	; 0x0b
     f4c:	1c 85       	ldd	r17, Y+12	; 0x0c
	if(current.Joystick_X >= 0)
     f4e:	77 23       	and	r23, r23
     f50:	54 f1       	brlt	.+84     	; 0xfa6 <Joystick_values+0xa0>
	{
		current.Joystick_X = ((current.Joystick_X) * 100.0/(255.0-intial_X));
     f52:	07 2e       	mov	r0, r23
     f54:	00 0c       	add	r0, r0
     f56:	88 0b       	sbc	r24, r24
     f58:	99 0b       	sbc	r25, r25
     f5a:	0e 94 d4 11 	call	0x23a8	; 0x23a8 <__floatsisf>
     f5e:	20 e0       	ldi	r18, 0x00	; 0
     f60:	30 e0       	ldi	r19, 0x00	; 0
     f62:	48 ec       	ldi	r20, 0xC8	; 200
     f64:	52 e4       	ldi	r21, 0x42	; 66
     f66:	0e 94 60 12 	call	0x24c0	; 0x24c0 <__mulsf3>
     f6a:	6b 01       	movw	r12, r22
     f6c:	7c 01       	movw	r14, r24
     f6e:	60 91 d2 02 	lds	r22, 0x02D2	; 0x8002d2 <intial_X>
     f72:	70 91 d3 02 	lds	r23, 0x02D3	; 0x8002d3 <intial_X+0x1>
     f76:	07 2e       	mov	r0, r23
     f78:	00 0c       	add	r0, r0
     f7a:	88 0b       	sbc	r24, r24
     f7c:	99 0b       	sbc	r25, r25
     f7e:	0e 94 d4 11 	call	0x23a8	; 0x23a8 <__floatsisf>
     f82:	9b 01       	movw	r18, r22
     f84:	ac 01       	movw	r20, r24
     f86:	60 e0       	ldi	r22, 0x00	; 0
     f88:	70 e0       	ldi	r23, 0x00	; 0
     f8a:	8f e7       	ldi	r24, 0x7F	; 127
     f8c:	93 e4       	ldi	r25, 0x43	; 67
     f8e:	0e 94 bd 10 	call	0x217a	; 0x217a <__subsf3>
     f92:	9b 01       	movw	r18, r22
     f94:	ac 01       	movw	r20, r24
     f96:	c7 01       	movw	r24, r14
     f98:	b6 01       	movw	r22, r12
     f9a:	0e 94 2a 11 	call	0x2254	; 0x2254 <__divsf3>
     f9e:	0e 94 9c 11 	call	0x2338	; 0x2338 <__fixsfsi>
     fa2:	7b 01       	movw	r14, r22
     fa4:	0d c0       	rjmp	.+26     	; 0xfc0 <Joystick_values+0xba>
	}
	else
	{
		current.Joystick_X = (((current.Joystick_X * 100)/intial_X));
     fa6:	24 e6       	ldi	r18, 0x64	; 100
     fa8:	26 9f       	mul	r18, r22
     faa:	c0 01       	movw	r24, r0
     fac:	27 9f       	mul	r18, r23
     fae:	90 0d       	add	r25, r0
     fb0:	11 24       	eor	r1, r1
     fb2:	60 91 d2 02 	lds	r22, 0x02D2	; 0x8002d2 <intial_X>
     fb6:	70 91 d3 02 	lds	r23, 0x02D3	; 0x8002d3 <intial_X+0x1>
     fba:	0e 94 cd 12 	call	0x259a	; 0x259a <__divmodhi4>
     fbe:	7b 01       	movw	r14, r22
	}
	if(current.Joystick_Y >= 0)
     fc0:	11 23       	and	r17, r17
     fc2:	4c f1       	brlt	.+82     	; 0x1016 <Joystick_values+0x110>
	{
		current.Joystick_Y = ((current.Joystick_Y) * 100.0/(255.0-intial_Y));
     fc4:	b8 01       	movw	r22, r16
     fc6:	11 0f       	add	r17, r17
     fc8:	88 0b       	sbc	r24, r24
     fca:	99 0b       	sbc	r25, r25
     fcc:	0e 94 d4 11 	call	0x23a8	; 0x23a8 <__floatsisf>
     fd0:	20 e0       	ldi	r18, 0x00	; 0
     fd2:	30 e0       	ldi	r19, 0x00	; 0
     fd4:	48 ec       	ldi	r20, 0xC8	; 200
     fd6:	52 e4       	ldi	r21, 0x42	; 66
     fd8:	0e 94 60 12 	call	0x24c0	; 0x24c0 <__mulsf3>
     fdc:	4b 01       	movw	r8, r22
     fde:	5c 01       	movw	r10, r24
     fe0:	60 91 ce 02 	lds	r22, 0x02CE	; 0x8002ce <intial_Y>
     fe4:	70 91 cf 02 	lds	r23, 0x02CF	; 0x8002cf <intial_Y+0x1>
     fe8:	07 2e       	mov	r0, r23
     fea:	00 0c       	add	r0, r0
     fec:	88 0b       	sbc	r24, r24
     fee:	99 0b       	sbc	r25, r25
     ff0:	0e 94 d4 11 	call	0x23a8	; 0x23a8 <__floatsisf>
     ff4:	9b 01       	movw	r18, r22
     ff6:	ac 01       	movw	r20, r24
     ff8:	60 e0       	ldi	r22, 0x00	; 0
     ffa:	70 e0       	ldi	r23, 0x00	; 0
     ffc:	8f e7       	ldi	r24, 0x7F	; 127
     ffe:	93 e4       	ldi	r25, 0x43	; 67
    1000:	0e 94 bd 10 	call	0x217a	; 0x217a <__subsf3>
    1004:	9b 01       	movw	r18, r22
    1006:	ac 01       	movw	r20, r24
    1008:	c5 01       	movw	r24, r10
    100a:	b4 01       	movw	r22, r8
    100c:	0e 94 2a 11 	call	0x2254	; 0x2254 <__divsf3>
    1010:	0e 94 9c 11 	call	0x2338	; 0x2338 <__fixsfsi>
    1014:	0c c0       	rjmp	.+24     	; 0x102e <Joystick_values+0x128>
	}
	else 
	{
		current.Joystick_Y = (((current.Joystick_Y * 100)/intial_Y));
    1016:	24 e6       	ldi	r18, 0x64	; 100
    1018:	20 9f       	mul	r18, r16
    101a:	c0 01       	movw	r24, r0
    101c:	21 9f       	mul	r18, r17
    101e:	90 0d       	add	r25, r0
    1020:	11 24       	eor	r1, r1
    1022:	60 91 ce 02 	lds	r22, 0x02CE	; 0x8002ce <intial_Y>
    1026:	70 91 cf 02 	lds	r23, 0x02CF	; 0x8002cf <intial_Y+0x1>
    102a:	0e 94 cd 12 	call	0x259a	; 0x259a <__divmodhi4>
	}
	
	return current;	
    102e:	fa 86       	std	Y+10, r15	; 0x0a
    1030:	e9 86       	std	Y+9, r14	; 0x09
    1032:	7c 87       	std	Y+12, r23	; 0x0c
    1034:	6b 87       	std	Y+11, r22	; 0x0b
    1036:	88 e0       	ldi	r24, 0x08	; 8
    1038:	fe 01       	movw	r30, r28
    103a:	39 96       	adiw	r30, 0x09	; 9
    103c:	de 01       	movw	r26, r28
    103e:	11 96       	adiw	r26, 0x01	; 1
    1040:	01 90       	ld	r0, Z+
    1042:	0d 92       	st	X+, r0
    1044:	8a 95       	dec	r24
    1046:	e1 f7       	brne	.-8      	; 0x1040 <Joystick_values+0x13a>
    1048:	29 81       	ldd	r18, Y+1	; 0x01
    104a:	3a 81       	ldd	r19, Y+2	; 0x02
    104c:	4b 81       	ldd	r20, Y+3	; 0x03
    104e:	5c 81       	ldd	r21, Y+4	; 0x04
    1050:	6d 81       	ldd	r22, Y+5	; 0x05
    1052:	7e 81       	ldd	r23, Y+6	; 0x06
}
    1054:	8f 81       	ldd	r24, Y+7	; 0x07
    1056:	98 85       	ldd	r25, Y+8	; 0x08
    1058:	60 96       	adiw	r28, 0x10	; 16
    105a:	0f b6       	in	r0, 0x3f	; 63
    105c:	f8 94       	cli
    105e:	de bf       	out	0x3e, r29	; 62
    1060:	0f be       	out	0x3f, r0	; 63
    1062:	cd bf       	out	0x3d, r28	; 61
    1064:	df 91       	pop	r29
    1066:	cf 91       	pop	r28
    1068:	1f 91       	pop	r17
    106a:	0f 91       	pop	r16
    106c:	ff 90       	pop	r15
    106e:	ef 90       	pop	r14
    1070:	df 90       	pop	r13
    1072:	cf 90       	pop	r12
    1074:	bf 90       	pop	r11
    1076:	af 90       	pop	r10
    1078:	9f 90       	pop	r9
    107a:	8f 90       	pop	r8
    107c:	08 95       	ret

0000107e <Joystick_info>:
/* 
Description: Function is used to provide the information of the Joystick
Input: Current values from the Joystick 
Output: Returns the values of the JoyStick after transformation
*/
 char* Joystick_info(Joystick current){
    107e:	cf 93       	push	r28
    1080:	df 93       	push	r29
    1082:	cd b7       	in	r28, 0x3d	; 61
    1084:	de b7       	in	r29, 0x3e	; 62
    1086:	28 97       	sbiw	r28, 0x08	; 8
    1088:	0f b6       	in	r0, 0x3f	; 63
    108a:	f8 94       	cli
    108c:	de bf       	out	0x3e, r29	; 62
    108e:	0f be       	out	0x3f, r0	; 63
    1090:	cd bf       	out	0x3d, r28	; 61
	current=Joystick_values(current);
    1092:	0e 94 83 07 	call	0xf06	; 0xf06 <Joystick_values>
	return Direction_Joystick(current);	
    1096:	0e 94 1b 07 	call	0xe36	; 0xe36 <Direction_Joystick>
}
    109a:	28 96       	adiw	r28, 0x08	; 8
    109c:	0f b6       	in	r0, 0x3f	; 63
    109e:	f8 94       	cli
    10a0:	de bf       	out	0x3e, r29	; 62
    10a2:	0f be       	out	0x3f, r0	; 63
    10a4:	cd bf       	out	0x3d, r28	; 61
    10a6:	df 91       	pop	r29
    10a8:	cf 91       	pop	r28
    10aa:	08 95       	ret

000010ac <send_input_singals>:
/* 
Description: Sends the CAN message to the other nodes when the game is started
Input: Nothing
Output: Nothing
*/
void send_input_singals(){
    10ac:	af 92       	push	r10
    10ae:	bf 92       	push	r11
    10b0:	cf 92       	push	r12
    10b2:	df 92       	push	r13
    10b4:	ef 92       	push	r14
    10b6:	ff 92       	push	r15
    10b8:	0f 93       	push	r16
    10ba:	1f 93       	push	r17
    10bc:	cf 93       	push	r28
    10be:	df 93       	push	r29
    10c0:	cd b7       	in	r28, 0x3d	; 61
    10c2:	de b7       	in	r29, 0x3e	; 62
    10c4:	6b 97       	sbiw	r28, 0x1b	; 27
    10c6:	0f b6       	in	r0, 0x3f	; 63
    10c8:	f8 94       	cli
    10ca:	de bf       	out	0x3e, r29	; 62
    10cc:	0f be       	out	0x3f, r0	; 63
    10ce:	cd bf       	out	0x3d, r28	; 61
		CAN_Msg message;
		Joystick current;
		//If the State is 1, then the game has started otherwise stops sending the transmitting messages
		while(state== 1)
    10d0:	80 91 d0 02 	lds	r24, 0x02D0	; 0x8002d0 <state>
    10d4:	90 91 d1 02 	lds	r25, 0x02D1	; 0x8002d1 <state+0x1>
    10d8:	01 97       	sbiw	r24, 0x01	; 1
    10da:	09 f0       	breq	.+2      	; 0x10de <send_input_singals+0x32>
    10dc:	6c c0       	rjmp	.+216    	; 0x11b6 <send_input_singals+0x10a>
		{			
			Joystick value= Joystick_values(current);
			//Configuring the message ID, Length and Data to be sent
			message.Msg_ID = 1;
    10de:	cc 24       	eor	r12, r12
    10e0:	c3 94       	inc	r12
    10e2:	d1 2c       	mov	r13, r1
			message.Msg_length = 3;
    10e4:	0f 2e       	mov	r0, r31
    10e6:	f3 e0       	ldi	r31, 0x03	; 3
    10e8:	bf 2e       	mov	r11, r31
    10ea:	f0 2d       	mov	r31, r0
			message.Data[1] = value.Slider_R+201;
		}
		//If the read_Slider Left button is pressed, Solenoid pin is activated by sending a data of  10
		if((PINB & 4)==4)
		{
			message.Data[2]=10;
    10ec:	0f 2e       	mov	r0, r31
    10ee:	fa e0       	ldi	r31, 0x0A	; 10
    10f0:	af 2e       	mov	r10, r31
    10f2:	f0 2d       	mov	r31, r0
		CAN_Msg message;
		Joystick current;
		//If the State is 1, then the game has started otherwise stops sending the transmitting messages
		while(state== 1)
		{			
			Joystick value= Joystick_values(current);
    10f4:	2c 85       	ldd	r18, Y+12	; 0x0c
    10f6:	3d 85       	ldd	r19, Y+13	; 0x0d
    10f8:	4e 85       	ldd	r20, Y+14	; 0x0e
    10fa:	5f 85       	ldd	r21, Y+15	; 0x0f
    10fc:	68 89       	ldd	r22, Y+16	; 0x10
    10fe:	79 89       	ldd	r23, Y+17	; 0x11
    1100:	8a 89       	ldd	r24, Y+18	; 0x12
    1102:	9b 89       	ldd	r25, Y+19	; 0x13
    1104:	0e 94 83 07 	call	0xf06	; 0xf06 <Joystick_values>
    1108:	2c 8b       	std	Y+20, r18	; 0x14
    110a:	3d 8b       	std	Y+21, r19	; 0x15
    110c:	4e 8b       	std	Y+22, r20	; 0x16
    110e:	5f 8b       	std	Y+23, r21	; 0x17
    1110:	68 8f       	std	Y+24, r22	; 0x18
    1112:	79 8f       	std	Y+25, r23	; 0x19
    1114:	8a 8f       	std	Y+26, r24	; 0x1a
    1116:	9b 8f       	std	Y+27, r25	; 0x1b
    1118:	8c 89       	ldd	r24, Y+20	; 0x14
    111a:	9d 89       	ldd	r25, Y+21	; 0x15
    111c:	2a 8d       	ldd	r18, Y+26	; 0x1a
    111e:	3b 8d       	ldd	r19, Y+27	; 0x1b
			//Configuring the message ID, Length and Data to be sent
			message.Msg_ID = 1;
    1120:	da 82       	std	Y+2, r13	; 0x02
    1122:	c9 82       	std	Y+1, r12	; 0x01
			message.Msg_length = 3;
    1124:	bb 82       	std	Y+3, r11	; 0x03
			if(value.Joystick_X<-5)
    1126:	8b 3f       	cpi	r24, 0xFB	; 251
    1128:	6f ef       	ldi	r22, 0xFF	; 255
    112a:	96 07       	cpc	r25, r22
    112c:	1c f4       	brge	.+6      	; 0x1134 <send_input_singals+0x88>
			{
				message.Data[0] = value.Joystick_X+201;
    112e:	87 53       	subi	r24, 0x37	; 55
    1130:	8c 83       	std	Y+4, r24	; 0x04
    1132:	09 c0       	rjmp	.+18     	; 0x1146 <send_input_singals+0x9a>
			}
			//If the data is NOP region, the data is sent as 0
			else if(5>value.Joystick_X && value.Joystick_X>-5)
    1134:	bc 01       	movw	r22, r24
    1136:	6c 5f       	subi	r22, 0xFC	; 252
    1138:	7f 4f       	sbci	r23, 0xFF	; 255
    113a:	69 30       	cpi	r22, 0x09	; 9
    113c:	71 05       	cpc	r23, r1
    113e:	10 f4       	brcc	.+4      	; 0x1144 <send_input_singals+0x98>
			{
				message.Data[0] = 0;
    1140:	1c 82       	std	Y+4, r1	; 0x04
    1142:	01 c0       	rjmp	.+2      	; 0x1146 <send_input_singals+0x9a>
			}
			else
			{
				message.Data[0] = value.Joystick_X;
    1144:	8c 83       	std	Y+4, r24	; 0x04
			else
			{
				message.Data[1] = value.Joystick_Y;
			}
		//Manipulating the Right slider values to minimize the issues of negative numbers
		if(value.Slider_R>0)
    1146:	12 16       	cp	r1, r18
    1148:	13 06       	cpc	r1, r19
    114a:	14 f4       	brge	.+4      	; 0x1150 <send_input_singals+0xa4>
		{
			message.Data[1] = value.Slider_R;
    114c:	2d 83       	std	Y+5, r18	; 0x05
    114e:	02 c0       	rjmp	.+4      	; 0x1154 <send_input_singals+0xa8>
		}
		else
		{
			message.Data[1] = value.Slider_R+201;
    1150:	27 53       	subi	r18, 0x37	; 55
    1152:	2d 83       	std	Y+5, r18	; 0x05
		}
		//If the read_Slider Left button is pressed, Solenoid pin is activated by sending a data of  10
		if((PINB & 4)==4)
    1154:	b2 9b       	sbis	0x16, 2	; 22
    1156:	02 c0       	rjmp	.+4      	; 0x115c <send_input_singals+0xb0>
		{
			message.Data[2]=10;
    1158:	ae 82       	std	Y+6, r10	; 0x06
    115a:	01 c0       	rjmp	.+2      	; 0x115e <send_input_singals+0xb2>
		}
		else
		{
			message.Data[2]=0;
    115c:	1e 82       	std	Y+6, r1	; 0x06
		}
		//Sending the CAN message to other nodes
		can_transmit(message);
    115e:	e9 80       	ldd	r14, Y+1	; 0x01
    1160:	fa 80       	ldd	r15, Y+2	; 0x02
    1162:	0b 81       	ldd	r16, Y+3	; 0x03
    1164:	1c 81       	ldd	r17, Y+4	; 0x04
    1166:	2d 81       	ldd	r18, Y+5	; 0x05
    1168:	3e 81       	ldd	r19, Y+6	; 0x06
    116a:	4f 81       	ldd	r20, Y+7	; 0x07
    116c:	58 85       	ldd	r21, Y+8	; 0x08
    116e:	69 85       	ldd	r22, Y+9	; 0x09
    1170:	7a 85       	ldd	r23, Y+10	; 0x0a
    1172:	8b 85       	ldd	r24, Y+11	; 0x0b
    1174:	0e 94 aa 03 	call	0x754	; 0x754 <can_transmit>
		//Updates the score until game is ended
 		update_present_score();
    1178:	0e 94 e4 05 	call	0xbc8	; 0xbc8 <update_present_score>
		//Storing the CAN messages of the current user to replay it later
		replay_store(message);
    117c:	e9 80       	ldd	r14, Y+1	; 0x01
    117e:	fa 80       	ldd	r15, Y+2	; 0x02
    1180:	0b 81       	ldd	r16, Y+3	; 0x03
    1182:	1c 81       	ldd	r17, Y+4	; 0x04
    1184:	2d 81       	ldd	r18, Y+5	; 0x05
    1186:	3e 81       	ldd	r19, Y+6	; 0x06
    1188:	4f 81       	ldd	r20, Y+7	; 0x07
    118a:	58 85       	ldd	r21, Y+8	; 0x08
    118c:	69 85       	ldd	r22, Y+9	; 0x09
    118e:	7a 85       	ldd	r23, Y+10	; 0x0a
    1190:	8b 85       	ldd	r24, Y+11	; 0x0b
    1192:	0e 94 52 0e 	call	0x1ca4	; 0x1ca4 <replay_store>
    1196:	9f ef       	ldi	r25, 0xFF	; 255
    1198:	2f eb       	ldi	r18, 0xBF	; 191
    119a:	63 e0       	ldi	r22, 0x03	; 3
    119c:	91 50       	subi	r25, 0x01	; 1
    119e:	20 40       	sbci	r18, 0x00	; 0
    11a0:	60 40       	sbci	r22, 0x00	; 0
    11a2:	e1 f7       	brne	.-8      	; 0x119c <send_input_singals+0xf0>
    11a4:	00 c0       	rjmp	.+0      	; 0x11a6 <send_input_singals+0xfa>
    11a6:	00 00       	nop
*/
void send_input_singals(){
		CAN_Msg message;
		Joystick current;
		//If the State is 1, then the game has started otherwise stops sending the transmitting messages
		while(state== 1)
    11a8:	80 91 d0 02 	lds	r24, 0x02D0	; 0x8002d0 <state>
    11ac:	90 91 d1 02 	lds	r25, 0x02D1	; 0x8002d1 <state+0x1>
    11b0:	01 97       	sbiw	r24, 0x01	; 1
    11b2:	09 f4       	brne	.+2      	; 0x11b6 <send_input_singals+0x10a>
    11b4:	9f cf       	rjmp	.-194    	; 0x10f4 <send_input_singals+0x48>
 		update_present_score();
		//Storing the CAN messages of the current user to replay it later
		replay_store(message);
		 _delay_ms(250);
	}
}
    11b6:	6b 96       	adiw	r28, 0x1b	; 27
    11b8:	0f b6       	in	r0, 0x3f	; 63
    11ba:	f8 94       	cli
    11bc:	de bf       	out	0x3e, r29	; 62
    11be:	0f be       	out	0x3f, r0	; 63
    11c0:	cd bf       	out	0x3d, r28	; 61
    11c2:	df 91       	pop	r29
    11c4:	cf 91       	pop	r28
    11c6:	1f 91       	pop	r17
    11c8:	0f 91       	pop	r16
    11ca:	ff 90       	pop	r15
    11cc:	ef 90       	pop	r14
    11ce:	df 90       	pop	r13
    11d0:	cf 90       	pop	r12
    11d2:	bf 90       	pop	r11
    11d4:	af 90       	pop	r10
    11d6:	08 95       	ret

000011d8 <easy_mode>:
Description: Depending on the user chosen mode, a CAN message is sent to assign the mode. Function for easy mode
Input: Nothing
Output: Nothing
*/
void easy_mode()
{
    11d8:	ef 92       	push	r14
    11da:	ff 92       	push	r15
    11dc:	0f 93       	push	r16
    11de:	1f 93       	push	r17
    11e0:	cf 93       	push	r28
    11e2:	df 93       	push	r29
    11e4:	cd b7       	in	r28, 0x3d	; 61
    11e6:	de b7       	in	r29, 0x3e	; 62
    11e8:	2b 97       	sbiw	r28, 0x0b	; 11
    11ea:	0f b6       	in	r0, 0x3f	; 63
    11ec:	f8 94       	cli
    11ee:	de bf       	out	0x3e, r29	; 62
    11f0:	0f be       	out	0x3f, r0	; 63
    11f2:	cd bf       	out	0x3d, r28	; 61
	CAN_Msg mode_msg;
	mode_msg.Msg_ID = 9;
    11f4:	89 e0       	ldi	r24, 0x09	; 9
    11f6:	e8 2e       	mov	r14, r24
    11f8:	89 83       	std	Y+1, r24	; 0x01
    11fa:	1a 82       	std	Y+2, r1	; 0x02
	mode_msg.Msg_length = 1;
    11fc:	81 e0       	ldi	r24, 0x01	; 1
    11fe:	8b 83       	std	Y+3, r24	; 0x03
	mode_msg.Data[0] = 1;
    1200:	8c 83       	std	Y+4, r24	; 0x04
	can_transmit(mode_msg);
    1202:	f1 2c       	mov	r15, r1
    1204:	01 e0       	ldi	r16, 0x01	; 1
    1206:	11 e0       	ldi	r17, 0x01	; 1
    1208:	2d 81       	ldd	r18, Y+5	; 0x05
    120a:	3e 81       	ldd	r19, Y+6	; 0x06
    120c:	4f 81       	ldd	r20, Y+7	; 0x07
    120e:	58 85       	ldd	r21, Y+8	; 0x08
    1210:	69 85       	ldd	r22, Y+9	; 0x09
    1212:	7a 85       	ldd	r23, Y+10	; 0x0a
    1214:	8b 85       	ldd	r24, Y+11	; 0x0b
    1216:	0e 94 aa 03 	call	0x754	; 0x754 <can_transmit>
    121a:	2f ef       	ldi	r18, 0xFF	; 255
    121c:	8f eb       	ldi	r24, 0xBF	; 191
    121e:	93 e0       	ldi	r25, 0x03	; 3
    1220:	21 50       	subi	r18, 0x01	; 1
    1222:	80 40       	sbci	r24, 0x00	; 0
    1224:	90 40       	sbci	r25, 0x00	; 0
    1226:	e1 f7       	brne	.-8      	; 0x1220 <easy_mode+0x48>
    1228:	00 c0       	rjmp	.+0      	; 0x122a <easy_mode+0x52>
    122a:	00 00       	nop
	_delay_ms(250);
}
    122c:	2b 96       	adiw	r28, 0x0b	; 11
    122e:	0f b6       	in	r0, 0x3f	; 63
    1230:	f8 94       	cli
    1232:	de bf       	out	0x3e, r29	; 62
    1234:	0f be       	out	0x3f, r0	; 63
    1236:	cd bf       	out	0x3d, r28	; 61
    1238:	df 91       	pop	r29
    123a:	cf 91       	pop	r28
    123c:	1f 91       	pop	r17
    123e:	0f 91       	pop	r16
    1240:	ff 90       	pop	r15
    1242:	ef 90       	pop	r14
    1244:	08 95       	ret

00001246 <difficult_mode>:
Description: Depending on the user chosen mode, a CAN message is sent to assign the mode. Function for difficult mode
Input: Nothing
Output: Nothing
*/
void difficult_mode()
{
    1246:	ef 92       	push	r14
    1248:	ff 92       	push	r15
    124a:	0f 93       	push	r16
    124c:	1f 93       	push	r17
    124e:	cf 93       	push	r28
    1250:	df 93       	push	r29
    1252:	cd b7       	in	r28, 0x3d	; 61
    1254:	de b7       	in	r29, 0x3e	; 62
    1256:	2b 97       	sbiw	r28, 0x0b	; 11
    1258:	0f b6       	in	r0, 0x3f	; 63
    125a:	f8 94       	cli
    125c:	de bf       	out	0x3e, r29	; 62
    125e:	0f be       	out	0x3f, r0	; 63
    1260:	cd bf       	out	0x3d, r28	; 61
	CAN_Msg mode_msg;
	mode_msg.Msg_ID = 9;
    1262:	89 e0       	ldi	r24, 0x09	; 9
    1264:	e8 2e       	mov	r14, r24
    1266:	89 83       	std	Y+1, r24	; 0x01
    1268:	1a 82       	std	Y+2, r1	; 0x02
	mode_msg.Msg_length = 1;
    126a:	81 e0       	ldi	r24, 0x01	; 1
    126c:	8b 83       	std	Y+3, r24	; 0x03
	mode_msg.Data[0] = 2;
    126e:	82 e0       	ldi	r24, 0x02	; 2
    1270:	8c 83       	std	Y+4, r24	; 0x04
	can_transmit(mode_msg);	
    1272:	f1 2c       	mov	r15, r1
    1274:	01 e0       	ldi	r16, 0x01	; 1
    1276:	12 e0       	ldi	r17, 0x02	; 2
    1278:	2d 81       	ldd	r18, Y+5	; 0x05
    127a:	3e 81       	ldd	r19, Y+6	; 0x06
    127c:	4f 81       	ldd	r20, Y+7	; 0x07
    127e:	58 85       	ldd	r21, Y+8	; 0x08
    1280:	69 85       	ldd	r22, Y+9	; 0x09
    1282:	7a 85       	ldd	r23, Y+10	; 0x0a
    1284:	8b 85       	ldd	r24, Y+11	; 0x0b
    1286:	0e 94 aa 03 	call	0x754	; 0x754 <can_transmit>
    128a:	2f ef       	ldi	r18, 0xFF	; 255
    128c:	8f eb       	ldi	r24, 0xBF	; 191
    128e:	93 e0       	ldi	r25, 0x03	; 3
    1290:	21 50       	subi	r18, 0x01	; 1
    1292:	80 40       	sbci	r24, 0x00	; 0
    1294:	90 40       	sbci	r25, 0x00	; 0
    1296:	e1 f7       	brne	.-8      	; 0x1290 <difficult_mode+0x4a>
    1298:	00 c0       	rjmp	.+0      	; 0x129a <difficult_mode+0x54>
    129a:	00 00       	nop
	_delay_ms(250);
    129c:	2b 96       	adiw	r28, 0x0b	; 11
    129e:	0f b6       	in	r0, 0x3f	; 63
    12a0:	f8 94       	cli
    12a2:	de bf       	out	0x3e, r29	; 62
    12a4:	0f be       	out	0x3f, r0	; 63
    12a6:	cd bf       	out	0x3d, r28	; 61
    12a8:	df 91       	pop	r29
    12aa:	cf 91       	pop	r28
    12ac:	1f 91       	pop	r17
    12ae:	0f 91       	pop	r16
    12b0:	ff 90       	pop	r15
    12b2:	ef 90       	pop	r14
    12b4:	08 95       	ret

000012b6 <Button>:
/* 
Description: Reads the SLider and Joystick buttons from Multifunction Board
Input: The head contains the data selected from the list in Menu
Output: Nothing
*/
void Button(Node* head){
    12b6:	af 92       	push	r10
    12b8:	bf 92       	push	r11
    12ba:	cf 92       	push	r12
    12bc:	df 92       	push	r13
    12be:	ef 92       	push	r14
    12c0:	ff 92       	push	r15
    12c2:	1f 93       	push	r17
    12c4:	cf 93       	push	r28
    12c6:	df 93       	push	r29
    12c8:	ec 01       	movw	r28, r24
	//Reading the value of the button
	int read_JoyStick_button_status = (PINB & 1);
    12ca:	86 b3       	in	r24, 0x16	; 22
	int read_Slider_Right_Button_status = (PINB & 2);
    12cc:	16 b3       	in	r17, 0x16	; 22
    12ce:	12 70       	andi	r17, 0x02	; 2
	//Checks if the button is pressed
	if(read_JoyStick_button_status == 0)
    12d0:	80 fd       	sbrc	r24, 0
    12d2:	30 c1       	rjmp	.+608    	; 0x1534 <Button+0x27e>
	{
		//When Start is pressed, the game starts
		if(head->data == "Start")
    12d4:	88 81       	ld	r24, Y
    12d6:	99 81       	ldd	r25, Y+1	; 0x01
    12d8:	81 51       	subi	r24, 0x11	; 17
    12da:	92 40       	sbci	r25, 0x02	; 2
    12dc:	b9 f5       	brne	.+110    	; 0x134c <Button+0x96>
			{
				reset_oled();
    12de:	0e 94 3f 0c 	call	0x187e	; 0x187e <reset_oled>
				state = 1;
    12e2:	81 e0       	ldi	r24, 0x01	; 1
    12e4:	90 e0       	ldi	r25, 0x00	; 0
    12e6:	90 93 d1 02 	sts	0x02D1, r25	; 0x8002d1 <state+0x1>
    12ea:	80 93 d0 02 	sts	0x02D0, r24	; 0x8002d0 <state>
				if(default_mode_end == 1)
    12ee:	80 91 b2 02 	lds	r24, 0x02B2	; 0x8002b2 <__data_end>
    12f2:	90 91 b3 02 	lds	r25, 0x02B3	; 0x8002b3 <__data_end+0x1>
    12f6:	01 97       	sbiw	r24, 0x01	; 1
    12f8:	31 f4       	brne	.+12     	; 0x1306 <Button+0x50>
				{
					default_mode=0;
    12fa:	10 92 b5 02 	sts	0x02B5, r1	; 0x8002b5 <default_mode+0x1>
    12fe:	10 92 b4 02 	sts	0x02B4, r1	; 0x8002b4 <default_mode>
					easy_mode();
    1302:	0e 94 ec 08 	call	0x11d8	; 0x11d8 <easy_mode>
				}
				if(default_mode == 0)
    1306:	80 91 b4 02 	lds	r24, 0x02B4	; 0x8002b4 <default_mode>
    130a:	90 91 b5 02 	lds	r25, 0x02B5	; 0x8002b5 <default_mode+0x1>
    130e:	89 2b       	or	r24, r25
    1310:	11 f4       	brne	.+4      	; 0x1316 <Button+0x60>
				{
					
					easy_mode();
    1312:	0e 94 ec 08 	call	0x11d8	; 0x11d8 <easy_mode>
				}
				reset_system_node_2();
    1316:	0e 94 99 0f 	call	0x1f32	; 0x1f32 <reset_system_node_2>
				OLED_timer(4,3,50);
    131a:	42 e3       	ldi	r20, 0x32	; 50
    131c:	50 e0       	ldi	r21, 0x00	; 0
    131e:	63 e0       	ldi	r22, 0x03	; 3
    1320:	70 e0       	ldi	r23, 0x00	; 0
    1322:	84 e0       	ldi	r24, 0x04	; 4
    1324:	90 e0       	ldi	r25, 0x00	; 0
    1326:	0e 94 2c 0e 	call	0x1c58	; 0x1c58 <OLED_timer>
				reset_oled();
    132a:	0e 94 3f 0c 	call	0x187e	; 0x187e <reset_oled>
				oled_goto_line(3);
    132e:	83 e0       	ldi	r24, 0x03	; 3
    1330:	90 e0       	ldi	r25, 0x00	; 0
    1332:	0e 94 01 0c 	call	0x1802	; 0x1802 <oled_goto_line>
				oled_goto_column(20);
    1336:	84 e1       	ldi	r24, 0x14	; 20
    1338:	90 e0       	ldi	r25, 0x00	; 0
    133a:	0e 94 f8 0c 	call	0x19f0	; 0x19f0 <oled_goto_column>
 				oled_print("GAME STARTED",LARGE);
    133e:	62 e0       	ldi	r22, 0x02	; 2
    1340:	87 e1       	ldi	r24, 0x17	; 23
    1342:	92 e0       	ldi	r25, 0x02	; 2
    1344:	0e 94 20 0d 	call	0x1a40	; 0x1a40 <oled_print>
 				send_input_singals(); 
    1348:	0e 94 56 08 	call	0x10ac	; 0x10ac <send_input_singals>
			}
		//When calibrated is pressed, the joystick is calibrated	
		if(head->data == "Calibrate")
    134c:	88 81       	ld	r24, Y
    134e:	99 81       	ldd	r25, Y+1	; 0x01
    1350:	84 52       	subi	r24, 0x24	; 36
    1352:	92 40       	sbci	r25, 0x02	; 2
    1354:	01 f5       	brne	.+64     	; 0x1396 <Button+0xe0>
			{
				Joystick_init();
    1356:	0e 94 8a 06 	call	0xd14	; 0xd14 <Joystick_init>
				reset_system_node_2();
    135a:	0e 94 99 0f 	call	0x1f32	; 0x1f32 <reset_system_node_2>
				reset_oled();
    135e:	0e 94 3f 0c 	call	0x187e	; 0x187e <reset_oled>
				oled_goto_line(3);
    1362:	83 e0       	ldi	r24, 0x03	; 3
    1364:	90 e0       	ldi	r25, 0x00	; 0
    1366:	0e 94 01 0c 	call	0x1802	; 0x1802 <oled_goto_line>
				oled_goto_column(30);
    136a:	8e e1       	ldi	r24, 0x1E	; 30
    136c:	90 e0       	ldi	r25, 0x00	; 0
    136e:	0e 94 f8 0c 	call	0x19f0	; 0x19f0 <oled_goto_column>
 				oled_print("CALIBRATED",MEDIUM);
    1372:	61 e0       	ldi	r22, 0x01	; 1
    1374:	8e e2       	ldi	r24, 0x2E	; 46
    1376:	92 e0       	ldi	r25, 0x02	; 2
    1378:	0e 94 20 0d 	call	0x1a40	; 0x1a40 <oled_print>
    137c:	ff ef       	ldi	r31, 0xFF	; 255
    137e:	2f ef       	ldi	r18, 0xFF	; 255
    1380:	8d e1       	ldi	r24, 0x1D	; 29
    1382:	f1 50       	subi	r31, 0x01	; 1
    1384:	20 40       	sbci	r18, 0x00	; 0
    1386:	80 40       	sbci	r24, 0x00	; 0
    1388:	e1 f7       	brne	.-8      	; 0x1382 <Button+0xcc>
    138a:	00 c0       	rjmp	.+0      	; 0x138c <Button+0xd6>
    138c:	00 00       	nop
				_delay_ms(2000);
				reset_oled();
    138e:	0e 94 3f 0c 	call	0x187e	; 0x187e <reset_oled>
				displayMenu();	
    1392:	0e 94 15 0b 	call	0x162a	; 0x162a <displayMenu>
			}
		//When Replay is pressed, the current user how they played game will be replayed by retrieving the values from SRAM
		if(head->data == "Replay")
    1396:	88 81       	ld	r24, Y
    1398:	99 81       	ldd	r25, Y+1	; 0x01
    139a:	89 53       	subi	r24, 0x39	; 57
    139c:	92 40       	sbci	r25, 0x02	; 2
    139e:	41 f5       	brne	.+80     	; 0x13f0 <Button+0x13a>
		{
			reset_system_node_2();
    13a0:	0e 94 99 0f 	call	0x1f32	; 0x1f32 <reset_system_node_2>
			if(default_mode == 2)
    13a4:	80 91 b4 02 	lds	r24, 0x02B4	; 0x8002b4 <default_mode>
    13a8:	90 91 b5 02 	lds	r25, 0x02B5	; 0x8002b5 <default_mode+0x1>
    13ac:	02 97       	sbiw	r24, 0x02	; 2
    13ae:	19 f4       	brne	.+6      	; 0x13b6 <Button+0x100>
			{
				difficult_mode();
    13b0:	0e 94 23 09 	call	0x1246	; 0x1246 <difficult_mode>
    13b4:	02 c0       	rjmp	.+4      	; 0x13ba <Button+0x104>
			}
			else
			{
				easy_mode();
    13b6:	0e 94 ec 08 	call	0x11d8	; 0x11d8 <easy_mode>
			}
			reset_oled();
    13ba:	0e 94 3f 0c 	call	0x187e	; 0x187e <reset_oled>
			oled_goto_line(3);
    13be:	83 e0       	ldi	r24, 0x03	; 3
    13c0:	90 e0       	ldi	r25, 0x00	; 0
    13c2:	0e 94 01 0c 	call	0x1802	; 0x1802 <oled_goto_line>
			oled_goto_column(10);
    13c6:	8a e0       	ldi	r24, 0x0A	; 10
    13c8:	90 e0       	ldi	r25, 0x00	; 0
    13ca:	0e 94 f8 0c 	call	0x19f0	; 0x19f0 <oled_goto_column>
			oled_print("REPLAY STARTED",LARGE);
    13ce:	62 e0       	ldi	r22, 0x02	; 2
    13d0:	80 e4       	ldi	r24, 0x40	; 64
    13d2:	92 e0       	ldi	r25, 0x02	; 2
    13d4:	0e 94 20 0d 	call	0x1a40	; 0x1a40 <oled_print>
			replay_retrieve();
    13d8:	0e 94 ba 0e 	call	0x1d74	; 0x1d74 <replay_retrieve>
			reset_oled();
    13dc:	0e 94 3f 0c 	call	0x187e	; 0x187e <reset_oled>
			displayMenu();	
    13e0:	0e 94 15 0b 	call	0x162a	; 0x162a <displayMenu>
			replay_status=1;
    13e4:	81 e0       	ldi	r24, 0x01	; 1
    13e6:	90 e0       	ldi	r25, 0x00	; 0
    13e8:	90 93 bf 02 	sts	0x02BF, r25	; 0x8002bf <replay_status+0x1>
    13ec:	80 93 be 02 	sts	0x02BE, r24	; 0x8002be <replay_status>
		}
		//When Highscore is pressed, Displays the Highscore in OLED 
		if(head->data == "Highscore")
    13f0:	88 81       	ld	r24, Y
    13f2:	99 81       	ldd	r25, Y+1	; 0x01
    13f4:	8f 54       	subi	r24, 0x4F	; 79
    13f6:	92 40       	sbci	r25, 0x02	; 2
    13f8:	c9 f5       	brne	.+114    	; 0x146c <Button+0x1b6>
		{	
			reset_oled();
    13fa:	0e 94 3f 0c 	call	0x187e	; 0x187e <reset_oled>
			oled_print("HIGHSCORES",LARGE);
    13fe:	62 e0       	ldi	r22, 0x02	; 2
    1400:	89 e5       	ldi	r24, 0x59	; 89
    1402:	92 e0       	ldi	r25, 0x02	; 2
    1404:	0e 94 20 0d 	call	0x1a40	; 0x1a40 <oled_print>
			read_HighScore();
    1408:	0e 94 38 06 	call	0xc70	; 0xc70 <read_HighScore>
    140c:	0f 2e       	mov	r0, r31
    140e:	f0 ec       	ldi	r31, 0xC0	; 192
    1410:	cf 2e       	mov	r12, r31
    1412:	f2 e0       	ldi	r31, 0x02	; 2
    1414:	df 2e       	mov	r13, r31
    1416:	f0 2d       	mov	r31, r0
    1418:	68 94       	set
    141a:	ee 24       	eor	r14, r14
    141c:	e1 f8       	bld	r14, 1
    141e:	f1 2c       	mov	r15, r1
			char* temp=NULL;
			for(int i=0;i<3;i++)
			{	
				int current_value =current_HighScore[i];
				temp = convertIntegerToChar(current_value);
    1420:	f6 01       	movw	r30, r12
    1422:	81 91       	ld	r24, Z+
    1424:	91 91       	ld	r25, Z+
    1426:	6f 01       	movw	r12, r30
    1428:	0e 94 8c 0d 	call	0x1b18	; 0x1b18 <convertIntegerToChar>
    142c:	5c 01       	movw	r10, r24
				oled_goto_line(i+2);
    142e:	c7 01       	movw	r24, r14
    1430:	0e 94 01 0c 	call	0x1802	; 0x1802 <oled_goto_line>
				oled_goto_column(35);
    1434:	83 e2       	ldi	r24, 0x23	; 35
    1436:	90 e0       	ldi	r25, 0x00	; 0
    1438:	0e 94 f8 0c 	call	0x19f0	; 0x19f0 <oled_goto_column>
				oled_print(temp,LARGE);	
    143c:	62 e0       	ldi	r22, 0x02	; 2
    143e:	c5 01       	movw	r24, r10
    1440:	0e 94 20 0d 	call	0x1a40	; 0x1a40 <oled_print>
    1444:	ff ef       	ldi	r31, 0xFF	; 255
    1446:	ef 1a       	sub	r14, r31
    1448:	ff 0a       	sbc	r15, r31
		{	
			reset_oled();
			oled_print("HIGHSCORES",LARGE);
			read_HighScore();
			char* temp=NULL;
			for(int i=0;i<3;i++)
    144a:	25 e0       	ldi	r18, 0x05	; 5
    144c:	e2 16       	cp	r14, r18
    144e:	f1 04       	cpc	r15, r1
    1450:	39 f7       	brne	.-50     	; 0x1420 <Button+0x16a>
    1452:	8f ef       	ldi	r24, 0xFF	; 255
    1454:	9f ef       	ldi	r25, 0xFF	; 255
    1456:	ec e2       	ldi	r30, 0x2C	; 44
    1458:	81 50       	subi	r24, 0x01	; 1
    145a:	90 40       	sbci	r25, 0x00	; 0
    145c:	e0 40       	sbci	r30, 0x00	; 0
    145e:	e1 f7       	brne	.-8      	; 0x1458 <Button+0x1a2>
    1460:	00 c0       	rjmp	.+0      	; 0x1462 <Button+0x1ac>
    1462:	00 c0       	rjmp	.+0      	; 0x1464 <Button+0x1ae>
				oled_goto_line(i+2);
				oled_goto_column(35);
				oled_print(temp,LARGE);	
			}
			_delay_ms(3000);
			reset_oled();
    1464:	0e 94 3f 0c 	call	0x187e	; 0x187e <reset_oled>
			displayMenu();		
    1468:	0e 94 15 0b 	call	0x162a	; 0x162a <displayMenu>
		}
		//When Mode is pressed, Displays the modes to be chosen
		if(head->data == "Mode")
    146c:	88 81       	ld	r24, Y
    146e:	99 81       	ldd	r25, Y+1	; 0x01
    1470:	84 56       	subi	r24, 0x64	; 100
    1472:	92 40       	sbci	r25, 0x02	; 2
    1474:	69 f4       	brne	.+26     	; 0x1490 <Button+0x1da>
		{
			reset_oled();
    1476:	0e 94 3f 0c 	call	0x187e	; 0x187e <reset_oled>
    147a:	2f ef       	ldi	r18, 0xFF	; 255
    147c:	8f ef       	ldi	r24, 0xFF	; 255
    147e:	9d e1       	ldi	r25, 0x1D	; 29
    1480:	21 50       	subi	r18, 0x01	; 1
    1482:	80 40       	sbci	r24, 0x00	; 0
    1484:	90 40       	sbci	r25, 0x00	; 0
    1486:	e1 f7       	brne	.-8      	; 0x1480 <Button+0x1ca>
    1488:	00 c0       	rjmp	.+0      	; 0x148a <Button+0x1d4>
    148a:	00 00       	nop
			_delay_ms(2000);
			Sub_displayMenu();
    148c:	0e 94 7f 0b 	call	0x16fe	; 0x16fe <Sub_displayMenu>
		}
		//When Exit is pressed, exits from the game
		if(head->data == "Contrast")
    1490:	88 81       	ld	r24, Y
    1492:	99 81       	ldd	r25, Y+1	; 0x01
    1494:	89 56       	subi	r24, 0x69	; 105
    1496:	92 40       	sbci	r25, 0x02	; 2
    1498:	21 f4       	brne	.+8      	; 0x14a2 <Button+0x1ec>
		{
			reset_oled();
    149a:	0e 94 3f 0c 	call	0x187e	; 0x187e <reset_oled>
			Sub_displayMenu_contrast();
    149e:	0e 94 bb 0b 	call	0x1776	; 0x1776 <Sub_displayMenu_contrast>
		}
		//When Easy mode is pressed, the CAN message is sent to the node2 to make the game simpler
		if(head->data == "EASY")
    14a2:	88 81       	ld	r24, Y
    14a4:	99 81       	ldd	r25, Y+1	; 0x01
    14a6:	82 57       	subi	r24, 0x72	; 114
    14a8:	92 40       	sbci	r25, 0x02	; 2
    14aa:	61 f4       	brne	.+24     	; 0x14c4 <Button+0x20e>
		{	
			easy_mode();
    14ac:	0e 94 ec 08 	call	0x11d8	; 0x11d8 <easy_mode>
			default_mode=1;
    14b0:	81 e0       	ldi	r24, 0x01	; 1
    14b2:	90 e0       	ldi	r25, 0x00	; 0
    14b4:	90 93 b5 02 	sts	0x02B5, r25	; 0x8002b5 <default_mode+0x1>
    14b8:	80 93 b4 02 	sts	0x02B4, r24	; 0x8002b4 <default_mode>
			reset_oled();
    14bc:	0e 94 3f 0c 	call	0x187e	; 0x187e <reset_oled>
			displayMenu();
    14c0:	0e 94 15 0b 	call	0x162a	; 0x162a <displayMenu>
		}
		//When Difficult mode is pressed, the CAN message is sent to the node2 to make the game Tough
		if(head->data == "DIFFICULT")
    14c4:	88 81       	ld	r24, Y
    14c6:	99 81       	ldd	r25, Y+1	; 0x01
    14c8:	87 57       	subi	r24, 0x77	; 119
    14ca:	92 40       	sbci	r25, 0x02	; 2
    14cc:	61 f4       	brne	.+24     	; 0x14e6 <Button+0x230>
		{
			difficult_mode();
    14ce:	0e 94 23 09 	call	0x1246	; 0x1246 <difficult_mode>
			default_mode = 2;
    14d2:	82 e0       	ldi	r24, 0x02	; 2
    14d4:	90 e0       	ldi	r25, 0x00	; 0
    14d6:	90 93 b5 02 	sts	0x02B5, r25	; 0x8002b5 <default_mode+0x1>
    14da:	80 93 b4 02 	sts	0x02B4, r24	; 0x8002b4 <default_mode>
			reset_oled();
    14de:	0e 94 3f 0c 	call	0x187e	; 0x187e <reset_oled>
			displayMenu();		
    14e2:	0e 94 15 0b 	call	0x162a	; 0x162a <displayMenu>
		}
		//When LOW contrast is pressed, the brightness is low
		if(head->data == "LOW")
    14e6:	88 81       	ld	r24, Y
    14e8:	99 81       	ldd	r25, Y+1	; 0x01
    14ea:	81 58       	subi	r24, 0x81	; 129
    14ec:	92 40       	sbci	r25, 0x02	; 2
    14ee:	41 f4       	brne	.+16     	; 0x1500 <Button+0x24a>
		{
			contrast(50);
    14f0:	82 e3       	ldi	r24, 0x32	; 50
    14f2:	90 e0       	ldi	r25, 0x00	; 0
    14f4:	0e 94 45 0e 	call	0x1c8a	; 0x1c8a <contrast>
			reset_oled();
    14f8:	0e 94 3f 0c 	call	0x187e	; 0x187e <reset_oled>
			displayMenu();
    14fc:	0e 94 15 0b 	call	0x162a	; 0x162a <displayMenu>
		}
		//When LOW contrast is pressed, the brightness is medium
		if(head->data == "MEDIUM")
    1500:	88 81       	ld	r24, Y
    1502:	99 81       	ldd	r25, Y+1	; 0x01
    1504:	85 58       	subi	r24, 0x85	; 133
    1506:	92 40       	sbci	r25, 0x02	; 2
    1508:	41 f4       	brne	.+16     	; 0x151a <Button+0x264>
		{
			contrast(150);
    150a:	86 e9       	ldi	r24, 0x96	; 150
    150c:	90 e0       	ldi	r25, 0x00	; 0
    150e:	0e 94 45 0e 	call	0x1c8a	; 0x1c8a <contrast>
			reset_oled();
    1512:	0e 94 3f 0c 	call	0x187e	; 0x187e <reset_oled>
			displayMenu();
    1516:	0e 94 15 0b 	call	0x162a	; 0x162a <displayMenu>
		}
		//When BRIGHT contrast is pressed, the brightness is high
		if(head->data == "BRIGHT")
    151a:	88 81       	ld	r24, Y
    151c:	99 81       	ldd	r25, Y+1	; 0x01
    151e:	8c 58       	subi	r24, 0x8C	; 140
    1520:	92 40       	sbci	r25, 0x02	; 2
    1522:	41 f4       	brne	.+16     	; 0x1534 <Button+0x27e>
		{
			contrast(255);
    1524:	8f ef       	ldi	r24, 0xFF	; 255
    1526:	90 e0       	ldi	r25, 0x00	; 0
    1528:	0e 94 45 0e 	call	0x1c8a	; 0x1c8a <contrast>
			reset_oled();
    152c:	0e 94 3f 0c 	call	0x187e	; 0x187e <reset_oled>
			displayMenu();
    1530:	0e 94 15 0b 	call	0x162a	; 0x162a <displayMenu>
		}
	}
	//Checks if the Right Slider button is pressed and displays the main menu
	if(read_Slider_Right_Button_status == 2)
    1534:	12 30       	cpi	r17, 0x02	; 2
    1536:	21 f4       	brne	.+8      	; 0x1540 <Button+0x28a>
	{
		reset_oled();
    1538:	0e 94 3f 0c 	call	0x187e	; 0x187e <reset_oled>
		head=displayMenu();	
    153c:	0e 94 15 0b 	call	0x162a	; 0x162a <displayMenu>
	}
	
}
    1540:	df 91       	pop	r29
    1542:	cf 91       	pop	r28
    1544:	1f 91       	pop	r17
    1546:	ff 90       	pop	r15
    1548:	ef 90       	pop	r14
    154a:	df 90       	pop	r13
    154c:	cf 90       	pop	r12
    154e:	bf 90       	pop	r11
    1550:	af 90       	pop	r10
    1552:	08 95       	ret

00001554 <create_new_node>:
Description: Creation of a new node and allocating the memory
Input: Data and size of the new node to be created
Output: Returns the new node after creation
*/
Node* create_new_node(char* data,int size)
{
    1554:	cf 93       	push	r28
    1556:	df 93       	push	r29
    1558:	ec 01       	movw	r28, r24
	Node* new_node = (Node*)malloc(sizeof(Node));
    155a:	8a e0       	ldi	r24, 0x0A	; 10
    155c:	90 e0       	ldi	r25, 0x00	; 0
    155e:	0e 94 f5 12 	call	0x25ea	; 0x25ea <malloc>
    1562:	fc 01       	movw	r30, r24
	new_node->data = data;
    1564:	d1 83       	std	Z+1, r29	; 0x01
    1566:	c0 83       	st	Z, r28
	if(length%2==0)
    1568:	80 91 b8 02 	lds	r24, 0x02B8	; 0x8002b8 <length>
    156c:	80 fd       	sbrc	r24, 0
    156e:	0b c0       	rjmp	.+22     	; 0x1586 <create_new_node+0x32>
	{
		new_node->column=10;
    1570:	8a e0       	ldi	r24, 0x0A	; 10
    1572:	90 e0       	ldi	r25, 0x00	; 0
    1574:	95 83       	std	Z+5, r25	; 0x05
    1576:	84 83       	std	Z+4, r24	; 0x04
		new_node->line=page;
    1578:	80 91 b6 02 	lds	r24, 0x02B6	; 0x8002b6 <page>
    157c:	90 91 b7 02 	lds	r25, 0x02B7	; 0x8002b7 <page+0x1>
    1580:	93 83       	std	Z+3, r25	; 0x03
    1582:	82 83       	std	Z+2, r24	; 0x02
    1584:	0f c0       	rjmp	.+30     	; 0x15a4 <create_new_node+0x50>
	}
	else
	{
		new_node->column=70;
    1586:	86 e4       	ldi	r24, 0x46	; 70
    1588:	90 e0       	ldi	r25, 0x00	; 0
    158a:	95 83       	std	Z+5, r25	; 0x05
    158c:	84 83       	std	Z+4, r24	; 0x04
		new_node->line=page;
    158e:	80 91 b6 02 	lds	r24, 0x02B6	; 0x8002b6 <page>
    1592:	90 91 b7 02 	lds	r25, 0x02B7	; 0x8002b7 <page+0x1>
    1596:	93 83       	std	Z+3, r25	; 0x03
    1598:	82 83       	std	Z+2, r24	; 0x02
		page+=3;
    159a:	03 96       	adiw	r24, 0x03	; 3
    159c:	90 93 b7 02 	sts	0x02B7, r25	; 0x8002b7 <page+0x1>
    15a0:	80 93 b6 02 	sts	0x02B6, r24	; 0x8002b6 <page>
	}
	new_node->next = NULL;
    15a4:	17 82       	std	Z+7, r1	; 0x07
    15a6:	16 82       	std	Z+6, r1	; 0x06
	new_node->prev = NULL;
    15a8:	11 86       	std	Z+9, r1	; 0x09
    15aa:	10 86       	std	Z+8, r1	; 0x08
	return new_node;
}
    15ac:	cf 01       	movw	r24, r30
    15ae:	df 91       	pop	r29
    15b0:	cf 91       	pop	r28
    15b2:	08 95       	ret

000015b4 <append_linked_list>:
Description: Appending the new node to the linked list and a Circular Linked list is implemented
Input: Data
Output: Nothing
*/
void append_linked_list(char* data)
{
    15b4:	cf 93       	push	r28
    15b6:	df 93       	push	r29
	Node* new_node = create_new_node(data,length);
    15b8:	60 91 b8 02 	lds	r22, 0x02B8	; 0x8002b8 <length>
    15bc:	70 91 b9 02 	lds	r23, 0x02B9	; 0x8002b9 <length+0x1>
    15c0:	0e 94 aa 0a 	call	0x1554	; 0x1554 <create_new_node>
	Node* temp = NULL;
	//Checks if the head is the first node
	if (head==NULL)
    15c4:	a0 91 ba 02 	lds	r26, 0x02BA	; 0x8002ba <head>
    15c8:	b0 91 bb 02 	lds	r27, 0x02BB	; 0x8002bb <head+0x1>
    15cc:	10 97       	sbiw	r26, 0x00	; 0
    15ce:	71 f4       	brne	.+28     	; 0x15ec <append_linked_list+0x38>
	{
		head=new_node;
    15d0:	90 93 bb 02 	sts	0x02BB, r25	; 0x8002bb <head+0x1>
    15d4:	80 93 ba 02 	sts	0x02BA, r24	; 0x8002ba <head>
		new_node->next=head;
    15d8:	dc 01       	movw	r26, r24
    15da:	17 96       	adiw	r26, 0x07	; 7
    15dc:	9c 93       	st	X, r25
    15de:	8e 93       	st	-X, r24
    15e0:	16 97       	sbiw	r26, 0x06	; 6
		new_node->prev=head;
    15e2:	19 96       	adiw	r26, 0x09	; 9
    15e4:	9c 93       	st	X, r25
    15e6:	8e 93       	st	-X, r24
    15e8:	18 97       	sbiw	r26, 0x08	; 8
    15ea:	13 c0       	rjmp	.+38     	; 0x1612 <append_linked_list+0x5e>
    15ec:	fd 01       	movw	r30, r26
    15ee:	01 c0       	rjmp	.+2      	; 0x15f2 <append_linked_list+0x3e>
	{
		temp=head;
		//Loop until the last second one of the linked list where the last node is not same
		while(temp->next!=head)
		{
			temp=temp->next;
    15f0:	f9 01       	movw	r30, r18
	}
	else
	{
		temp=head;
		//Loop until the last second one of the linked list where the last node is not same
		while(temp->next!=head)
    15f2:	26 81       	ldd	r18, Z+6	; 0x06
    15f4:	37 81       	ldd	r19, Z+7	; 0x07
    15f6:	a2 17       	cp	r26, r18
    15f8:	b3 07       	cpc	r27, r19
    15fa:	d1 f7       	brne	.-12     	; 0x15f0 <append_linked_list+0x3c>
		{
			temp=temp->next;
		}
		temp->next=new_node;
    15fc:	97 83       	std	Z+7, r25	; 0x07
    15fe:	86 83       	std	Z+6, r24	; 0x06
		new_node->next=head;
    1600:	ec 01       	movw	r28, r24
    1602:	bf 83       	std	Y+7, r27	; 0x07
    1604:	ae 83       	std	Y+6, r26	; 0x06
		head->prev=new_node;
    1606:	19 96       	adiw	r26, 0x09	; 9
    1608:	9c 93       	st	X, r25
    160a:	8e 93       	st	-X, r24
    160c:	18 97       	sbiw	r26, 0x08	; 8
		new_node->prev=temp;
    160e:	f9 87       	std	Y+9, r31	; 0x09
    1610:	e8 87       	std	Y+8, r30	; 0x08
	}
	length++;
    1612:	80 91 b8 02 	lds	r24, 0x02B8	; 0x8002b8 <length>
    1616:	90 91 b9 02 	lds	r25, 0x02B9	; 0x8002b9 <length+0x1>
    161a:	01 96       	adiw	r24, 0x01	; 1
    161c:	90 93 b9 02 	sts	0x02B9, r25	; 0x8002b9 <length+0x1>
    1620:	80 93 b8 02 	sts	0x02B8, r24	; 0x8002b8 <length>
}
    1624:	df 91       	pop	r29
    1626:	cf 91       	pop	r28
    1628:	08 95       	ret

0000162a <displayMenu>:
Description: Display the attributes which needs to be displayed on the OLED
Input: Data
Output: Returns the node structure
*/
Node* displayMenu()
{
    162a:	cf 93       	push	r28
    162c:	df 93       	push	r29
	reset_oled();
    162e:	0e 94 3f 0c 	call	0x187e	; 0x187e <reset_oled>
	head=NULL;
    1632:	10 92 bb 02 	sts	0x02BB, r1	; 0x8002bb <head+0x1>
    1636:	10 92 ba 02 	sts	0x02BA, r1	; 0x8002ba <head>
	length=0;
    163a:	10 92 b9 02 	sts	0x02B9, r1	; 0x8002b9 <length+0x1>
    163e:	10 92 b8 02 	sts	0x02B8, r1	; 0x8002b8 <length>
	page=0;
    1642:	10 92 b7 02 	sts	0x02B7, r1	; 0x8002b7 <page+0x1>
    1646:	10 92 b6 02 	sts	0x02B6, r1	; 0x8002b6 <page>
	append_linked_list("Start");
    164a:	81 e1       	ldi	r24, 0x11	; 17
    164c:	92 e0       	ldi	r25, 0x02	; 2
    164e:	0e 94 da 0a 	call	0x15b4	; 0x15b4 <append_linked_list>
	append_linked_list("Highscore");
    1652:	8f e4       	ldi	r24, 0x4F	; 79
    1654:	92 e0       	ldi	r25, 0x02	; 2
    1656:	0e 94 da 0a 	call	0x15b4	; 0x15b4 <append_linked_list>
	append_linked_list("Calibrate");
    165a:	84 e2       	ldi	r24, 0x24	; 36
    165c:	92 e0       	ldi	r25, 0x02	; 2
    165e:	0e 94 da 0a 	call	0x15b4	; 0x15b4 <append_linked_list>
	append_linked_list("Replay");
    1662:	89 e3       	ldi	r24, 0x39	; 57
    1664:	92 e0       	ldi	r25, 0x02	; 2
    1666:	0e 94 da 0a 	call	0x15b4	; 0x15b4 <append_linked_list>
	append_linked_list("Mode");
    166a:	84 e6       	ldi	r24, 0x64	; 100
    166c:	92 e0       	ldi	r25, 0x02	; 2
    166e:	0e 94 da 0a 	call	0x15b4	; 0x15b4 <append_linked_list>
	append_linked_list("Contrast");
    1672:	89 e6       	ldi	r24, 0x69	; 105
    1674:	92 e0       	ldi	r25, 0x02	; 2
    1676:	0e 94 da 0a 	call	0x15b4	; 0x15b4 <append_linked_list>
	/*from front*/
	Node* temp = head;
    167a:	c0 91 ba 02 	lds	r28, 0x02BA	; 0x8002ba <head>
    167e:	d0 91 bb 02 	lds	r29, 0x02BB	; 0x8002bb <head+0x1>
	do
	{
		//arranging elements based on 2 columms
		oled_goto_line(temp->line);
    1682:	8a 81       	ldd	r24, Y+2	; 0x02
    1684:	9b 81       	ldd	r25, Y+3	; 0x03
    1686:	0e 94 01 0c 	call	0x1802	; 0x1802 <oled_goto_line>
		oled_goto_column(temp->column);	
    168a:	8c 81       	ldd	r24, Y+4	; 0x04
    168c:	9d 81       	ldd	r25, Y+5	; 0x05
    168e:	0e 94 f8 0c 	call	0x19f0	; 0x19f0 <oled_goto_column>
		//writing data to the oled 	
		oled_print(temp->data,MEDIUM);		
    1692:	61 e0       	ldi	r22, 0x01	; 1
    1694:	88 81       	ld	r24, Y
    1696:	99 81       	ldd	r25, Y+1	; 0x01
    1698:	0e 94 20 0d 	call	0x1a40	; 0x1a40 <oled_print>
		temp=temp->next;		
    169c:	0e 80       	ldd	r0, Y+6	; 0x06
    169e:	df 81       	ldd	r29, Y+7	; 0x07
    16a0:	c0 2d       	mov	r28, r0
	}while(temp!=head);
    16a2:	80 91 ba 02 	lds	r24, 0x02BA	; 0x8002ba <head>
    16a6:	90 91 bb 02 	lds	r25, 0x02BB	; 0x8002bb <head+0x1>
    16aa:	c8 17       	cp	r28, r24
    16ac:	d9 07       	cpc	r29, r25
    16ae:	49 f7       	brne	.-46     	; 0x1682 <displayMenu+0x58>
	return head;
}
    16b0:	df 91       	pop	r29
    16b2:	cf 91       	pop	r28
    16b4:	08 95       	ret

000016b6 <displayArrow>:
Input: Nothing
Output: Nothing
*/
void displayArrow(int line,int column)
{
	oled_goto_pos(line,column);
    16b6:	0e 94 15 0d 	call	0x1a2a	; 0x1a2a <oled_goto_pos>
	data_command(0b00011000);
    16ba:	88 e1       	ldi	r24, 0x18	; 24
    16bc:	0e 94 fb 0b 	call	0x17f6	; 0x17f6 <data_command>
	data_command(0b00011000);
    16c0:	88 e1       	ldi	r24, 0x18	; 24
    16c2:	0e 94 fb 0b 	call	0x17f6	; 0x17f6 <data_command>
	data_command(0b01111110);
    16c6:	8e e7       	ldi	r24, 0x7E	; 126
    16c8:	0e 94 fb 0b 	call	0x17f6	; 0x17f6 <data_command>
	data_command(0b00111100);
    16cc:	8c e3       	ldi	r24, 0x3C	; 60
    16ce:	0e 94 fb 0b 	call	0x17f6	; 0x17f6 <data_command>
	data_command(0b00011000);
    16d2:	88 e1       	ldi	r24, 0x18	; 24
    16d4:	0e 94 fb 0b 	call	0x17f6	; 0x17f6 <data_command>
    16d8:	08 95       	ret

000016da <clearArrow>:
Input: Nothing
Output: Nothing
*/
void clearArrow(int line,int column)
{
	oled_goto_pos(line,column);
    16da:	0e 94 15 0d 	call	0x1a2a	; 0x1a2a <oled_goto_pos>
	data_command(0b00000000);
    16de:	80 e0       	ldi	r24, 0x00	; 0
    16e0:	0e 94 fb 0b 	call	0x17f6	; 0x17f6 <data_command>
	data_command(0b00000000);
    16e4:	80 e0       	ldi	r24, 0x00	; 0
    16e6:	0e 94 fb 0b 	call	0x17f6	; 0x17f6 <data_command>
	data_command(0b00000000);
    16ea:	80 e0       	ldi	r24, 0x00	; 0
    16ec:	0e 94 fb 0b 	call	0x17f6	; 0x17f6 <data_command>
	data_command(0b00000000);
    16f0:	80 e0       	ldi	r24, 0x00	; 0
    16f2:	0e 94 fb 0b 	call	0x17f6	; 0x17f6 <data_command>
	data_command(0b00000000);
    16f6:	80 e0       	ldi	r24, 0x00	; 0
    16f8:	0e 94 fb 0b 	call	0x17f6	; 0x17f6 <data_command>
    16fc:	08 95       	ret

000016fe <Sub_displayMenu>:
Description: Creating a new sub menu for only Modes to be visible and chosen from the user
Input: Nothing
Output: Returns the node structure
*/
Node* Sub_displayMenu()
{
    16fe:	cf 93       	push	r28
    1700:	df 93       	push	r29
	reset_oled();
    1702:	0e 94 3f 0c 	call	0x187e	; 0x187e <reset_oled>
	head=NULL;
    1706:	10 92 bb 02 	sts	0x02BB, r1	; 0x8002bb <head+0x1>
    170a:	10 92 ba 02 	sts	0x02BA, r1	; 0x8002ba <head>
	length=0;
    170e:	10 92 b9 02 	sts	0x02B9, r1	; 0x8002b9 <length+0x1>
    1712:	10 92 b8 02 	sts	0x02B8, r1	; 0x8002b8 <length>
	page=0;
    1716:	10 92 b7 02 	sts	0x02B7, r1	; 0x8002b7 <page+0x1>
    171a:	10 92 b6 02 	sts	0x02B6, r1	; 0x8002b6 <page>

	append_linked_list("EASY");
    171e:	82 e7       	ldi	r24, 0x72	; 114
    1720:	92 e0       	ldi	r25, 0x02	; 2
    1722:	0e 94 da 0a 	call	0x15b4	; 0x15b4 <append_linked_list>
	append_linked_list("DIFFICULT");
    1726:	87 e7       	ldi	r24, 0x77	; 119
    1728:	92 e0       	ldi	r25, 0x02	; 2
    172a:	0e 94 da 0a 	call	0x15b4	; 0x15b4 <append_linked_list>
	clearArrow(1,0);
    172e:	60 e0       	ldi	r22, 0x00	; 0
    1730:	70 e0       	ldi	r23, 0x00	; 0
    1732:	81 e0       	ldi	r24, 0x01	; 1
    1734:	90 e0       	ldi	r25, 0x00	; 0
    1736:	0e 94 6d 0b 	call	0x16da	; 0x16da <clearArrow>
	/*from front*/
	Node* temp = head;
    173a:	c0 91 ba 02 	lds	r28, 0x02BA	; 0x8002ba <head>
    173e:	d0 91 bb 02 	lds	r29, 0x02BB	; 0x8002bb <head+0x1>
	do
	{
		//arranging elements based on 2 columns
		oled_goto_line(temp->line);
    1742:	8a 81       	ldd	r24, Y+2	; 0x02
    1744:	9b 81       	ldd	r25, Y+3	; 0x03
    1746:	0e 94 01 0c 	call	0x1802	; 0x1802 <oled_goto_line>
		oled_goto_column(temp->column);
    174a:	8c 81       	ldd	r24, Y+4	; 0x04
    174c:	9d 81       	ldd	r25, Y+5	; 0x05
    174e:	0e 94 f8 0c 	call	0x19f0	; 0x19f0 <oled_goto_column>
		//writing data to the oled
		oled_print(temp->data,MEDIUM);
    1752:	61 e0       	ldi	r22, 0x01	; 1
    1754:	88 81       	ld	r24, Y
    1756:	99 81       	ldd	r25, Y+1	; 0x01
    1758:	0e 94 20 0d 	call	0x1a40	; 0x1a40 <oled_print>
		temp=temp->next;
    175c:	0e 80       	ldd	r0, Y+6	; 0x06
    175e:	df 81       	ldd	r29, Y+7	; 0x07
    1760:	c0 2d       	mov	r28, r0
	}while(temp!=head);
    1762:	80 91 ba 02 	lds	r24, 0x02BA	; 0x8002ba <head>
    1766:	90 91 bb 02 	lds	r25, 0x02BB	; 0x8002bb <head+0x1>
    176a:	c8 17       	cp	r28, r24
    176c:	d9 07       	cpc	r29, r25
    176e:	49 f7       	brne	.-46     	; 0x1742 <Sub_displayMenu+0x44>
	return head;
}
    1770:	df 91       	pop	r29
    1772:	cf 91       	pop	r28
    1774:	08 95       	ret

00001776 <Sub_displayMenu_contrast>:
Description: Creating a new sub menu for only Contrast to be visible and chosen from the user
Input: Nothing
Output: Returns the node structure
*/
Node* Sub_displayMenu_contrast()
{
    1776:	cf 93       	push	r28
    1778:	df 93       	push	r29
	reset_oled();
    177a:	0e 94 3f 0c 	call	0x187e	; 0x187e <reset_oled>
	head=NULL;
    177e:	10 92 bb 02 	sts	0x02BB, r1	; 0x8002bb <head+0x1>
    1782:	10 92 ba 02 	sts	0x02BA, r1	; 0x8002ba <head>
	length=0;
    1786:	10 92 b9 02 	sts	0x02B9, r1	; 0x8002b9 <length+0x1>
    178a:	10 92 b8 02 	sts	0x02B8, r1	; 0x8002b8 <length>
	page=0;
    178e:	10 92 b7 02 	sts	0x02B7, r1	; 0x8002b7 <page+0x1>
    1792:	10 92 b6 02 	sts	0x02B6, r1	; 0x8002b6 <page>

	append_linked_list("LOW");
    1796:	81 e8       	ldi	r24, 0x81	; 129
    1798:	92 e0       	ldi	r25, 0x02	; 2
    179a:	0e 94 da 0a 	call	0x15b4	; 0x15b4 <append_linked_list>
	append_linked_list("MEDIUM");
    179e:	85 e8       	ldi	r24, 0x85	; 133
    17a0:	92 e0       	ldi	r25, 0x02	; 2
    17a2:	0e 94 da 0a 	call	0x15b4	; 0x15b4 <append_linked_list>
	append_linked_list("BRIGHT");
    17a6:	8c e8       	ldi	r24, 0x8C	; 140
    17a8:	92 e0       	ldi	r25, 0x02	; 2
    17aa:	0e 94 da 0a 	call	0x15b4	; 0x15b4 <append_linked_list>
	clearArrow(1,0);
    17ae:	60 e0       	ldi	r22, 0x00	; 0
    17b0:	70 e0       	ldi	r23, 0x00	; 0
    17b2:	81 e0       	ldi	r24, 0x01	; 1
    17b4:	90 e0       	ldi	r25, 0x00	; 0
    17b6:	0e 94 6d 0b 	call	0x16da	; 0x16da <clearArrow>
	/*from front*/
	Node* temp = head;
    17ba:	c0 91 ba 02 	lds	r28, 0x02BA	; 0x8002ba <head>
    17be:	d0 91 bb 02 	lds	r29, 0x02BB	; 0x8002bb <head+0x1>
	do
	{
		//arranging elements based on 2 columns
		oled_goto_line(temp->line);
    17c2:	8a 81       	ldd	r24, Y+2	; 0x02
    17c4:	9b 81       	ldd	r25, Y+3	; 0x03
    17c6:	0e 94 01 0c 	call	0x1802	; 0x1802 <oled_goto_line>
		oled_goto_column(temp->column);
    17ca:	8c 81       	ldd	r24, Y+4	; 0x04
    17cc:	9d 81       	ldd	r25, Y+5	; 0x05
    17ce:	0e 94 f8 0c 	call	0x19f0	; 0x19f0 <oled_goto_column>
		//writing data to the oled
		oled_print(temp->data,MEDIUM);
    17d2:	61 e0       	ldi	r22, 0x01	; 1
    17d4:	88 81       	ld	r24, Y
    17d6:	99 81       	ldd	r25, Y+1	; 0x01
    17d8:	0e 94 20 0d 	call	0x1a40	; 0x1a40 <oled_print>
		temp=temp->next;
    17dc:	0e 80       	ldd	r0, Y+6	; 0x06
    17de:	df 81       	ldd	r29, Y+7	; 0x07
    17e0:	c0 2d       	mov	r28, r0
	}while(temp!=head);
    17e2:	80 91 ba 02 	lds	r24, 0x02BA	; 0x8002ba <head>
    17e6:	90 91 bb 02 	lds	r25, 0x02BB	; 0x8002bb <head+0x1>
    17ea:	c8 17       	cp	r28, r24
    17ec:	d9 07       	cpc	r29, r25
    17ee:	49 f7       	brne	.-46     	; 0x17c2 <Sub_displayMenu_contrast+0x4c>
	return head;
    17f0:	df 91       	pop	r29
    17f2:	cf 91       	pop	r28
    17f4:	08 95       	ret

000017f6 <data_command>:
Input: Command for the memory to be written
Output: Nothing
*/
void data_command(uint8_t command) 
{
	oled_ext_data[0]=command;
    17f6:	e0 91 08 01 	lds	r30, 0x0108	; 0x800108 <oled_ext_data>
    17fa:	f0 91 09 01 	lds	r31, 0x0109	; 0x800109 <oled_ext_data+0x1>
    17fe:	80 83       	st	Z, r24
    1800:	08 95       	ret

00001802 <oled_goto_line>:
Input:  Input of the line to be processsed
Output: Nothing
*/
void oled_goto_line(int line)
{
	current_line=line;
    1802:	80 93 bc 02 	sts	0x02BC, r24	; 0x8002bc <current_line>
    1806:	90 93 bd 02 	sts	0x02BD, r25	; 0x8002bd <current_line+0x1>
Input: Command for the memory to be written
Output: Nothing
*/
void write_command(uint8_t command) 
{	
	oled_ext_command[0]=command;
    180a:	e0 91 0a 01 	lds	r30, 0x010A	; 0x80010a <oled_ext_command>
    180e:	f0 91 0b 01 	lds	r31, 0x010B	; 0x80010b <oled_ext_command+0x1>
    1812:	90 e2       	ldi	r25, 0x20	; 32
    1814:	90 83       	st	Z, r25
    1816:	e0 91 0a 01 	lds	r30, 0x010A	; 0x80010a <oled_ext_command>
    181a:	f0 91 0b 01 	lds	r31, 0x010B	; 0x80010b <oled_ext_command+0x1>
    181e:	22 e0       	ldi	r18, 0x02	; 2
    1820:	20 83       	st	Z, r18
{
	current_line=line;
	write_command(0x20);
	write_command(0x02);
	//setting the page number
	write_command(0xB0+line); 
    1822:	80 55       	subi	r24, 0x50	; 80
Input: Command for the memory to be written
Output: Nothing
*/
void write_command(uint8_t command) 
{	
	oled_ext_command[0]=command;
    1824:	e0 91 0a 01 	lds	r30, 0x010A	; 0x80010a <oled_ext_command>
    1828:	f0 91 0b 01 	lds	r31, 0x010B	; 0x80010b <oled_ext_command+0x1>
    182c:	80 83       	st	Z, r24
    182e:	e0 91 0a 01 	lds	r30, 0x010A	; 0x80010a <oled_ext_command>
    1832:	f0 91 0b 01 	lds	r31, 0x010B	; 0x80010b <oled_ext_command+0x1>
    1836:	81 e2       	ldi	r24, 0x21	; 33
    1838:	80 83       	st	Z, r24
    183a:	e0 91 0a 01 	lds	r30, 0x010A	; 0x80010a <oled_ext_command>
    183e:	f0 91 0b 01 	lds	r31, 0x010B	; 0x80010b <oled_ext_command+0x1>
    1842:	10 82       	st	Z, r1
    1844:	e0 91 0a 01 	lds	r30, 0x010A	; 0x80010a <oled_ext_command>
    1848:	f0 91 0b 01 	lds	r31, 0x010B	; 0x80010b <oled_ext_command+0x1>
    184c:	8f e7       	ldi	r24, 0x7F	; 127
    184e:	80 83       	st	Z, r24
    1850:	e0 91 0a 01 	lds	r30, 0x010A	; 0x80010a <oled_ext_command>
    1854:	f0 91 0b 01 	lds	r31, 0x010B	; 0x80010b <oled_ext_command+0x1>
    1858:	90 83       	st	Z, r25
    185a:	e0 91 0a 01 	lds	r30, 0x010A	; 0x80010a <oled_ext_command>
    185e:	f0 91 0b 01 	lds	r31, 0x010B	; 0x80010b <oled_ext_command+0x1>
    1862:	10 82       	st	Z, r1
    1864:	08 95       	ret

00001866 <oled_clear_line>:
Input: Input of the line to be processsed
Output: Nothing
*/
void oled_clear_line(int line)
{
	oled_goto_line(line);
    1866:	0e 94 01 0c 	call	0x1802	; 0x1802 <oled_goto_line>
    186a:	80 e8       	ldi	r24, 0x80	; 128
    186c:	90 e0       	ldi	r25, 0x00	; 0
Input: Command for the memory to be written
Output: Nothing
*/
void data_command(uint8_t command) 
{
	oled_ext_data[0]=command;
    186e:	e0 91 08 01 	lds	r30, 0x0108	; 0x800108 <oled_ext_data>
    1872:	f0 91 09 01 	lds	r31, 0x0109	; 0x800109 <oled_ext_data+0x1>
    1876:	10 82       	st	Z, r1
    1878:	01 97       	sbiw	r24, 0x01	; 1
Output: Nothing
*/
void oled_clear_line(int line)
{
	oled_goto_line(line);
	for(int column=0;column<128;column++)
    187a:	c9 f7       	brne	.-14     	; 0x186e <oled_clear_line+0x8>
	{
		data_command(0);
	}
}
    187c:	08 95       	ret

0000187e <reset_oled>:
Description: Reseting the whole OLED to display blank
Input: Nothing
Output: Nothing
*/
void reset_oled()
{
    187e:	cf 93       	push	r28
    1880:	df 93       	push	r29
	for(int line=0;line<8;line++)
    1882:	c0 e0       	ldi	r28, 0x00	; 0
    1884:	d0 e0       	ldi	r29, 0x00	; 0
	{
		oled_clear_line(line);
    1886:	ce 01       	movw	r24, r28
    1888:	0e 94 33 0c 	call	0x1866	; 0x1866 <oled_clear_line>
Input: Nothing
Output: Nothing
*/
void reset_oled()
{
	for(int line=0;line<8;line++)
    188c:	21 96       	adiw	r28, 0x01	; 1
    188e:	c8 30       	cpi	r28, 0x08	; 8
    1890:	d1 05       	cpc	r29, r1
    1892:	c9 f7       	brne	.-14     	; 0x1886 <reset_oled+0x8>
	{
		oled_clear_line(line);
	}
	oled_goto_line(0);	
    1894:	80 e0       	ldi	r24, 0x00	; 0
    1896:	90 e0       	ldi	r25, 0x00	; 0
    1898:	0e 94 01 0c 	call	0x1802	; 0x1802 <oled_goto_line>
}
    189c:	df 91       	pop	r29
    189e:	cf 91       	pop	r28
    18a0:	08 95       	ret

000018a2 <init_oled>:
Input: Command for the memory to be written
Output: Nothing
*/
void write_command(uint8_t command) 
{	
	oled_ext_command[0]=command;
    18a2:	e0 91 0a 01 	lds	r30, 0x010A	; 0x80010a <oled_ext_command>
    18a6:	f0 91 0b 01 	lds	r31, 0x010B	; 0x80010b <oled_ext_command+0x1>
    18aa:	8e ea       	ldi	r24, 0xAE	; 174
    18ac:	80 83       	st	Z, r24
    18ae:	e0 91 0a 01 	lds	r30, 0x010A	; 0x80010a <oled_ext_command>
    18b2:	f0 91 0b 01 	lds	r31, 0x010B	; 0x80010b <oled_ext_command+0x1>
    18b6:	81 ea       	ldi	r24, 0xA1	; 161
    18b8:	80 83       	st	Z, r24
    18ba:	e0 91 0a 01 	lds	r30, 0x010A	; 0x80010a <oled_ext_command>
    18be:	f0 91 0b 01 	lds	r31, 0x010B	; 0x80010b <oled_ext_command+0x1>
    18c2:	8a ed       	ldi	r24, 0xDA	; 218
    18c4:	80 83       	st	Z, r24
    18c6:	e0 91 0a 01 	lds	r30, 0x010A	; 0x80010a <oled_ext_command>
    18ca:	f0 91 0b 01 	lds	r31, 0x010B	; 0x80010b <oled_ext_command+0x1>
    18ce:	82 e1       	ldi	r24, 0x12	; 18
    18d0:	80 83       	st	Z, r24
    18d2:	e0 91 0a 01 	lds	r30, 0x010A	; 0x80010a <oled_ext_command>
    18d6:	f0 91 0b 01 	lds	r31, 0x010B	; 0x80010b <oled_ext_command+0x1>
    18da:	88 ec       	ldi	r24, 0xC8	; 200
    18dc:	80 83       	st	Z, r24
    18de:	e0 91 0a 01 	lds	r30, 0x010A	; 0x80010a <oled_ext_command>
    18e2:	f0 91 0b 01 	lds	r31, 0x010B	; 0x80010b <oled_ext_command+0x1>
    18e6:	88 ea       	ldi	r24, 0xA8	; 168
    18e8:	80 83       	st	Z, r24
    18ea:	e0 91 0a 01 	lds	r30, 0x010A	; 0x80010a <oled_ext_command>
    18ee:	f0 91 0b 01 	lds	r31, 0x010B	; 0x80010b <oled_ext_command+0x1>
    18f2:	8f e3       	ldi	r24, 0x3F	; 63
    18f4:	80 83       	st	Z, r24
    18f6:	e0 91 0a 01 	lds	r30, 0x010A	; 0x80010a <oled_ext_command>
    18fa:	f0 91 0b 01 	lds	r31, 0x010B	; 0x80010b <oled_ext_command+0x1>
    18fe:	85 ed       	ldi	r24, 0xD5	; 213
    1900:	80 83       	st	Z, r24
    1902:	e0 91 0a 01 	lds	r30, 0x010A	; 0x80010a <oled_ext_command>
    1906:	f0 91 0b 01 	lds	r31, 0x010B	; 0x80010b <oled_ext_command+0x1>
    190a:	80 e8       	ldi	r24, 0x80	; 128
    190c:	80 83       	st	Z, r24
    190e:	e0 91 0a 01 	lds	r30, 0x010A	; 0x80010a <oled_ext_command>
    1912:	f0 91 0b 01 	lds	r31, 0x010B	; 0x80010b <oled_ext_command+0x1>
    1916:	81 e8       	ldi	r24, 0x81	; 129
    1918:	80 83       	st	Z, r24
    191a:	e0 91 0a 01 	lds	r30, 0x010A	; 0x80010a <oled_ext_command>
    191e:	f0 91 0b 01 	lds	r31, 0x010B	; 0x80010b <oled_ext_command+0x1>
    1922:	80 e5       	ldi	r24, 0x50	; 80
    1924:	80 83       	st	Z, r24
    1926:	e0 91 0a 01 	lds	r30, 0x010A	; 0x80010a <oled_ext_command>
    192a:	f0 91 0b 01 	lds	r31, 0x010B	; 0x80010b <oled_ext_command+0x1>
    192e:	89 ed       	ldi	r24, 0xD9	; 217
    1930:	80 83       	st	Z, r24
    1932:	e0 91 0a 01 	lds	r30, 0x010A	; 0x80010a <oled_ext_command>
    1936:	f0 91 0b 01 	lds	r31, 0x010B	; 0x80010b <oled_ext_command+0x1>
    193a:	81 e2       	ldi	r24, 0x21	; 33
    193c:	80 83       	st	Z, r24
    193e:	e0 91 0a 01 	lds	r30, 0x010A	; 0x80010a <oled_ext_command>
    1942:	f0 91 0b 01 	lds	r31, 0x010B	; 0x80010b <oled_ext_command+0x1>
    1946:	90 e2       	ldi	r25, 0x20	; 32
    1948:	90 83       	st	Z, r25
    194a:	e0 91 0a 01 	lds	r30, 0x010A	; 0x80010a <oled_ext_command>
    194e:	f0 91 0b 01 	lds	r31, 0x010B	; 0x80010b <oled_ext_command+0x1>
    1952:	10 82       	st	Z, r1
    1954:	e0 91 0a 01 	lds	r30, 0x010A	; 0x80010a <oled_ext_command>
    1958:	f0 91 0b 01 	lds	r31, 0x010B	; 0x80010b <oled_ext_command+0x1>
    195c:	80 83       	st	Z, r24
    195e:	e0 91 0a 01 	lds	r30, 0x010A	; 0x80010a <oled_ext_command>
    1962:	f0 91 0b 01 	lds	r31, 0x010B	; 0x80010b <oled_ext_command+0x1>
    1966:	10 82       	st	Z, r1
    1968:	e0 91 0a 01 	lds	r30, 0x010A	; 0x80010a <oled_ext_command>
    196c:	f0 91 0b 01 	lds	r31, 0x010B	; 0x80010b <oled_ext_command+0x1>
    1970:	8f e7       	ldi	r24, 0x7F	; 127
    1972:	80 83       	st	Z, r24
    1974:	e0 91 0a 01 	lds	r30, 0x010A	; 0x80010a <oled_ext_command>
    1978:	f0 91 0b 01 	lds	r31, 0x010B	; 0x80010b <oled_ext_command+0x1>
    197c:	82 e2       	ldi	r24, 0x22	; 34
    197e:	80 83       	st	Z, r24
    1980:	e0 91 0a 01 	lds	r30, 0x010A	; 0x80010a <oled_ext_command>
    1984:	f0 91 0b 01 	lds	r31, 0x010B	; 0x80010b <oled_ext_command+0x1>
    1988:	80 eb       	ldi	r24, 0xB0	; 176
    198a:	80 83       	st	Z, r24
    198c:	e0 91 0a 01 	lds	r30, 0x010A	; 0x80010a <oled_ext_command>
    1990:	f0 91 0b 01 	lds	r31, 0x010B	; 0x80010b <oled_ext_command+0x1>
    1994:	87 eb       	ldi	r24, 0xB7	; 183
    1996:	80 83       	st	Z, r24
    1998:	e0 91 0a 01 	lds	r30, 0x010A	; 0x80010a <oled_ext_command>
    199c:	f0 91 0b 01 	lds	r31, 0x010B	; 0x80010b <oled_ext_command+0x1>
    19a0:	8b ed       	ldi	r24, 0xDB	; 219
    19a2:	80 83       	st	Z, r24
    19a4:	e0 91 0a 01 	lds	r30, 0x010A	; 0x80010a <oled_ext_command>
    19a8:	f0 91 0b 01 	lds	r31, 0x010B	; 0x80010b <oled_ext_command+0x1>
    19ac:	80 e3       	ldi	r24, 0x30	; 48
    19ae:	80 83       	st	Z, r24
    19b0:	e0 91 0a 01 	lds	r30, 0x010A	; 0x80010a <oled_ext_command>
    19b4:	f0 91 0b 01 	lds	r31, 0x010B	; 0x80010b <oled_ext_command+0x1>
    19b8:	8d ea       	ldi	r24, 0xAD	; 173
    19ba:	80 83       	st	Z, r24
    19bc:	e0 91 0a 01 	lds	r30, 0x010A	; 0x80010a <oled_ext_command>
    19c0:	f0 91 0b 01 	lds	r31, 0x010B	; 0x80010b <oled_ext_command+0x1>
    19c4:	10 82       	st	Z, r1
    19c6:	e0 91 0a 01 	lds	r30, 0x010A	; 0x80010a <oled_ext_command>
    19ca:	f0 91 0b 01 	lds	r31, 0x010B	; 0x80010b <oled_ext_command+0x1>
    19ce:	84 ea       	ldi	r24, 0xA4	; 164
    19d0:	80 83       	st	Z, r24
    19d2:	e0 91 0a 01 	lds	r30, 0x010A	; 0x80010a <oled_ext_command>
    19d6:	f0 91 0b 01 	lds	r31, 0x010B	; 0x80010b <oled_ext_command+0x1>
    19da:	86 ea       	ldi	r24, 0xA6	; 166
    19dc:	80 83       	st	Z, r24
    19de:	e0 91 0a 01 	lds	r30, 0x010A	; 0x80010a <oled_ext_command>
    19e2:	f0 91 0b 01 	lds	r31, 0x010B	; 0x80010b <oled_ext_command+0x1>
    19e6:	8f ea       	ldi	r24, 0xAF	; 175
    19e8:	80 83       	st	Z, r24
	write_command(0x00);
	write_command(0xa4);        //out follows RAM content
	write_command(0xa6);        //set normal display
	write_command(0xaf);        // display on
	//write_command(0xa5);		//Turn on all  the pixels
	reset_oled();
    19ea:	0e 94 3f 0c 	call	0x187e	; 0x187e <reset_oled>
    19ee:	08 95       	ret

000019f0 <oled_goto_column>:
Input: Command for the memory to be written
Output: Nothing
*/
void write_command(uint8_t command) 
{	
	oled_ext_command[0]=command;
    19f0:	e0 91 0a 01 	lds	r30, 0x010A	; 0x80010a <oled_ext_command>
    19f4:	f0 91 0b 01 	lds	r31, 0x010B	; 0x80010b <oled_ext_command+0x1>
    19f8:	91 e2       	ldi	r25, 0x21	; 33
    19fa:	90 83       	st	Z, r25
    19fc:	e0 91 0a 01 	lds	r30, 0x010A	; 0x80010a <oled_ext_command>
    1a00:	f0 91 0b 01 	lds	r31, 0x010B	; 0x80010b <oled_ext_command+0x1>
    1a04:	80 83       	st	Z, r24
    1a06:	e0 91 0a 01 	lds	r30, 0x010A	; 0x80010a <oled_ext_command>
    1a0a:	f0 91 0b 01 	lds	r31, 0x010B	; 0x80010b <oled_ext_command+0x1>
    1a0e:	8f e7       	ldi	r24, 0x7F	; 127
    1a10:	80 83       	st	Z, r24
    1a12:	e0 91 0a 01 	lds	r30, 0x010A	; 0x80010a <oled_ext_command>
    1a16:	f0 91 0b 01 	lds	r31, 0x010B	; 0x80010b <oled_ext_command+0x1>
    1a1a:	80 e2       	ldi	r24, 0x20	; 32
    1a1c:	80 83       	st	Z, r24
    1a1e:	e0 91 0a 01 	lds	r30, 0x010A	; 0x80010a <oled_ext_command>
    1a22:	f0 91 0b 01 	lds	r31, 0x010B	; 0x80010b <oled_ext_command+0x1>
    1a26:	10 82       	st	Z, r1
    1a28:	08 95       	ret

00001a2a <oled_goto_pos>:
Description: Going to the specified line and Column in OLED
Input:  Input of the position to be processsed
Output: Nothing
*/
void oled_goto_pos(int line,int column)
{
    1a2a:	cf 93       	push	r28
    1a2c:	df 93       	push	r29
    1a2e:	eb 01       	movw	r28, r22
	oled_goto_line(line);
    1a30:	0e 94 01 0c 	call	0x1802	; 0x1802 <oled_goto_line>
	oled_goto_column(column);
    1a34:	ce 01       	movw	r24, r28
    1a36:	0e 94 f8 0c 	call	0x19f0	; 0x19f0 <oled_goto_column>
}
    1a3a:	df 91       	pop	r29
    1a3c:	cf 91       	pop	r28
    1a3e:	08 95       	ret

00001a40 <oled_print>:
Description: Prints the specified data on the OLED depending on the FONT type
Input:  Input of the data and FONT is received
Output: Nothing
*/
void oled_print(char* character,FONTSTYLE font)
{
    1a40:	cf 93       	push	r28
    1a42:	df 93       	push	r29
	int i=0;	
	if(font==SMALL)
    1a44:	61 11       	cpse	r22, r1
    1a46:	1f c0       	rjmp	.+62     	; 0x1a86 <oled_print+0x46>
	{
		while(character[i] != '\0')
    1a48:	dc 01       	movw	r26, r24
    1a4a:	ec 91       	ld	r30, X
    1a4c:	ee 23       	and	r30, r30
    1a4e:	09 f4       	brne	.+2      	; 0x1a52 <oled_print+0x12>
    1a50:	60 c0       	rjmp	.+192    	; 0x1b12 <oled_print+0xd2>
    1a52:	ec 01       	movw	r28, r24
    1a54:	21 96       	adiw	r28, 0x01	; 1
		{
			unsigned char* tempArray= font4[character[i]-32];
    1a56:	f0 e0       	ldi	r31, 0x00	; 0
    1a58:	ee 0f       	add	r30, r30
    1a5a:	ff 1f       	adc	r31, r31
    1a5c:	ee 0f       	add	r30, r30
    1a5e:	ff 1f       	adc	r31, r31
    1a60:	e0 51       	subi	r30, 0x10	; 16
    1a62:	f0 40       	sbci	r31, 0x00	; 0
    1a64:	9f 01       	movw	r18, r30
    1a66:	2c 5f       	subi	r18, 0xFC	; 252
    1a68:	3f 4f       	sbci	r19, 0xFF	; 255
			for (int j=0; j<4 ;j++)
			{
				data_command(pgm_read_byte(&tempArray[j]));
    1a6a:	94 91       	lpm	r25, Z
Input: Command for the memory to be written
Output: Nothing
*/
void data_command(uint8_t command) 
{
	oled_ext_data[0]=command;
    1a6c:	a0 91 08 01 	lds	r26, 0x0108	; 0x800108 <oled_ext_data>
    1a70:	b0 91 09 01 	lds	r27, 0x0109	; 0x800109 <oled_ext_data+0x1>
    1a74:	9c 93       	st	X, r25
    1a76:	31 96       	adiw	r30, 0x01	; 1
	if(font==SMALL)
	{
		while(character[i] != '\0')
		{
			unsigned char* tempArray= font4[character[i]-32];
			for (int j=0; j<4 ;j++)
    1a78:	e2 17       	cp	r30, r18
    1a7a:	f3 07       	cpc	r31, r19
    1a7c:	b1 f7       	brne	.-20     	; 0x1a6a <oled_print+0x2a>
void oled_print(char* character,FONTSTYLE font)
{
	int i=0;	
	if(font==SMALL)
	{
		while(character[i] != '\0')
    1a7e:	e9 91       	ld	r30, Y+
    1a80:	e1 11       	cpse	r30, r1
    1a82:	e9 cf       	rjmp	.-46     	; 0x1a56 <oled_print+0x16>
    1a84:	46 c0       	rjmp	.+140    	; 0x1b12 <oled_print+0xd2>
				data_command(pgm_read_byte(&tempArray[j]));
			}
			i++;
		}
	}
	else if(font==MEDIUM)
    1a86:	61 30       	cpi	r22, 0x01	; 1
    1a88:	29 f0       	breq	.+10     	; 0x1a94 <oled_print+0x54>
			}
			i++;	
		}
	}
	else {
		while(character[i] != '\0')
    1a8a:	dc 01       	movw	r26, r24
    1a8c:	ec 91       	ld	r30, X
    1a8e:	e1 11       	cpse	r30, r1
    1a90:	25 c0       	rjmp	.+74     	; 0x1adc <oled_print+0x9c>
    1a92:	3f c0       	rjmp	.+126    	; 0x1b12 <oled_print+0xd2>
			i++;
		}
	}
	else if(font==MEDIUM)
	{
		while(character[i] != '\0')
    1a94:	fc 01       	movw	r30, r24
    1a96:	20 81       	ld	r18, Z
    1a98:	22 23       	and	r18, r18
    1a9a:	09 f4       	brne	.+2      	; 0x1a9e <oled_print+0x5e>
    1a9c:	3a c0       	rjmp	.+116    	; 0x1b12 <oled_print+0xd2>
    1a9e:	ec 01       	movw	r28, r24
    1aa0:	21 96       	adiw	r28, 0x01	; 1
		{
			unsigned char* tempArray= font5[character[i]-32];
    1aa2:	30 e0       	ldi	r19, 0x00	; 0
    1aa4:	20 52       	subi	r18, 0x20	; 32
    1aa6:	31 09       	sbc	r19, r1
    1aa8:	f9 01       	movw	r30, r18
    1aaa:	ee 0f       	add	r30, r30
    1aac:	ff 1f       	adc	r31, r31
    1aae:	ee 0f       	add	r30, r30
    1ab0:	ff 1f       	adc	r31, r31
    1ab2:	e2 0f       	add	r30, r18
    1ab4:	f3 1f       	adc	r31, r19
    1ab6:	e4 51       	subi	r30, 0x14	; 20
    1ab8:	fe 4f       	sbci	r31, 0xFE	; 254
    1aba:	9f 01       	movw	r18, r30
    1abc:	2b 5f       	subi	r18, 0xFB	; 251
    1abe:	3f 4f       	sbci	r19, 0xFF	; 255
			for (int j=0; j<5 ;j++)
			{
				data_command(pgm_read_byte(&tempArray[j]));
    1ac0:	84 91       	lpm	r24, Z
Input: Command for the memory to be written
Output: Nothing
*/
void data_command(uint8_t command) 
{
	oled_ext_data[0]=command;
    1ac2:	a0 91 08 01 	lds	r26, 0x0108	; 0x800108 <oled_ext_data>
    1ac6:	b0 91 09 01 	lds	r27, 0x0109	; 0x800109 <oled_ext_data+0x1>
    1aca:	8c 93       	st	X, r24
    1acc:	31 96       	adiw	r30, 0x01	; 1
	else if(font==MEDIUM)
	{
		while(character[i] != '\0')
		{
			unsigned char* tempArray= font5[character[i]-32];
			for (int j=0; j<5 ;j++)
    1ace:	2e 17       	cp	r18, r30
    1ad0:	3f 07       	cpc	r19, r31
    1ad2:	b1 f7       	brne	.-20     	; 0x1ac0 <oled_print+0x80>
			i++;
		}
	}
	else if(font==MEDIUM)
	{
		while(character[i] != '\0')
    1ad4:	29 91       	ld	r18, Y+
    1ad6:	21 11       	cpse	r18, r1
    1ad8:	e4 cf       	rjmp	.-56     	; 0x1aa2 <oled_print+0x62>
    1ada:	1b c0       	rjmp	.+54     	; 0x1b12 <oled_print+0xd2>
    1adc:	ec 01       	movw	r28, r24
    1ade:	21 96       	adiw	r28, 0x01	; 1
		}
	}
	else {
		while(character[i] != '\0')
		{
			unsigned char* tempArray= font8[character[i]-32];
    1ae0:	f0 e0       	ldi	r31, 0x00	; 0
    1ae2:	ee 0f       	add	r30, r30
    1ae4:	ff 1f       	adc	r31, r31
    1ae6:	ee 0f       	add	r30, r30
    1ae8:	ff 1f       	adc	r31, r31
    1aea:	ee 0f       	add	r30, r30
    1aec:	ff 1f       	adc	r31, r31
    1aee:	e9 53       	subi	r30, 0x39	; 57
    1af0:	fd 4f       	sbci	r31, 0xFD	; 253
    1af2:	9f 01       	movw	r18, r30
    1af4:	28 5f       	subi	r18, 0xF8	; 248
    1af6:	3f 4f       	sbci	r19, 0xFF	; 255
			for (int j=0; j<8 ;j++)
			{
				data_command(pgm_read_byte(&tempArray[j]));
    1af8:	94 91       	lpm	r25, Z
Input: Command for the memory to be written
Output: Nothing
*/
void data_command(uint8_t command) 
{
	oled_ext_data[0]=command;
    1afa:	a0 91 08 01 	lds	r26, 0x0108	; 0x800108 <oled_ext_data>
    1afe:	b0 91 09 01 	lds	r27, 0x0109	; 0x800109 <oled_ext_data+0x1>
    1b02:	9c 93       	st	X, r25
    1b04:	31 96       	adiw	r30, 0x01	; 1
	}
	else {
		while(character[i] != '\0')
		{
			unsigned char* tempArray= font8[character[i]-32];
			for (int j=0; j<8 ;j++)
    1b06:	2e 17       	cp	r18, r30
    1b08:	3f 07       	cpc	r19, r31
    1b0a:	b1 f7       	brne	.-20     	; 0x1af8 <oled_print+0xb8>
			}
			i++;	
		}
	}
	else {
		while(character[i] != '\0')
    1b0c:	e9 91       	ld	r30, Y+
    1b0e:	e1 11       	cpse	r30, r1
    1b10:	e7 cf       	rjmp	.-50     	; 0x1ae0 <oled_print+0xa0>
				data_command(pgm_read_byte(&tempArray[j]));
			}
			i++;
		}
	}
}
    1b12:	df 91       	pop	r29
    1b14:	cf 91       	pop	r28
    1b16:	08 95       	ret

00001b18 <convertIntegerToChar>:
Description: Function used to convert the integer to character (the reference for the source code is from GeeksforGeeks) 
Input:  Input of the value
Output: returns a pointer to character after the conversion
*/
char* convertIntegerToChar(int N)
{
    1b18:	8f 92       	push	r8
    1b1a:	9f 92       	push	r9
    1b1c:	af 92       	push	r10
    1b1e:	bf 92       	push	r11
    1b20:	cf 92       	push	r12
    1b22:	df 92       	push	r13
    1b24:	ef 92       	push	r14
    1b26:	ff 92       	push	r15
    1b28:	0f 93       	push	r16
    1b2a:	1f 93       	push	r17
    1b2c:	cf 93       	push	r28
    1b2e:	df 93       	push	r29
    1b30:	cd b7       	in	r28, 0x3d	; 61
    1b32:	de b7       	in	r29, 0x3e	; 62
    1b34:	8c 01       	movw	r16, r24
	}
    // Char array truncate by null
    arr[i] = '\0';
    // Return char array
    return (char*)arr;
}
    1b36:	cd b6       	in	r12, 0x3d	; 61
    1b38:	de b6       	in	r13, 0x3e	; 62
{
    // Count digits in number N
    int m = N;
    int digit = 0;
	char* arr;
    while (m)
    1b3a:	00 97       	sbiw	r24, 0x00	; 0
    1b3c:	09 f4       	brne	.+2      	; 0x1b40 <convertIntegerToChar+0x28>
    1b3e:	47 c0       	rjmp	.+142    	; 0x1bce <convertIntegerToChar+0xb6>
    1b40:	20 e0       	ldi	r18, 0x00	; 0
    1b42:	30 e0       	ldi	r19, 0x00	; 0
	 {
        // Increment number of digits
        digit++;
        // Truncate the last digit from the number
        m /= 10;
    1b44:	ea e0       	ldi	r30, 0x0A	; 10
    1b46:	f0 e0       	ldi	r31, 0x00	; 0
    int digit = 0;
	char* arr;
    while (m)
	 {
        // Increment number of digits
        digit++;
    1b48:	2f 5f       	subi	r18, 0xFF	; 255
    1b4a:	3f 4f       	sbci	r19, 0xFF	; 255
        // Truncate the last digit from the number
        m /= 10;
    1b4c:	bf 01       	movw	r22, r30
    1b4e:	0e 94 cd 12 	call	0x259a	; 0x259a <__divmodhi4>
    1b52:	cb 01       	movw	r24, r22
{
    // Count digits in number N
    int m = N;
    int digit = 0;
	char* arr;
    while (m)
    1b54:	00 97       	sbiw	r24, 0x00	; 0
    1b56:	c1 f7       	brne	.-16     	; 0x1b48 <convertIntegerToChar+0x30>
    1b58:	21 c0       	rjmp	.+66     	; 0x1b9c <convertIntegerToChar+0x84>
    // Separating integer into digits and accommodate it to character array
    int index = 0;
    while (N)
	 {
        // Separate last digit from the number and add ASCII value of character '0' is 48
        arr1[++index] = N % 10 + '0';
    1b5a:	2f 5f       	subi	r18, 0xFF	; 255
    1b5c:	3f 4f       	sbci	r19, 0xFF	; 255
    1b5e:	c8 01       	movw	r24, r16
    1b60:	b5 01       	movw	r22, r10
    1b62:	0e 94 cd 12 	call	0x259a	; 0x259a <__divmodhi4>
    1b66:	80 5d       	subi	r24, 0xD0	; 208
    1b68:	81 93       	st	Z+, r24
        // Truncate the last digit from the number
        N /= 10;
    1b6a:	06 2f       	mov	r16, r22
    1b6c:	17 2f       	mov	r17, r23
    char arr1[digit];
    // Memory allocation of array
    arr = (char*)malloc(digit);
    // Separating integer into digits and accommodate it to character array
    int index = 0;
    while (N)
    1b6e:	01 15       	cp	r16, r1
    1b70:	11 05       	cpc	r17, r1
    1b72:	99 f7       	brne	.-26     	; 0x1b5a <convertIntegerToChar+0x42>
        arr1[++index] = N % 10 + '0';
        // Truncate the last digit from the number
        N /= 10;
    }
	int i;
	for (i = 0; i < index; i++) 
    1b74:	12 16       	cp	r1, r18
    1b76:	13 06       	cpc	r1, r19
    1b78:	74 f4       	brge	.+28     	; 0x1b96 <convertIntegerToChar+0x7e>
    1b7a:	f9 01       	movw	r30, r18
    1b7c:	31 96       	adiw	r30, 0x01	; 1
    1b7e:	ee 0d       	add	r30, r14
    1b80:	ff 1d       	adc	r31, r15
    1b82:	d4 01       	movw	r26, r8
    1b84:	8f ef       	ldi	r24, 0xFF	; 255
    1b86:	e8 1a       	sub	r14, r24
    1b88:	f8 0a       	sbc	r15, r24
	{
		arr[i] = arr1[index - i];
    1b8a:	82 91       	ld	r24, -Z
    1b8c:	8d 93       	st	X+, r24
        arr1[++index] = N % 10 + '0';
        // Truncate the last digit from the number
        N /= 10;
    }
	int i;
	for (i = 0; i < index; i++) 
    1b8e:	ee 15       	cp	r30, r14
    1b90:	ff 05       	cpc	r31, r15
    1b92:	d9 f7       	brne	.-10     	; 0x1b8a <convertIntegerToChar+0x72>
    1b94:	23 c0       	rjmp	.+70     	; 0x1bdc <convertIntegerToChar+0xc4>
    1b96:	20 e0       	ldi	r18, 0x00	; 0
    1b98:	30 e0       	ldi	r19, 0x00	; 0
    1b9a:	20 c0       	rjmp	.+64     	; 0x1bdc <convertIntegerToChar+0xc4>
        // Truncate the last digit from the number
        m /= 10;
    }
    // Declare char array for result 
    // Declare duplicate char array
    char arr1[digit];
    1b9c:	8d b7       	in	r24, 0x3d	; 61
    1b9e:	9e b7       	in	r25, 0x3e	; 62
    1ba0:	82 1b       	sub	r24, r18
    1ba2:	93 0b       	sbc	r25, r19
    1ba4:	0f b6       	in	r0, 0x3f	; 63
    1ba6:	f8 94       	cli
    1ba8:	9e bf       	out	0x3e, r25	; 62
    1baa:	0f be       	out	0x3f, r0	; 63
    1bac:	8d bf       	out	0x3d, r24	; 61
    1bae:	01 96       	adiw	r24, 0x01	; 1
    1bb0:	7c 01       	movw	r14, r24
    // Memory allocation of array
    arr = (char*)malloc(digit);
    1bb2:	c9 01       	movw	r24, r18
    1bb4:	0e 94 f5 12 	call	0x25ea	; 0x25ea <malloc>
    1bb8:	4c 01       	movw	r8, r24
    1bba:	f7 01       	movw	r30, r14
    1bbc:	31 96       	adiw	r30, 0x01	; 1
    1bbe:	20 e0       	ldi	r18, 0x00	; 0
    1bc0:	30 e0       	ldi	r19, 0x00	; 0
    // Separating integer into digits and accommodate it to character array
    int index = 0;
    while (N)
	 {
        // Separate last digit from the number and add ASCII value of character '0' is 48
        arr1[++index] = N % 10 + '0';
    1bc2:	0f 2e       	mov	r0, r31
    1bc4:	fa e0       	ldi	r31, 0x0A	; 10
    1bc6:	af 2e       	mov	r10, r31
    1bc8:	b1 2c       	mov	r11, r1
    1bca:	f0 2d       	mov	r31, r0
    1bcc:	c6 cf       	rjmp	.-116    	; 0x1b5a <convertIntegerToChar+0x42>
    }
    // Declare char array for result 
    // Declare duplicate char array
    char arr1[digit];
    // Memory allocation of array
    arr = (char*)malloc(digit);
    1bce:	80 e0       	ldi	r24, 0x00	; 0
    1bd0:	90 e0       	ldi	r25, 0x00	; 0
    1bd2:	0e 94 f5 12 	call	0x25ea	; 0x25ea <malloc>
    1bd6:	4c 01       	movw	r8, r24
    1bd8:	20 e0       	ldi	r18, 0x00	; 0
    1bda:	30 e0       	ldi	r19, 0x00	; 0
	for (i = 0; i < index; i++) 
	{
		arr[i] = arr1[index - i];
	}
    // Char array truncate by null
    arr[i] = '\0';
    1bdc:	f4 01       	movw	r30, r8
    1bde:	e2 0f       	add	r30, r18
    1be0:	f3 1f       	adc	r31, r19
    1be2:	10 82       	st	Z, r1
    // Return char array
    return (char*)arr;
}
    1be4:	c4 01       	movw	r24, r8
    1be6:	0f b6       	in	r0, 0x3f	; 63
    1be8:	f8 94       	cli
    1bea:	de be       	out	0x3e, r13	; 62
    1bec:	0f be       	out	0x3f, r0	; 63
    1bee:	cd be       	out	0x3d, r12	; 61
    1bf0:	df 91       	pop	r29
    1bf2:	cf 91       	pop	r28
    1bf4:	1f 91       	pop	r17
    1bf6:	0f 91       	pop	r16
    1bf8:	ff 90       	pop	r15
    1bfa:	ef 90       	pop	r14
    1bfc:	df 90       	pop	r13
    1bfe:	cf 90       	pop	r12
    1c00:	bf 90       	pop	r11
    1c02:	af 90       	pop	r10
    1c04:	9f 90       	pop	r9
    1c06:	8f 90       	pop	r8
    1c08:	08 95       	ret

00001c0a <print_digit>:
Description: Prints each of the digit on the OLED by converting to a character
Input:  Input of the value, line, Column to be mentioned
Output: Nothing
*/
void print_digit(int digit, int line, int column)
{
    1c0a:	ef 92       	push	r14
    1c0c:	ff 92       	push	r15
    1c0e:	0f 93       	push	r16
    1c10:	1f 93       	push	r17
    1c12:	cf 93       	push	r28
    1c14:	df 93       	push	r29
    1c16:	7b 01       	movw	r14, r22
    1c18:	8a 01       	movw	r16, r20
	char* temp=NULL;
	temp = convertIntegerToChar(digit);
    1c1a:	0e 94 8c 0d 	call	0x1b18	; 0x1b18 <convertIntegerToChar>
    1c1e:	ec 01       	movw	r28, r24
	oled_goto_line(line);
    1c20:	c7 01       	movw	r24, r14
    1c22:	0e 94 01 0c 	call	0x1802	; 0x1802 <oled_goto_line>
	oled_goto_column(column);
    1c26:	c8 01       	movw	r24, r16
    1c28:	0e 94 f8 0c 	call	0x19f0	; 0x19f0 <oled_goto_column>
	oled_print(temp,LARGE);
    1c2c:	62 e0       	ldi	r22, 0x02	; 2
    1c2e:	ce 01       	movw	r24, r28
    1c30:	0e 94 20 0d 	call	0x1a40	; 0x1a40 <oled_print>
    1c34:	2f ef       	ldi	r18, 0xFF	; 255
    1c36:	8f ef       	ldi	r24, 0xFF	; 255
    1c38:	9e e0       	ldi	r25, 0x0E	; 14
    1c3a:	21 50       	subi	r18, 0x01	; 1
    1c3c:	80 40       	sbci	r24, 0x00	; 0
    1c3e:	90 40       	sbci	r25, 0x00	; 0
    1c40:	e1 f7       	brne	.-8      	; 0x1c3a <print_digit+0x30>
    1c42:	00 c0       	rjmp	.+0      	; 0x1c44 <print_digit+0x3a>
    1c44:	00 00       	nop
	_delay_ms(1000);
	reset_oled();	
    1c46:	0e 94 3f 0c 	call	0x187e	; 0x187e <reset_oled>
}
    1c4a:	df 91       	pop	r29
    1c4c:	cf 91       	pop	r28
    1c4e:	1f 91       	pop	r17
    1c50:	0f 91       	pop	r16
    1c52:	ff 90       	pop	r15
    1c54:	ef 90       	pop	r14
    1c56:	08 95       	ret

00001c58 <OLED_timer>:
Description: Generates a timer for the value mentioned at the position on the OLED
Input:  Input of the value, line, Column to be mentioned
Output: Nothing
*/
void OLED_timer(int value, int line, int column)
{
    1c58:	ef 92       	push	r14
    1c5a:	ff 92       	push	r15
    1c5c:	0f 93       	push	r16
    1c5e:	1f 93       	push	r17
    1c60:	cf 93       	push	r28
    1c62:	df 93       	push	r29
    1c64:	ec 01       	movw	r28, r24
    1c66:	7b 01       	movw	r14, r22
    1c68:	8a 01       	movw	r16, r20
	int current_value;
	for(current_value=value; current_value>=0;current_value--)
    1c6a:	99 23       	and	r25, r25
    1c6c:	3c f0       	brlt	.+14     	; 0x1c7c <OLED_timer+0x24>
	{
		print_digit(current_value,line,column);	
    1c6e:	a8 01       	movw	r20, r16
    1c70:	b7 01       	movw	r22, r14
    1c72:	ce 01       	movw	r24, r28
    1c74:	0e 94 05 0e 	call	0x1c0a	; 0x1c0a <print_digit>
Output: Nothing
*/
void OLED_timer(int value, int line, int column)
{
	int current_value;
	for(current_value=value; current_value>=0;current_value--)
    1c78:	21 97       	sbiw	r28, 0x01	; 1
    1c7a:	c8 f7       	brcc	.-14     	; 0x1c6e <OLED_timer+0x16>
	{
		print_digit(current_value,line,column);	
	}	
}
    1c7c:	df 91       	pop	r29
    1c7e:	cf 91       	pop	r28
    1c80:	1f 91       	pop	r17
    1c82:	0f 91       	pop	r16
    1c84:	ff 90       	pop	r15
    1c86:	ef 90       	pop	r14
    1c88:	08 95       	ret

00001c8a <contrast>:
Input: Command for the memory to be written
Output: Nothing
*/
void write_command(uint8_t command) 
{	
	oled_ext_command[0]=command;
    1c8a:	e0 91 0a 01 	lds	r30, 0x010A	; 0x80010a <oled_ext_command>
    1c8e:	f0 91 0b 01 	lds	r31, 0x010B	; 0x80010b <oled_ext_command+0x1>
    1c92:	91 e8       	ldi	r25, 0x81	; 129
    1c94:	90 83       	st	Z, r25
*/
 void contrast(int value)
{
	write_command(0x81);
	value+=100;
	data_command(0x81+value);	 
    1c96:	8b 51       	subi	r24, 0x1B	; 27
Input: Command for the memory to be written
Output: Nothing
*/
void data_command(uint8_t command) 
{
	oled_ext_data[0]=command;
    1c98:	e0 91 08 01 	lds	r30, 0x0108	; 0x800108 <oled_ext_data>
    1c9c:	f0 91 09 01 	lds	r31, 0x0109	; 0x800109 <oled_ext_data+0x1>
    1ca0:	80 83       	st	Z, r24
    1ca2:	08 95       	ret

00001ca4 <replay_store>:
Description: Stores the current user game values of Joystick and Silder in SRAM
Input: The data of the CAN message to be stored
Output: Nothing
*/
void replay_store(CAN_Msg msg)
{
    1ca4:	ef 92       	push	r14
    1ca6:	ff 92       	push	r15
    1ca8:	0f 93       	push	r16
    1caa:	1f 93       	push	r17
    1cac:	cf 93       	push	r28
    1cae:	df 93       	push	r29
    1cb0:	cd b7       	in	r28, 0x3d	; 61
    1cb2:	de b7       	in	r29, 0x3e	; 62
    1cb4:	2b 97       	sbiw	r28, 0x0b	; 11
    1cb6:	0f b6       	in	r0, 0x3f	; 63
    1cb8:	f8 94       	cli
    1cba:	de bf       	out	0x3e, r29	; 62
    1cbc:	0f be       	out	0x3f, r0	; 63
    1cbe:	cd bf       	out	0x3d, r28	; 61
	//Storing each of the CAN message in one address
	ext_ram[current_ram_address] = msg.Msg_ID;
    1cc0:	e0 91 0c 01 	lds	r30, 0x010C	; 0x80010c <ext_ram>
    1cc4:	f0 91 0d 01 	lds	r31, 0x010D	; 0x80010d <ext_ram+0x1>
    1cc8:	80 91 d4 02 	lds	r24, 0x02D4	; 0x8002d4 <current_ram_address>
    1ccc:	90 91 d5 02 	lds	r25, 0x02D5	; 0x8002d5 <current_ram_address+0x1>
    1cd0:	e8 0f       	add	r30, r24
    1cd2:	f9 1f       	adc	r31, r25
    1cd4:	e0 82       	st	Z, r14
	ext_ram[current_ram_address+1] = msg.Msg_length;
    1cd6:	e0 91 d4 02 	lds	r30, 0x02D4	; 0x8002d4 <current_ram_address>
    1cda:	f0 91 d5 02 	lds	r31, 0x02D5	; 0x8002d5 <current_ram_address+0x1>
    1cde:	31 96       	adiw	r30, 0x01	; 1
    1ce0:	80 91 0c 01 	lds	r24, 0x010C	; 0x80010c <ext_ram>
    1ce4:	90 91 0d 01 	lds	r25, 0x010D	; 0x80010d <ext_ram+0x1>
    1ce8:	e8 0f       	add	r30, r24
    1cea:	f9 1f       	adc	r31, r25
    1cec:	00 83       	st	Z, r16
	ext_ram[current_ram_address+2] = msg.Data[0];
    1cee:	e0 91 d4 02 	lds	r30, 0x02D4	; 0x8002d4 <current_ram_address>
    1cf2:	f0 91 d5 02 	lds	r31, 0x02D5	; 0x8002d5 <current_ram_address+0x1>
    1cf6:	32 96       	adiw	r30, 0x02	; 2
    1cf8:	80 91 0c 01 	lds	r24, 0x010C	; 0x80010c <ext_ram>
    1cfc:	90 91 0d 01 	lds	r25, 0x010D	; 0x80010d <ext_ram+0x1>
    1d00:	e8 0f       	add	r30, r24
    1d02:	f9 1f       	adc	r31, r25
    1d04:	10 83       	st	Z, r17
	ext_ram[current_ram_address+3] = msg.Data[1];
    1d06:	e0 91 d4 02 	lds	r30, 0x02D4	; 0x8002d4 <current_ram_address>
    1d0a:	f0 91 d5 02 	lds	r31, 0x02D5	; 0x8002d5 <current_ram_address+0x1>
    1d0e:	33 96       	adiw	r30, 0x03	; 3
    1d10:	80 91 0c 01 	lds	r24, 0x010C	; 0x80010c <ext_ram>
    1d14:	90 91 0d 01 	lds	r25, 0x010D	; 0x80010d <ext_ram+0x1>
    1d18:	e8 0f       	add	r30, r24
    1d1a:	f9 1f       	adc	r31, r25
    1d1c:	20 83       	st	Z, r18
	ext_ram[current_ram_address+4] = msg.Data[2];
    1d1e:	e0 91 d4 02 	lds	r30, 0x02D4	; 0x8002d4 <current_ram_address>
    1d22:	f0 91 d5 02 	lds	r31, 0x02D5	; 0x8002d5 <current_ram_address+0x1>
    1d26:	34 96       	adiw	r30, 0x04	; 4
    1d28:	80 91 0c 01 	lds	r24, 0x010C	; 0x80010c <ext_ram>
    1d2c:	90 91 0d 01 	lds	r25, 0x010D	; 0x80010d <ext_ram+0x1>
    1d30:	e8 0f       	add	r30, r24
    1d32:	f9 1f       	adc	r31, r25
    1d34:	30 83       	st	Z, r19
	current_ram_address +=5;
    1d36:	80 91 d4 02 	lds	r24, 0x02D4	; 0x8002d4 <current_ram_address>
    1d3a:	90 91 d5 02 	lds	r25, 0x02D5	; 0x8002d5 <current_ram_address+0x1>
    1d3e:	05 96       	adiw	r24, 0x05	; 5
    1d40:	90 93 d5 02 	sts	0x02D5, r25	; 0x8002d5 <current_ram_address+0x1>
    1d44:	80 93 d4 02 	sts	0x02D4, r24	; 0x8002d4 <current_ram_address>
	total_usage +=5;
    1d48:	80 91 d6 02 	lds	r24, 0x02D6	; 0x8002d6 <total_usage>
    1d4c:	90 91 d7 02 	lds	r25, 0x02D7	; 0x8002d7 <total_usage+0x1>
    1d50:	05 96       	adiw	r24, 0x05	; 5
    1d52:	90 93 d7 02 	sts	0x02D7, r25	; 0x8002d7 <total_usage+0x1>
    1d56:	80 93 d6 02 	sts	0x02D6, r24	; 0x8002d6 <total_usage>
}
    1d5a:	2b 96       	adiw	r28, 0x0b	; 11
    1d5c:	0f b6       	in	r0, 0x3f	; 63
    1d5e:	f8 94       	cli
    1d60:	de bf       	out	0x3e, r29	; 62
    1d62:	0f be       	out	0x3f, r0	; 63
    1d64:	cd bf       	out	0x3d, r28	; 61
    1d66:	df 91       	pop	r29
    1d68:	cf 91       	pop	r28
    1d6a:	1f 91       	pop	r17
    1d6c:	0f 91       	pop	r16
    1d6e:	ff 90       	pop	r15
    1d70:	ef 90       	pop	r14
    1d72:	08 95       	ret

00001d74 <replay_retrieve>:
Description: Replays how the current user played the game, when Replay is selected from the display Menu
Input: Nothing
Output: Nothing
*/
void replay_retrieve()
{
    1d74:	ef 92       	push	r14
    1d76:	ff 92       	push	r15
    1d78:	0f 93       	push	r16
    1d7a:	1f 93       	push	r17
    1d7c:	cf 93       	push	r28
    1d7e:	df 93       	push	r29
    1d80:	cd b7       	in	r28, 0x3d	; 61
    1d82:	de b7       	in	r29, 0x3e	; 62
    1d84:	2b 97       	sbiw	r28, 0x0b	; 11
    1d86:	0f b6       	in	r0, 0x3f	; 63
    1d88:	f8 94       	cli
    1d8a:	de bf       	out	0x3e, r29	; 62
    1d8c:	0f be       	out	0x3f, r0	; 63
    1d8e:	cd bf       	out	0x3d, r28	; 61
	current_ram_address = 0;
    1d90:	10 92 d5 02 	sts	0x02D5, r1	; 0x8002d5 <current_ram_address+0x1>
    1d94:	10 92 d4 02 	sts	0x02D4, r1	; 0x8002d4 <current_ram_address>
	CAN_Msg retreived_msg;
	//Transmit the CAN message until consumed memory in SRAM and transmit the data
	while(current_ram_address < total_usage)
    1d98:	80 91 d6 02 	lds	r24, 0x02D6	; 0x8002d6 <total_usage>
    1d9c:	90 91 d7 02 	lds	r25, 0x02D7	; 0x8002d7 <total_usage+0x1>
    1da0:	89 2b       	or	r24, r25
    1da2:	09 f4       	brne	.+2      	; 0x1da6 <replay_retrieve+0x32>
    1da4:	4c c0       	rjmp	.+152    	; 0x1e3e <replay_retrieve+0xca>
    1da6:	80 e0       	ldi	r24, 0x00	; 0
    1da8:	90 e0       	ldi	r25, 0x00	; 0
	{
		retreived_msg.Msg_ID = ext_ram[current_ram_address];
    1daa:	e0 91 0c 01 	lds	r30, 0x010C	; 0x80010c <ext_ram>
    1dae:	f0 91 0d 01 	lds	r31, 0x010D	; 0x80010d <ext_ram+0x1>
    1db2:	df 01       	movw	r26, r30
    1db4:	a8 0f       	add	r26, r24
    1db6:	b9 1f       	adc	r27, r25
    1db8:	2c 91       	ld	r18, X
    1dba:	30 e0       	ldi	r19, 0x00	; 0
    1dbc:	3a 83       	std	Y+2, r19	; 0x02
    1dbe:	29 83       	std	Y+1, r18	; 0x01
		retreived_msg.Msg_length = ext_ram[current_ram_address+1];
    1dc0:	dc 01       	movw	r26, r24
    1dc2:	11 96       	adiw	r26, 0x01	; 1
    1dc4:	ae 0f       	add	r26, r30
    1dc6:	bf 1f       	adc	r27, r31
    1dc8:	2c 91       	ld	r18, X
    1dca:	2b 83       	std	Y+3, r18	; 0x03
		retreived_msg.Data[0] = ext_ram[current_ram_address+2];
    1dcc:	dc 01       	movw	r26, r24
    1dce:	12 96       	adiw	r26, 0x02	; 2
    1dd0:	ae 0f       	add	r26, r30
    1dd2:	bf 1f       	adc	r27, r31
    1dd4:	2c 91       	ld	r18, X
    1dd6:	2c 83       	std	Y+4, r18	; 0x04
		retreived_msg.Data[1] = ext_ram[current_ram_address+3];
    1dd8:	dc 01       	movw	r26, r24
    1dda:	13 96       	adiw	r26, 0x03	; 3
    1ddc:	ae 0f       	add	r26, r30
    1dde:	bf 1f       	adc	r27, r31
    1de0:	2c 91       	ld	r18, X
    1de2:	2d 83       	std	Y+5, r18	; 0x05
		retreived_msg.Data[2] = ext_ram[current_ram_address+4];
    1de4:	04 96       	adiw	r24, 0x04	; 4
    1de6:	e8 0f       	add	r30, r24
    1de8:	f9 1f       	adc	r31, r25
    1dea:	80 81       	ld	r24, Z
    1dec:	8e 83       	std	Y+6, r24	; 0x06
    1dee:	83 e2       	ldi	r24, 0x23	; 35
    1df0:	94 ef       	ldi	r25, 0xF4	; 244
    1df2:	01 97       	sbiw	r24, 0x01	; 1
    1df4:	f1 f7       	brne	.-4      	; 0x1df2 <replay_retrieve+0x7e>
    1df6:	00 c0       	rjmp	.+0      	; 0x1df8 <replay_retrieve+0x84>
    1df8:	00 00       	nop
		_delay_ms(250);
		current_ram_address+=5;
    1dfa:	80 91 d4 02 	lds	r24, 0x02D4	; 0x8002d4 <current_ram_address>
    1dfe:	90 91 d5 02 	lds	r25, 0x02D5	; 0x8002d5 <current_ram_address+0x1>
    1e02:	05 96       	adiw	r24, 0x05	; 5
    1e04:	90 93 d5 02 	sts	0x02D5, r25	; 0x8002d5 <current_ram_address+0x1>
    1e08:	80 93 d4 02 	sts	0x02D4, r24	; 0x8002d4 <current_ram_address>
		can_transmit(retreived_msg);
    1e0c:	e9 80       	ldd	r14, Y+1	; 0x01
    1e0e:	fa 80       	ldd	r15, Y+2	; 0x02
    1e10:	0b 81       	ldd	r16, Y+3	; 0x03
    1e12:	1c 81       	ldd	r17, Y+4	; 0x04
    1e14:	2d 81       	ldd	r18, Y+5	; 0x05
    1e16:	3e 81       	ldd	r19, Y+6	; 0x06
    1e18:	4f 81       	ldd	r20, Y+7	; 0x07
    1e1a:	58 85       	ldd	r21, Y+8	; 0x08
    1e1c:	69 85       	ldd	r22, Y+9	; 0x09
    1e1e:	7a 85       	ldd	r23, Y+10	; 0x0a
    1e20:	8b 85       	ldd	r24, Y+11	; 0x0b
    1e22:	0e 94 aa 03 	call	0x754	; 0x754 <can_transmit>
void replay_retrieve()
{
	current_ram_address = 0;
	CAN_Msg retreived_msg;
	//Transmit the CAN message until consumed memory in SRAM and transmit the data
	while(current_ram_address < total_usage)
    1e26:	80 91 d4 02 	lds	r24, 0x02D4	; 0x8002d4 <current_ram_address>
    1e2a:	90 91 d5 02 	lds	r25, 0x02D5	; 0x8002d5 <current_ram_address+0x1>
    1e2e:	20 91 d6 02 	lds	r18, 0x02D6	; 0x8002d6 <total_usage>
    1e32:	30 91 d7 02 	lds	r19, 0x02D7	; 0x8002d7 <total_usage+0x1>
    1e36:	82 17       	cp	r24, r18
    1e38:	93 07       	cpc	r25, r19
    1e3a:	08 f4       	brcc	.+2      	; 0x1e3e <replay_retrieve+0xca>
    1e3c:	b6 cf       	rjmp	.-148    	; 0x1daa <replay_retrieve+0x36>
		retreived_msg.Data[2] = ext_ram[current_ram_address+4];
		_delay_ms(250);
		current_ram_address+=5;
		can_transmit(retreived_msg);
	}
	printf("Replay is over");
    1e3e:	83 e9       	ldi	r24, 0x93	; 147
    1e40:	92 e0       	ldi	r25, 0x02	; 2
    1e42:	9f 93       	push	r25
    1e44:	8f 93       	push	r24
    1e46:	0e 94 6a 14 	call	0x28d4	; 0x28d4 <printf>
}
    1e4a:	0f 90       	pop	r0
    1e4c:	0f 90       	pop	r0
    1e4e:	2b 96       	adiw	r28, 0x0b	; 11
    1e50:	0f b6       	in	r0, 0x3f	; 63
    1e52:	f8 94       	cli
    1e54:	de bf       	out	0x3e, r29	; 62
    1e56:	0f be       	out	0x3f, r0	; 63
    1e58:	cd bf       	out	0x3d, r28	; 61
    1e5a:	df 91       	pop	r29
    1e5c:	cf 91       	pop	r28
    1e5e:	1f 91       	pop	r17
    1e60:	0f 91       	pop	r16
    1e62:	ff 90       	pop	r15
    1e64:	ef 90       	pop	r14
    1e66:	08 95       	ret

00001e68 <spi_init>:
Output: Nothing
*/
void spi_init()
{
	//Set MOSI, SCK, SS to the port B as input
	DDRB |= (1<<MOSI)|(1<<SCK)|(1<<SS);	
    1e68:	87 b3       	in	r24, 0x17	; 23
    1e6a:	80 6b       	ori	r24, 0xB0	; 176
    1e6c:	87 bb       	out	0x17, r24	; 23
	//Set MISO to the port B as output
	DDRB &= ~(1<<MISO);	
    1e6e:	be 98       	cbi	0x17, 6	; 23
	//Writing to the PORT B of SS
	PORTB |= (1<<SS);	
    1e70:	c4 9a       	sbi	0x18, 4	; 24
	//Setting the SPI control register by enabling the SPI and dividing the Fosc clock by 16
	SPCR = (1<<SPE)|(1<<MSTR)|(1<<SPR0);
    1e72:	81 e5       	ldi	r24, 0x51	; 81
    1e74:	8d b9       	out	0x0d, r24	; 13
    1e76:	08 95       	ret

00001e78 <spi_read>:
Input: Nothing
Output: Nothing
*/
uint8_t spi_read()
{
	SPDR = 0x00;
    1e78:	1f b8       	out	0x0f, r1	; 15
	while(!(SPSR & (1<<SPIF)));	
    1e7a:	77 9b       	sbis	0x0e, 7	; 14
    1e7c:	fe cf       	rjmp	.-4      	; 0x1e7a <spi_read+0x2>
	return SPDR;
    1e7e:	8f b1       	in	r24, 0x0f	; 15
}
    1e80:	08 95       	ret

00001e82 <spi_write>:
Input: Nothing
Output: Nothing
*/
void spi_write( int data)
{
	SPDR = data;
    1e82:	8f b9       	out	0x0f, r24	; 15
	while(!(SPSR & (1<<SPIF)));	
    1e84:	77 9b       	sbis	0x0e, 7	; 14
    1e86:	fe cf       	rjmp	.-4      	; 0x1e84 <spi_write+0x2>
}
    1e88:	08 95       	ret

00001e8a <slave_select>:
Input: Nothing
Output: Nothing
*/
void slave_select()
{
	PORTB &=~(1<<SS);
    1e8a:	c4 98       	cbi	0x18, 4	; 24
    1e8c:	08 95       	ret

00001e8e <slave_deselect>:
Input: Nothing
Output: Nothing
*/
void slave_deselect()
{
	PORTB |=(1<<SS);
    1e8e:	c4 9a       	sbi	0x18, 4	; 24
    1e90:	08 95       	ret

00001e92 <MEM_Init>:
Output: Nothing
*/
void MEM_Init()
{
	//Enabling the external memory interface
	MCUCR=(1<<SRE);
    1e92:	80 e8       	ldi	r24, 0x80	; 128
    1e94:	85 bf       	out	0x35, r24	; 53
	//PC7 - PC4 are released as normal port pins 
	SFIOR=(1<<XMM2);
    1e96:	80 e2       	ldi	r24, 0x20	; 32
    1e98:	80 bf       	out	0x30, r24	; 48
    1e9a:	08 95       	ret

00001e9c <OLED_Start>:
Input:  Nothing
Output: Nothing
*/
void OLED_Start()
{
	reset_oled();
    1e9c:	0e 94 3f 0c 	call	0x187e	; 0x187e <reset_oled>
	oled_goto_line(3);
    1ea0:	83 e0       	ldi	r24, 0x03	; 3
    1ea2:	90 e0       	ldi	r25, 0x00	; 0
    1ea4:	0e 94 01 0c 	call	0x1802	; 0x1802 <oled_goto_line>
	oled_goto_column(5);
    1ea8:	85 e0       	ldi	r24, 0x05	; 5
    1eaa:	90 e0       	ldi	r25, 0x00	; 0
    1eac:	0e 94 f8 0c 	call	0x19f0	; 0x19f0 <oled_goto_column>
	oled_print("WELCOME TO GAME",LARGE);
    1eb0:	62 e0       	ldi	r22, 0x02	; 2
    1eb2:	82 ea       	ldi	r24, 0xA2	; 162
    1eb4:	92 e0       	ldi	r25, 0x02	; 2
    1eb6:	0e 94 20 0d 	call	0x1a40	; 0x1a40 <oled_print>
    1eba:	2f e3       	ldi	r18, 0x3F	; 63
    1ebc:	82 e4       	ldi	r24, 0x42	; 66
    1ebe:	9f e0       	ldi	r25, 0x0F	; 15
    1ec0:	21 50       	subi	r18, 0x01	; 1
    1ec2:	80 40       	sbci	r24, 0x00	; 0
    1ec4:	90 40       	sbci	r25, 0x00	; 0
    1ec6:	e1 f7       	brne	.-8      	; 0x1ec0 <OLED_Start+0x24>
    1ec8:	00 c0       	rjmp	.+0      	; 0x1eca <OLED_Start+0x2e>
    1eca:	00 00       	nop
	_delay_ms(5000);
	reset_oled();
    1ecc:	0e 94 3f 0c 	call	0x187e	; 0x187e <reset_oled>
	oled_goto_line(3);
    1ed0:	83 e0       	ldi	r24, 0x03	; 3
    1ed2:	90 e0       	ldi	r25, 0x00	; 0
    1ed4:	0e 94 01 0c 	call	0x1802	; 0x1802 <oled_goto_line>
	oled_goto_column(30);	
    1ed8:	8e e1       	ldi	r24, 0x1E	; 30
    1eda:	90 e0       	ldi	r25, 0x00	; 0
    1edc:	0e 94 f8 0c 	call	0x19f0	; 0x19f0 <oled_goto_column>
	oled_print("WELCOME TO GAME",MEDIUM);
    1ee0:	61 e0       	ldi	r22, 0x01	; 1
    1ee2:	82 ea       	ldi	r24, 0xA2	; 162
    1ee4:	92 e0       	ldi	r25, 0x02	; 2
    1ee6:	0e 94 20 0d 	call	0x1a40	; 0x1a40 <oled_print>
    1eea:	2f e3       	ldi	r18, 0x3F	; 63
    1eec:	82 e4       	ldi	r24, 0x42	; 66
    1eee:	9f e0       	ldi	r25, 0x0F	; 15
    1ef0:	21 50       	subi	r18, 0x01	; 1
    1ef2:	80 40       	sbci	r24, 0x00	; 0
    1ef4:	90 40       	sbci	r25, 0x00	; 0
    1ef6:	e1 f7       	brne	.-8      	; 0x1ef0 <OLED_Start+0x54>
    1ef8:	00 c0       	rjmp	.+0      	; 0x1efa <OLED_Start+0x5e>
    1efa:	00 00       	nop
	_delay_ms(5000);
	reset_oled();
    1efc:	0e 94 3f 0c 	call	0x187e	; 0x187e <reset_oled>
	oled_goto_line(3);
    1f00:	83 e0       	ldi	r24, 0x03	; 3
    1f02:	90 e0       	ldi	r25, 0x00	; 0
    1f04:	0e 94 01 0c 	call	0x1802	; 0x1802 <oled_goto_line>
	oled_goto_column(30);
    1f08:	8e e1       	ldi	r24, 0x1E	; 30
    1f0a:	90 e0       	ldi	r25, 0x00	; 0
    1f0c:	0e 94 f8 0c 	call	0x19f0	; 0x19f0 <oled_goto_column>
	oled_print("WELCOME TO GAME",SMALL);
    1f10:	60 e0       	ldi	r22, 0x00	; 0
    1f12:	82 ea       	ldi	r24, 0xA2	; 162
    1f14:	92 e0       	ldi	r25, 0x02	; 2
    1f16:	0e 94 20 0d 	call	0x1a40	; 0x1a40 <oled_print>
    1f1a:	2f e3       	ldi	r18, 0x3F	; 63
    1f1c:	82 e4       	ldi	r24, 0x42	; 66
    1f1e:	9f e0       	ldi	r25, 0x0F	; 15
    1f20:	21 50       	subi	r18, 0x01	; 1
    1f22:	80 40       	sbci	r24, 0x00	; 0
    1f24:	90 40       	sbci	r25, 0x00	; 0
    1f26:	e1 f7       	brne	.-8      	; 0x1f20 <OLED_Start+0x84>
    1f28:	00 c0       	rjmp	.+0      	; 0x1f2a <OLED_Start+0x8e>
    1f2a:	00 00       	nop
	_delay_ms(5000);
	reset_oled();
    1f2c:	0e 94 3f 0c 	call	0x187e	; 0x187e <reset_oled>
    1f30:	08 95       	ret

00001f32 <reset_system_node_2>:
Description: Sends a message to Node 2 for doing a soft system reset during calibration
Input:  Nothing
Output: Nothing
*/
void reset_system_node_2()
{
    1f32:	ef 92       	push	r14
    1f34:	ff 92       	push	r15
    1f36:	0f 93       	push	r16
    1f38:	1f 93       	push	r17
    1f3a:	cf 93       	push	r28
    1f3c:	df 93       	push	r29
    1f3e:	cd b7       	in	r28, 0x3d	; 61
    1f40:	de b7       	in	r29, 0x3e	; 62
    1f42:	2b 97       	sbiw	r28, 0x0b	; 11
    1f44:	0f b6       	in	r0, 0x3f	; 63
    1f46:	f8 94       	cli
    1f48:	de bf       	out	0x3e, r29	; 62
    1f4a:	0f be       	out	0x3f, r0	; 63
    1f4c:	cd bf       	out	0x3d, r28	; 61
	//Configuring a CAN message to send to node 2 for doing soft rest
	CAN_Msg msg_reset;
	msg_reset.Msg_ID = 5;
    1f4e:	85 e0       	ldi	r24, 0x05	; 5
    1f50:	e8 2e       	mov	r14, r24
	msg_reset.Msg_length = 1;
	msg_reset.Data[0]=1;
	can_transmit(msg_reset);	
    1f52:	f1 2c       	mov	r15, r1
    1f54:	01 e0       	ldi	r16, 0x01	; 1
    1f56:	11 e0       	ldi	r17, 0x01	; 1
    1f58:	2d 81       	ldd	r18, Y+5	; 0x05
    1f5a:	3e 81       	ldd	r19, Y+6	; 0x06
    1f5c:	4f 81       	ldd	r20, Y+7	; 0x07
    1f5e:	58 85       	ldd	r21, Y+8	; 0x08
    1f60:	69 85       	ldd	r22, Y+9	; 0x09
    1f62:	7a 85       	ldd	r23, Y+10	; 0x0a
    1f64:	8b 85       	ldd	r24, Y+11	; 0x0b
    1f66:	0e 94 aa 03 	call	0x754	; 0x754 <can_transmit>
    1f6a:	2b 96       	adiw	r28, 0x0b	; 11
    1f6c:	0f b6       	in	r0, 0x3f	; 63
    1f6e:	f8 94       	cli
    1f70:	de bf       	out	0x3e, r29	; 62
    1f72:	0f be       	out	0x3f, r0	; 63
    1f74:	cd bf       	out	0x3d, r28	; 61
    1f76:	df 91       	pop	r29
    1f78:	cf 91       	pop	r28
    1f7a:	1f 91       	pop	r17
    1f7c:	0f 91       	pop	r16
    1f7e:	ff 90       	pop	r15
    1f80:	ef 90       	pop	r14
    1f82:	08 95       	ret

00001f84 <main>:
#include "Replay.h"
#include "System_StartUp.h"

extern Node* head;

int main(void){
    1f84:	cf 93       	push	r28
    1f86:	df 93       	push	r29
    1f88:	cd b7       	in	r28, 0x3d	; 61
    1f8a:	de b7       	in	r29, 0x3e	; 62
    1f8c:	28 97       	sbiw	r28, 0x08	; 8
    1f8e:	0f b6       	in	r0, 0x3f	; 63
    1f90:	f8 94       	cli
    1f92:	de bf       	out	0x3e, r29	; 62
    1f94:	0f be       	out	0x3f, r0	; 63
    1f96:	cd bf       	out	0x3d, r28	; 61
	//Initialization of UART And external memory
	USART_Init(MYUBRR);
    1f98:	8f e1       	ldi	r24, 0x1F	; 31
    1f9a:	90 e0       	ldi	r25, 0x00	; 0
    1f9c:	0e 94 b0 10 	call	0x2160	; 0x2160 <USART_Init>
	MEM_Init();
    1fa0:	0e 94 49 0f 	call	0x1e92	; 0x1e92 <MEM_Init>
	
	//Testing SRAM
	//SRAM_test();
	
	//Initialization OLED
 	init_oled();
    1fa4:	0e 94 51 0c 	call	0x18a2	; 0x18a2 <init_oled>
	OLED_Start();
    1fa8:	0e 94 4e 0f 	call	0x1e9c	; 0x1e9c <OLED_Start>
 	head=displayMenu();
    1fac:	0e 94 15 0b 	call	0x162a	; 0x162a <displayMenu>
    1fb0:	90 93 bb 02 	sts	0x02BB, r25	; 0x8002bb <head+0x1>
    1fb4:	80 93 ba 02 	sts	0x02BA, r24	; 0x8002ba <head>
	displayArrow(0,0);
    1fb8:	60 e0       	ldi	r22, 0x00	; 0
    1fba:	70 e0       	ldi	r23, 0x00	; 0
    1fbc:	80 e0       	ldi	r24, 0x00	; 0
    1fbe:	90 e0       	ldi	r25, 0x00	; 0
    1fc0:	0e 94 5b 0b 	call	0x16b6	; 0x16b6 <displayArrow>

	//Initialization Joystick and CAN
	initialize_clock_adc();
    1fc4:	0e 94 7f 03 	call	0x6fe	; 0x6fe <initialize_clock_adc>
	CAN_init();
    1fc8:	0e 94 9d 03 	call	0x73a	; 0x73a <CAN_init>
	MEM_Init();
    1fcc:	0e 94 49 0f 	call	0x1e92	; 0x1e92 <MEM_Init>
	Joystick_init();
    1fd0:	0e 94 8a 06 	call	0xd14	; 0xd14 <Joystick_init>
 	Joystick current;

 	while(1)
	 {
		// Depending on where the arrow is in the OLED and button is pressed, specific sub modules will be processed
   		char* direction = Joystick_info(current);
    1fd4:	29 81       	ldd	r18, Y+1	; 0x01
    1fd6:	3a 81       	ldd	r19, Y+2	; 0x02
    1fd8:	4b 81       	ldd	r20, Y+3	; 0x03
    1fda:	5c 81       	ldd	r21, Y+4	; 0x04
    1fdc:	6d 81       	ldd	r22, Y+5	; 0x05
    1fde:	7e 81       	ldd	r23, Y+6	; 0x06
    1fe0:	8f 81       	ldd	r24, Y+7	; 0x07
    1fe2:	98 85       	ldd	r25, Y+8	; 0x08
    1fe4:	0e 94 3f 08 	call	0x107e	; 0x107e <Joystick_info>
    1fe8:	8c 01       	movw	r16, r24
	 	if (strcmp(direction,"RIGHT") == 0)
    1fea:	6d e8       	ldi	r22, 0x8D	; 141
    1fec:	72 e0       	ldi	r23, 0x02	; 2
    1fee:	0e 94 16 14 	call	0x282c	; 0x282c <strcmp>
    1ff2:	89 2b       	or	r24, r25
    1ff4:	01 f5       	brne	.+64     	; 0x2036 <main+0xb2>
	 	{
	 		clearArrow(head->line,head->column-10);
    1ff6:	e0 91 ba 02 	lds	r30, 0x02BA	; 0x8002ba <head>
    1ffa:	f0 91 bb 02 	lds	r31, 0x02BB	; 0x8002bb <head+0x1>
    1ffe:	64 81       	ldd	r22, Z+4	; 0x04
    2000:	75 81       	ldd	r23, Z+5	; 0x05
    2002:	6a 50       	subi	r22, 0x0A	; 10
    2004:	71 09       	sbc	r23, r1
    2006:	82 81       	ldd	r24, Z+2	; 0x02
    2008:	93 81       	ldd	r25, Z+3	; 0x03
    200a:	0e 94 6d 0b 	call	0x16da	; 0x16da <clearArrow>
	 		head=head->next;
    200e:	e0 91 ba 02 	lds	r30, 0x02BA	; 0x8002ba <head>
    2012:	f0 91 bb 02 	lds	r31, 0x02BB	; 0x8002bb <head+0x1>
    2016:	06 80       	ldd	r0, Z+6	; 0x06
    2018:	f7 81       	ldd	r31, Z+7	; 0x07
    201a:	e0 2d       	mov	r30, r0
    201c:	f0 93 bb 02 	sts	0x02BB, r31	; 0x8002bb <head+0x1>
    2020:	e0 93 ba 02 	sts	0x02BA, r30	; 0x8002ba <head>
	 		displayArrow(head->line,head->column-10);
    2024:	64 81       	ldd	r22, Z+4	; 0x04
    2026:	75 81       	ldd	r23, Z+5	; 0x05
    2028:	6a 50       	subi	r22, 0x0A	; 10
    202a:	71 09       	sbc	r23, r1
    202c:	82 81       	ldd	r24, Z+2	; 0x02
    202e:	93 81       	ldd	r25, Z+3	; 0x03
    2030:	0e 94 5b 0b 	call	0x16b6	; 0x16b6 <displayArrow>
    2034:	7a c0       	rjmp	.+244    	; 0x212a <main+0x1a6>
	 	}
	 	else if (strcmp(direction,"LEFT") == 0)
    2036:	64 e0       	ldi	r22, 0x04	; 4
    2038:	72 e0       	ldi	r23, 0x02	; 2
    203a:	c8 01       	movw	r24, r16
    203c:	0e 94 16 14 	call	0x282c	; 0x282c <strcmp>
    2040:	89 2b       	or	r24, r25
    2042:	01 f5       	brne	.+64     	; 0x2084 <main+0x100>
	 	{
	 		clearArrow(head->line,head->column-10);
    2044:	e0 91 ba 02 	lds	r30, 0x02BA	; 0x8002ba <head>
    2048:	f0 91 bb 02 	lds	r31, 0x02BB	; 0x8002bb <head+0x1>
    204c:	64 81       	ldd	r22, Z+4	; 0x04
    204e:	75 81       	ldd	r23, Z+5	; 0x05
    2050:	6a 50       	subi	r22, 0x0A	; 10
    2052:	71 09       	sbc	r23, r1
    2054:	82 81       	ldd	r24, Z+2	; 0x02
    2056:	93 81       	ldd	r25, Z+3	; 0x03
    2058:	0e 94 6d 0b 	call	0x16da	; 0x16da <clearArrow>
	 		head=head->prev;
    205c:	e0 91 ba 02 	lds	r30, 0x02BA	; 0x8002ba <head>
    2060:	f0 91 bb 02 	lds	r31, 0x02BB	; 0x8002bb <head+0x1>
    2064:	00 84       	ldd	r0, Z+8	; 0x08
    2066:	f1 85       	ldd	r31, Z+9	; 0x09
    2068:	e0 2d       	mov	r30, r0
    206a:	f0 93 bb 02 	sts	0x02BB, r31	; 0x8002bb <head+0x1>
    206e:	e0 93 ba 02 	sts	0x02BA, r30	; 0x8002ba <head>
	 		displayArrow(head->line,head->column-10);
    2072:	64 81       	ldd	r22, Z+4	; 0x04
    2074:	75 81       	ldd	r23, Z+5	; 0x05
    2076:	6a 50       	subi	r22, 0x0A	; 10
    2078:	71 09       	sbc	r23, r1
    207a:	82 81       	ldd	r24, Z+2	; 0x02
    207c:	93 81       	ldd	r25, Z+3	; 0x03
    207e:	0e 94 5b 0b 	call	0x16b6	; 0x16b6 <displayArrow>
    2082:	53 c0       	rjmp	.+166    	; 0x212a <main+0x1a6>
	 	}
	 	else if (strcmp(direction,"UP") == 0)
    2084:	6c ef       	ldi	r22, 0xFC	; 252
    2086:	71 e0       	ldi	r23, 0x01	; 1
    2088:	c8 01       	movw	r24, r16
    208a:	0e 94 16 14 	call	0x282c	; 0x282c <strcmp>
    208e:	89 2b       	or	r24, r25
    2090:	19 f5       	brne	.+70     	; 0x20d8 <main+0x154>
	 	{
	 		clearArrow(head->line,head->column-10);
    2092:	e0 91 ba 02 	lds	r30, 0x02BA	; 0x8002ba <head>
    2096:	f0 91 bb 02 	lds	r31, 0x02BB	; 0x8002bb <head+0x1>
    209a:	64 81       	ldd	r22, Z+4	; 0x04
    209c:	75 81       	ldd	r23, Z+5	; 0x05
    209e:	6a 50       	subi	r22, 0x0A	; 10
    20a0:	71 09       	sbc	r23, r1
    20a2:	82 81       	ldd	r24, Z+2	; 0x02
    20a4:	93 81       	ldd	r25, Z+3	; 0x03
    20a6:	0e 94 6d 0b 	call	0x16da	; 0x16da <clearArrow>
	 		head=head->prev;
    20aa:	e0 91 ba 02 	lds	r30, 0x02BA	; 0x8002ba <head>
    20ae:	f0 91 bb 02 	lds	r31, 0x02BB	; 0x8002bb <head+0x1>
	 		head=head->prev;
    20b2:	00 84       	ldd	r0, Z+8	; 0x08
    20b4:	f1 85       	ldd	r31, Z+9	; 0x09
    20b6:	e0 2d       	mov	r30, r0
    20b8:	00 84       	ldd	r0, Z+8	; 0x08
    20ba:	f1 85       	ldd	r31, Z+9	; 0x09
    20bc:	e0 2d       	mov	r30, r0
    20be:	f0 93 bb 02 	sts	0x02BB, r31	; 0x8002bb <head+0x1>
    20c2:	e0 93 ba 02 	sts	0x02BA, r30	; 0x8002ba <head>
	 		displayArrow(head->line,head->column-10);
    20c6:	64 81       	ldd	r22, Z+4	; 0x04
    20c8:	75 81       	ldd	r23, Z+5	; 0x05
    20ca:	6a 50       	subi	r22, 0x0A	; 10
    20cc:	71 09       	sbc	r23, r1
    20ce:	82 81       	ldd	r24, Z+2	; 0x02
    20d0:	93 81       	ldd	r25, Z+3	; 0x03
    20d2:	0e 94 5b 0b 	call	0x16b6	; 0x16b6 <displayArrow>
    20d6:	29 c0       	rjmp	.+82     	; 0x212a <main+0x1a6>
	 	}
	 	else if (strcmp(direction,"DOWN") == 0)
    20d8:	6f ef       	ldi	r22, 0xFF	; 255
    20da:	71 e0       	ldi	r23, 0x01	; 1
    20dc:	c8 01       	movw	r24, r16
    20de:	0e 94 16 14 	call	0x282c	; 0x282c <strcmp>
    20e2:	89 2b       	or	r24, r25
    20e4:	11 f5       	brne	.+68     	; 0x212a <main+0x1a6>
	 	{
	 		clearArrow(head->line,head->column-10);
    20e6:	e0 91 ba 02 	lds	r30, 0x02BA	; 0x8002ba <head>
    20ea:	f0 91 bb 02 	lds	r31, 0x02BB	; 0x8002bb <head+0x1>
    20ee:	64 81       	ldd	r22, Z+4	; 0x04
    20f0:	75 81       	ldd	r23, Z+5	; 0x05
    20f2:	6a 50       	subi	r22, 0x0A	; 10
    20f4:	71 09       	sbc	r23, r1
    20f6:	82 81       	ldd	r24, Z+2	; 0x02
    20f8:	93 81       	ldd	r25, Z+3	; 0x03
    20fa:	0e 94 6d 0b 	call	0x16da	; 0x16da <clearArrow>
	 		head=head->next;
    20fe:	e0 91 ba 02 	lds	r30, 0x02BA	; 0x8002ba <head>
    2102:	f0 91 bb 02 	lds	r31, 0x02BB	; 0x8002bb <head+0x1>
	 		head=head->next;
    2106:	06 80       	ldd	r0, Z+6	; 0x06
    2108:	f7 81       	ldd	r31, Z+7	; 0x07
    210a:	e0 2d       	mov	r30, r0
    210c:	06 80       	ldd	r0, Z+6	; 0x06
    210e:	f7 81       	ldd	r31, Z+7	; 0x07
    2110:	e0 2d       	mov	r30, r0
    2112:	f0 93 bb 02 	sts	0x02BB, r31	; 0x8002bb <head+0x1>
    2116:	e0 93 ba 02 	sts	0x02BA, r30	; 0x8002ba <head>
	 		displayArrow(head->line,head->column-10);
    211a:	64 81       	ldd	r22, Z+4	; 0x04
    211c:	75 81       	ldd	r23, Z+5	; 0x05
    211e:	6a 50       	subi	r22, 0x0A	; 10
    2120:	71 09       	sbc	r23, r1
    2122:	82 81       	ldd	r24, Z+2	; 0x02
    2124:	93 81       	ldd	r25, Z+3	; 0x03
    2126:	0e 94 5b 0b 	call	0x16b6	; 0x16b6 <displayArrow>
	 	}
		Button(head);		
    212a:	80 91 ba 02 	lds	r24, 0x02BA	; 0x8002ba <head>
    212e:	90 91 bb 02 	lds	r25, 0x02BB	; 0x8002bb <head+0x1>
    2132:	0e 94 5b 09 	call	0x12b6	; 0x12b6 <Button>
    2136:	2f ef       	ldi	r18, 0xFF	; 255
    2138:	8f eb       	ldi	r24, 0xBF	; 191
    213a:	93 e0       	ldi	r25, 0x03	; 3
    213c:	21 50       	subi	r18, 0x01	; 1
    213e:	80 40       	sbci	r24, 0x00	; 0
    2140:	90 40       	sbci	r25, 0x00	; 0
    2142:	e1 f7       	brne	.-8      	; 0x213c <main+0x1b8>
    2144:	00 c0       	rjmp	.+0      	; 0x2146 <main+0x1c2>
    2146:	00 00       	nop
    2148:	45 cf       	rjmp	.-374    	; 0x1fd4 <main+0x50>

0000214a <USART_Transmit>:
Output: Nothing
*/
int USART_Transmit(char data, FILE *stream)
{
	/* Wait for empty transmit buffer */
	while (!(UCSR0A & (1<<UDRE0)));
    214a:	5d 9b       	sbis	0x0b, 5	; 11
    214c:	fe cf       	rjmp	.-4      	; 0x214a <USART_Transmit>
	/* Put data into buffer, sends the data */
	UDR0 = data;
    214e:	8c b9       	out	0x0c, r24	; 12
	return 0;
}
    2150:	80 e0       	ldi	r24, 0x00	; 0
    2152:	90 e0       	ldi	r25, 0x00	; 0
    2154:	08 95       	ret

00002156 <USART_Recieve>:
Output: Returns the data received from buffer
*/
int USART_Recieve(FILE *stream)
{
	/* Wait for data to be received */
	while (!(UCSR0A & (1<<RXC0)));
    2156:	5f 9b       	sbis	0x0b, 7	; 11
    2158:	fe cf       	rjmp	.-4      	; 0x2156 <USART_Recieve>
	/* Get and return received data from buffer */
	char data = UDR0;
    215a:	8c b1       	in	r24, 0x0c	; 12
	return data;
}
    215c:	90 e0       	ldi	r25, 0x00	; 0
    215e:	08 95       	ret

00002160 <USART_Init>:
Output: Nothing
*/
void USART_Init (unsigned int ubrr)
{
	/* Set baud rate */
	UBRR0H= (ubrr>>8);
    2160:	90 bd       	out	0x20, r25	; 32
	UBRR0L=  ubrr;
    2162:	89 b9       	out	0x09, r24	; 9
	UCSR0C= (1<<URSEL0)|(1<<USBS0)|(3<<UCSZ00);
    2164:	8e e8       	ldi	r24, 0x8E	; 142
    2166:	80 bd       	out	0x20, r24	; 32
	/* Enable receiver and transmitter */
	UCSR0B= (1<<RXEN0)|(1<<TXEN0);
    2168:	88 e1       	ldi	r24, 0x18	; 24
    216a:	8a b9       	out	0x0a, r24	; 10
	fdevopen(*USART_Transmit, *USART_Recieve);
    216c:	6b ea       	ldi	r22, 0xAB	; 171
    216e:	70 e1       	ldi	r23, 0x10	; 16
    2170:	85 ea       	ldi	r24, 0xA5	; 165
    2172:	90 e1       	ldi	r25, 0x10	; 16
    2174:	0e 94 1f 14 	call	0x283e	; 0x283e <fdevopen>
    2178:	08 95       	ret

0000217a <__subsf3>:
    217a:	50 58       	subi	r21, 0x80	; 128

0000217c <__addsf3>:
    217c:	bb 27       	eor	r27, r27
    217e:	aa 27       	eor	r26, r26
    2180:	0e 94 d5 10 	call	0x21aa	; 0x21aa <__addsf3x>
    2184:	0c 94 26 12 	jmp	0x244c	; 0x244c <__fp_round>
    2188:	0e 94 18 12 	call	0x2430	; 0x2430 <__fp_pscA>
    218c:	38 f0       	brcs	.+14     	; 0x219c <__addsf3+0x20>
    218e:	0e 94 1f 12 	call	0x243e	; 0x243e <__fp_pscB>
    2192:	20 f0       	brcs	.+8      	; 0x219c <__addsf3+0x20>
    2194:	39 f4       	brne	.+14     	; 0x21a4 <__addsf3+0x28>
    2196:	9f 3f       	cpi	r25, 0xFF	; 255
    2198:	19 f4       	brne	.+6      	; 0x21a0 <__addsf3+0x24>
    219a:	26 f4       	brtc	.+8      	; 0x21a4 <__addsf3+0x28>
    219c:	0c 94 15 12 	jmp	0x242a	; 0x242a <__fp_nan>
    21a0:	0e f4       	brtc	.+2      	; 0x21a4 <__addsf3+0x28>
    21a2:	e0 95       	com	r30
    21a4:	e7 fb       	bst	r30, 7
    21a6:	0c 94 0f 12 	jmp	0x241e	; 0x241e <__fp_inf>

000021aa <__addsf3x>:
    21aa:	e9 2f       	mov	r30, r25
    21ac:	0e 94 37 12 	call	0x246e	; 0x246e <__fp_split3>
    21b0:	58 f3       	brcs	.-42     	; 0x2188 <__addsf3+0xc>
    21b2:	ba 17       	cp	r27, r26
    21b4:	62 07       	cpc	r22, r18
    21b6:	73 07       	cpc	r23, r19
    21b8:	84 07       	cpc	r24, r20
    21ba:	95 07       	cpc	r25, r21
    21bc:	20 f0       	brcs	.+8      	; 0x21c6 <__addsf3x+0x1c>
    21be:	79 f4       	brne	.+30     	; 0x21de <__addsf3x+0x34>
    21c0:	a6 f5       	brtc	.+104    	; 0x222a <__addsf3x+0x80>
    21c2:	0c 94 59 12 	jmp	0x24b2	; 0x24b2 <__fp_zero>
    21c6:	0e f4       	brtc	.+2      	; 0x21ca <__addsf3x+0x20>
    21c8:	e0 95       	com	r30
    21ca:	0b 2e       	mov	r0, r27
    21cc:	ba 2f       	mov	r27, r26
    21ce:	a0 2d       	mov	r26, r0
    21d0:	0b 01       	movw	r0, r22
    21d2:	b9 01       	movw	r22, r18
    21d4:	90 01       	movw	r18, r0
    21d6:	0c 01       	movw	r0, r24
    21d8:	ca 01       	movw	r24, r20
    21da:	a0 01       	movw	r20, r0
    21dc:	11 24       	eor	r1, r1
    21de:	ff 27       	eor	r31, r31
    21e0:	59 1b       	sub	r21, r25
    21e2:	99 f0       	breq	.+38     	; 0x220a <__addsf3x+0x60>
    21e4:	59 3f       	cpi	r21, 0xF9	; 249
    21e6:	50 f4       	brcc	.+20     	; 0x21fc <__addsf3x+0x52>
    21e8:	50 3e       	cpi	r21, 0xE0	; 224
    21ea:	68 f1       	brcs	.+90     	; 0x2246 <__addsf3x+0x9c>
    21ec:	1a 16       	cp	r1, r26
    21ee:	f0 40       	sbci	r31, 0x00	; 0
    21f0:	a2 2f       	mov	r26, r18
    21f2:	23 2f       	mov	r18, r19
    21f4:	34 2f       	mov	r19, r20
    21f6:	44 27       	eor	r20, r20
    21f8:	58 5f       	subi	r21, 0xF8	; 248
    21fa:	f3 cf       	rjmp	.-26     	; 0x21e2 <__addsf3x+0x38>
    21fc:	46 95       	lsr	r20
    21fe:	37 95       	ror	r19
    2200:	27 95       	ror	r18
    2202:	a7 95       	ror	r26
    2204:	f0 40       	sbci	r31, 0x00	; 0
    2206:	53 95       	inc	r21
    2208:	c9 f7       	brne	.-14     	; 0x21fc <__addsf3x+0x52>
    220a:	7e f4       	brtc	.+30     	; 0x222a <__addsf3x+0x80>
    220c:	1f 16       	cp	r1, r31
    220e:	ba 0b       	sbc	r27, r26
    2210:	62 0b       	sbc	r22, r18
    2212:	73 0b       	sbc	r23, r19
    2214:	84 0b       	sbc	r24, r20
    2216:	ba f0       	brmi	.+46     	; 0x2246 <__addsf3x+0x9c>
    2218:	91 50       	subi	r25, 0x01	; 1
    221a:	a1 f0       	breq	.+40     	; 0x2244 <__addsf3x+0x9a>
    221c:	ff 0f       	add	r31, r31
    221e:	bb 1f       	adc	r27, r27
    2220:	66 1f       	adc	r22, r22
    2222:	77 1f       	adc	r23, r23
    2224:	88 1f       	adc	r24, r24
    2226:	c2 f7       	brpl	.-16     	; 0x2218 <__addsf3x+0x6e>
    2228:	0e c0       	rjmp	.+28     	; 0x2246 <__addsf3x+0x9c>
    222a:	ba 0f       	add	r27, r26
    222c:	62 1f       	adc	r22, r18
    222e:	73 1f       	adc	r23, r19
    2230:	84 1f       	adc	r24, r20
    2232:	48 f4       	brcc	.+18     	; 0x2246 <__addsf3x+0x9c>
    2234:	87 95       	ror	r24
    2236:	77 95       	ror	r23
    2238:	67 95       	ror	r22
    223a:	b7 95       	ror	r27
    223c:	f7 95       	ror	r31
    223e:	9e 3f       	cpi	r25, 0xFE	; 254
    2240:	08 f0       	brcs	.+2      	; 0x2244 <__addsf3x+0x9a>
    2242:	b0 cf       	rjmp	.-160    	; 0x21a4 <__addsf3+0x28>
    2244:	93 95       	inc	r25
    2246:	88 0f       	add	r24, r24
    2248:	08 f0       	brcs	.+2      	; 0x224c <__addsf3x+0xa2>
    224a:	99 27       	eor	r25, r25
    224c:	ee 0f       	add	r30, r30
    224e:	97 95       	ror	r25
    2250:	87 95       	ror	r24
    2252:	08 95       	ret

00002254 <__divsf3>:
    2254:	0e 94 3e 11 	call	0x227c	; 0x227c <__divsf3x>
    2258:	0c 94 26 12 	jmp	0x244c	; 0x244c <__fp_round>
    225c:	0e 94 1f 12 	call	0x243e	; 0x243e <__fp_pscB>
    2260:	58 f0       	brcs	.+22     	; 0x2278 <__divsf3+0x24>
    2262:	0e 94 18 12 	call	0x2430	; 0x2430 <__fp_pscA>
    2266:	40 f0       	brcs	.+16     	; 0x2278 <__divsf3+0x24>
    2268:	29 f4       	brne	.+10     	; 0x2274 <__divsf3+0x20>
    226a:	5f 3f       	cpi	r21, 0xFF	; 255
    226c:	29 f0       	breq	.+10     	; 0x2278 <__divsf3+0x24>
    226e:	0c 94 0f 12 	jmp	0x241e	; 0x241e <__fp_inf>
    2272:	51 11       	cpse	r21, r1
    2274:	0c 94 5a 12 	jmp	0x24b4	; 0x24b4 <__fp_szero>
    2278:	0c 94 15 12 	jmp	0x242a	; 0x242a <__fp_nan>

0000227c <__divsf3x>:
    227c:	0e 94 37 12 	call	0x246e	; 0x246e <__fp_split3>
    2280:	68 f3       	brcs	.-38     	; 0x225c <__divsf3+0x8>

00002282 <__divsf3_pse>:
    2282:	99 23       	and	r25, r25
    2284:	b1 f3       	breq	.-20     	; 0x2272 <__divsf3+0x1e>
    2286:	55 23       	and	r21, r21
    2288:	91 f3       	breq	.-28     	; 0x226e <__divsf3+0x1a>
    228a:	95 1b       	sub	r25, r21
    228c:	55 0b       	sbc	r21, r21
    228e:	bb 27       	eor	r27, r27
    2290:	aa 27       	eor	r26, r26
    2292:	62 17       	cp	r22, r18
    2294:	73 07       	cpc	r23, r19
    2296:	84 07       	cpc	r24, r20
    2298:	38 f0       	brcs	.+14     	; 0x22a8 <__divsf3_pse+0x26>
    229a:	9f 5f       	subi	r25, 0xFF	; 255
    229c:	5f 4f       	sbci	r21, 0xFF	; 255
    229e:	22 0f       	add	r18, r18
    22a0:	33 1f       	adc	r19, r19
    22a2:	44 1f       	adc	r20, r20
    22a4:	aa 1f       	adc	r26, r26
    22a6:	a9 f3       	breq	.-22     	; 0x2292 <__divsf3_pse+0x10>
    22a8:	35 d0       	rcall	.+106    	; 0x2314 <__divsf3_pse+0x92>
    22aa:	0e 2e       	mov	r0, r30
    22ac:	3a f0       	brmi	.+14     	; 0x22bc <__divsf3_pse+0x3a>
    22ae:	e0 e8       	ldi	r30, 0x80	; 128
    22b0:	32 d0       	rcall	.+100    	; 0x2316 <__divsf3_pse+0x94>
    22b2:	91 50       	subi	r25, 0x01	; 1
    22b4:	50 40       	sbci	r21, 0x00	; 0
    22b6:	e6 95       	lsr	r30
    22b8:	00 1c       	adc	r0, r0
    22ba:	ca f7       	brpl	.-14     	; 0x22ae <__divsf3_pse+0x2c>
    22bc:	2b d0       	rcall	.+86     	; 0x2314 <__divsf3_pse+0x92>
    22be:	fe 2f       	mov	r31, r30
    22c0:	29 d0       	rcall	.+82     	; 0x2314 <__divsf3_pse+0x92>
    22c2:	66 0f       	add	r22, r22
    22c4:	77 1f       	adc	r23, r23
    22c6:	88 1f       	adc	r24, r24
    22c8:	bb 1f       	adc	r27, r27
    22ca:	26 17       	cp	r18, r22
    22cc:	37 07       	cpc	r19, r23
    22ce:	48 07       	cpc	r20, r24
    22d0:	ab 07       	cpc	r26, r27
    22d2:	b0 e8       	ldi	r27, 0x80	; 128
    22d4:	09 f0       	breq	.+2      	; 0x22d8 <__divsf3_pse+0x56>
    22d6:	bb 0b       	sbc	r27, r27
    22d8:	80 2d       	mov	r24, r0
    22da:	bf 01       	movw	r22, r30
    22dc:	ff 27       	eor	r31, r31
    22de:	93 58       	subi	r25, 0x83	; 131
    22e0:	5f 4f       	sbci	r21, 0xFF	; 255
    22e2:	3a f0       	brmi	.+14     	; 0x22f2 <__divsf3_pse+0x70>
    22e4:	9e 3f       	cpi	r25, 0xFE	; 254
    22e6:	51 05       	cpc	r21, r1
    22e8:	78 f0       	brcs	.+30     	; 0x2308 <__divsf3_pse+0x86>
    22ea:	0c 94 0f 12 	jmp	0x241e	; 0x241e <__fp_inf>
    22ee:	0c 94 5a 12 	jmp	0x24b4	; 0x24b4 <__fp_szero>
    22f2:	5f 3f       	cpi	r21, 0xFF	; 255
    22f4:	e4 f3       	brlt	.-8      	; 0x22ee <__divsf3_pse+0x6c>
    22f6:	98 3e       	cpi	r25, 0xE8	; 232
    22f8:	d4 f3       	brlt	.-12     	; 0x22ee <__divsf3_pse+0x6c>
    22fa:	86 95       	lsr	r24
    22fc:	77 95       	ror	r23
    22fe:	67 95       	ror	r22
    2300:	b7 95       	ror	r27
    2302:	f7 95       	ror	r31
    2304:	9f 5f       	subi	r25, 0xFF	; 255
    2306:	c9 f7       	brne	.-14     	; 0x22fa <__divsf3_pse+0x78>
    2308:	88 0f       	add	r24, r24
    230a:	91 1d       	adc	r25, r1
    230c:	96 95       	lsr	r25
    230e:	87 95       	ror	r24
    2310:	97 f9       	bld	r25, 7
    2312:	08 95       	ret
    2314:	e1 e0       	ldi	r30, 0x01	; 1
    2316:	66 0f       	add	r22, r22
    2318:	77 1f       	adc	r23, r23
    231a:	88 1f       	adc	r24, r24
    231c:	bb 1f       	adc	r27, r27
    231e:	62 17       	cp	r22, r18
    2320:	73 07       	cpc	r23, r19
    2322:	84 07       	cpc	r24, r20
    2324:	ba 07       	cpc	r27, r26
    2326:	20 f0       	brcs	.+8      	; 0x2330 <__divsf3_pse+0xae>
    2328:	62 1b       	sub	r22, r18
    232a:	73 0b       	sbc	r23, r19
    232c:	84 0b       	sbc	r24, r20
    232e:	ba 0b       	sbc	r27, r26
    2330:	ee 1f       	adc	r30, r30
    2332:	88 f7       	brcc	.-30     	; 0x2316 <__divsf3_pse+0x94>
    2334:	e0 95       	com	r30
    2336:	08 95       	ret

00002338 <__fixsfsi>:
    2338:	0e 94 a3 11 	call	0x2346	; 0x2346 <__fixunssfsi>
    233c:	68 94       	set
    233e:	b1 11       	cpse	r27, r1
    2340:	0c 94 5a 12 	jmp	0x24b4	; 0x24b4 <__fp_szero>
    2344:	08 95       	ret

00002346 <__fixunssfsi>:
    2346:	0e 94 3f 12 	call	0x247e	; 0x247e <__fp_splitA>
    234a:	88 f0       	brcs	.+34     	; 0x236e <__fixunssfsi+0x28>
    234c:	9f 57       	subi	r25, 0x7F	; 127
    234e:	98 f0       	brcs	.+38     	; 0x2376 <__fixunssfsi+0x30>
    2350:	b9 2f       	mov	r27, r25
    2352:	99 27       	eor	r25, r25
    2354:	b7 51       	subi	r27, 0x17	; 23
    2356:	b0 f0       	brcs	.+44     	; 0x2384 <__fixunssfsi+0x3e>
    2358:	e1 f0       	breq	.+56     	; 0x2392 <__fixunssfsi+0x4c>
    235a:	66 0f       	add	r22, r22
    235c:	77 1f       	adc	r23, r23
    235e:	88 1f       	adc	r24, r24
    2360:	99 1f       	adc	r25, r25
    2362:	1a f0       	brmi	.+6      	; 0x236a <__fixunssfsi+0x24>
    2364:	ba 95       	dec	r27
    2366:	c9 f7       	brne	.-14     	; 0x235a <__fixunssfsi+0x14>
    2368:	14 c0       	rjmp	.+40     	; 0x2392 <__fixunssfsi+0x4c>
    236a:	b1 30       	cpi	r27, 0x01	; 1
    236c:	91 f0       	breq	.+36     	; 0x2392 <__fixunssfsi+0x4c>
    236e:	0e 94 59 12 	call	0x24b2	; 0x24b2 <__fp_zero>
    2372:	b1 e0       	ldi	r27, 0x01	; 1
    2374:	08 95       	ret
    2376:	0c 94 59 12 	jmp	0x24b2	; 0x24b2 <__fp_zero>
    237a:	67 2f       	mov	r22, r23
    237c:	78 2f       	mov	r23, r24
    237e:	88 27       	eor	r24, r24
    2380:	b8 5f       	subi	r27, 0xF8	; 248
    2382:	39 f0       	breq	.+14     	; 0x2392 <__fixunssfsi+0x4c>
    2384:	b9 3f       	cpi	r27, 0xF9	; 249
    2386:	cc f3       	brlt	.-14     	; 0x237a <__fixunssfsi+0x34>
    2388:	86 95       	lsr	r24
    238a:	77 95       	ror	r23
    238c:	67 95       	ror	r22
    238e:	b3 95       	inc	r27
    2390:	d9 f7       	brne	.-10     	; 0x2388 <__fixunssfsi+0x42>
    2392:	3e f4       	brtc	.+14     	; 0x23a2 <__fixunssfsi+0x5c>
    2394:	90 95       	com	r25
    2396:	80 95       	com	r24
    2398:	70 95       	com	r23
    239a:	61 95       	neg	r22
    239c:	7f 4f       	sbci	r23, 0xFF	; 255
    239e:	8f 4f       	sbci	r24, 0xFF	; 255
    23a0:	9f 4f       	sbci	r25, 0xFF	; 255
    23a2:	08 95       	ret

000023a4 <__floatunsisf>:
    23a4:	e8 94       	clt
    23a6:	09 c0       	rjmp	.+18     	; 0x23ba <__floatsisf+0x12>

000023a8 <__floatsisf>:
    23a8:	97 fb       	bst	r25, 7
    23aa:	3e f4       	brtc	.+14     	; 0x23ba <__floatsisf+0x12>
    23ac:	90 95       	com	r25
    23ae:	80 95       	com	r24
    23b0:	70 95       	com	r23
    23b2:	61 95       	neg	r22
    23b4:	7f 4f       	sbci	r23, 0xFF	; 255
    23b6:	8f 4f       	sbci	r24, 0xFF	; 255
    23b8:	9f 4f       	sbci	r25, 0xFF	; 255
    23ba:	99 23       	and	r25, r25
    23bc:	a9 f0       	breq	.+42     	; 0x23e8 <__floatsisf+0x40>
    23be:	f9 2f       	mov	r31, r25
    23c0:	96 e9       	ldi	r25, 0x96	; 150
    23c2:	bb 27       	eor	r27, r27
    23c4:	93 95       	inc	r25
    23c6:	f6 95       	lsr	r31
    23c8:	87 95       	ror	r24
    23ca:	77 95       	ror	r23
    23cc:	67 95       	ror	r22
    23ce:	b7 95       	ror	r27
    23d0:	f1 11       	cpse	r31, r1
    23d2:	f8 cf       	rjmp	.-16     	; 0x23c4 <__floatsisf+0x1c>
    23d4:	fa f4       	brpl	.+62     	; 0x2414 <__floatsisf+0x6c>
    23d6:	bb 0f       	add	r27, r27
    23d8:	11 f4       	brne	.+4      	; 0x23de <__floatsisf+0x36>
    23da:	60 ff       	sbrs	r22, 0
    23dc:	1b c0       	rjmp	.+54     	; 0x2414 <__floatsisf+0x6c>
    23de:	6f 5f       	subi	r22, 0xFF	; 255
    23e0:	7f 4f       	sbci	r23, 0xFF	; 255
    23e2:	8f 4f       	sbci	r24, 0xFF	; 255
    23e4:	9f 4f       	sbci	r25, 0xFF	; 255
    23e6:	16 c0       	rjmp	.+44     	; 0x2414 <__floatsisf+0x6c>
    23e8:	88 23       	and	r24, r24
    23ea:	11 f0       	breq	.+4      	; 0x23f0 <__floatsisf+0x48>
    23ec:	96 e9       	ldi	r25, 0x96	; 150
    23ee:	11 c0       	rjmp	.+34     	; 0x2412 <__floatsisf+0x6a>
    23f0:	77 23       	and	r23, r23
    23f2:	21 f0       	breq	.+8      	; 0x23fc <__floatsisf+0x54>
    23f4:	9e e8       	ldi	r25, 0x8E	; 142
    23f6:	87 2f       	mov	r24, r23
    23f8:	76 2f       	mov	r23, r22
    23fa:	05 c0       	rjmp	.+10     	; 0x2406 <__floatsisf+0x5e>
    23fc:	66 23       	and	r22, r22
    23fe:	71 f0       	breq	.+28     	; 0x241c <__floatsisf+0x74>
    2400:	96 e8       	ldi	r25, 0x86	; 134
    2402:	86 2f       	mov	r24, r22
    2404:	70 e0       	ldi	r23, 0x00	; 0
    2406:	60 e0       	ldi	r22, 0x00	; 0
    2408:	2a f0       	brmi	.+10     	; 0x2414 <__floatsisf+0x6c>
    240a:	9a 95       	dec	r25
    240c:	66 0f       	add	r22, r22
    240e:	77 1f       	adc	r23, r23
    2410:	88 1f       	adc	r24, r24
    2412:	da f7       	brpl	.-10     	; 0x240a <__floatsisf+0x62>
    2414:	88 0f       	add	r24, r24
    2416:	96 95       	lsr	r25
    2418:	87 95       	ror	r24
    241a:	97 f9       	bld	r25, 7
    241c:	08 95       	ret

0000241e <__fp_inf>:
    241e:	97 f9       	bld	r25, 7
    2420:	9f 67       	ori	r25, 0x7F	; 127
    2422:	80 e8       	ldi	r24, 0x80	; 128
    2424:	70 e0       	ldi	r23, 0x00	; 0
    2426:	60 e0       	ldi	r22, 0x00	; 0
    2428:	08 95       	ret

0000242a <__fp_nan>:
    242a:	9f ef       	ldi	r25, 0xFF	; 255
    242c:	80 ec       	ldi	r24, 0xC0	; 192
    242e:	08 95       	ret

00002430 <__fp_pscA>:
    2430:	00 24       	eor	r0, r0
    2432:	0a 94       	dec	r0
    2434:	16 16       	cp	r1, r22
    2436:	17 06       	cpc	r1, r23
    2438:	18 06       	cpc	r1, r24
    243a:	09 06       	cpc	r0, r25
    243c:	08 95       	ret

0000243e <__fp_pscB>:
    243e:	00 24       	eor	r0, r0
    2440:	0a 94       	dec	r0
    2442:	12 16       	cp	r1, r18
    2444:	13 06       	cpc	r1, r19
    2446:	14 06       	cpc	r1, r20
    2448:	05 06       	cpc	r0, r21
    244a:	08 95       	ret

0000244c <__fp_round>:
    244c:	09 2e       	mov	r0, r25
    244e:	03 94       	inc	r0
    2450:	00 0c       	add	r0, r0
    2452:	11 f4       	brne	.+4      	; 0x2458 <__fp_round+0xc>
    2454:	88 23       	and	r24, r24
    2456:	52 f0       	brmi	.+20     	; 0x246c <__fp_round+0x20>
    2458:	bb 0f       	add	r27, r27
    245a:	40 f4       	brcc	.+16     	; 0x246c <__fp_round+0x20>
    245c:	bf 2b       	or	r27, r31
    245e:	11 f4       	brne	.+4      	; 0x2464 <__fp_round+0x18>
    2460:	60 ff       	sbrs	r22, 0
    2462:	04 c0       	rjmp	.+8      	; 0x246c <__fp_round+0x20>
    2464:	6f 5f       	subi	r22, 0xFF	; 255
    2466:	7f 4f       	sbci	r23, 0xFF	; 255
    2468:	8f 4f       	sbci	r24, 0xFF	; 255
    246a:	9f 4f       	sbci	r25, 0xFF	; 255
    246c:	08 95       	ret

0000246e <__fp_split3>:
    246e:	57 fd       	sbrc	r21, 7
    2470:	90 58       	subi	r25, 0x80	; 128
    2472:	44 0f       	add	r20, r20
    2474:	55 1f       	adc	r21, r21
    2476:	59 f0       	breq	.+22     	; 0x248e <__fp_splitA+0x10>
    2478:	5f 3f       	cpi	r21, 0xFF	; 255
    247a:	71 f0       	breq	.+28     	; 0x2498 <__fp_splitA+0x1a>
    247c:	47 95       	ror	r20

0000247e <__fp_splitA>:
    247e:	88 0f       	add	r24, r24
    2480:	97 fb       	bst	r25, 7
    2482:	99 1f       	adc	r25, r25
    2484:	61 f0       	breq	.+24     	; 0x249e <__fp_splitA+0x20>
    2486:	9f 3f       	cpi	r25, 0xFF	; 255
    2488:	79 f0       	breq	.+30     	; 0x24a8 <__fp_splitA+0x2a>
    248a:	87 95       	ror	r24
    248c:	08 95       	ret
    248e:	12 16       	cp	r1, r18
    2490:	13 06       	cpc	r1, r19
    2492:	14 06       	cpc	r1, r20
    2494:	55 1f       	adc	r21, r21
    2496:	f2 cf       	rjmp	.-28     	; 0x247c <__fp_split3+0xe>
    2498:	46 95       	lsr	r20
    249a:	f1 df       	rcall	.-30     	; 0x247e <__fp_splitA>
    249c:	08 c0       	rjmp	.+16     	; 0x24ae <__fp_splitA+0x30>
    249e:	16 16       	cp	r1, r22
    24a0:	17 06       	cpc	r1, r23
    24a2:	18 06       	cpc	r1, r24
    24a4:	99 1f       	adc	r25, r25
    24a6:	f1 cf       	rjmp	.-30     	; 0x248a <__fp_splitA+0xc>
    24a8:	86 95       	lsr	r24
    24aa:	71 05       	cpc	r23, r1
    24ac:	61 05       	cpc	r22, r1
    24ae:	08 94       	sec
    24b0:	08 95       	ret

000024b2 <__fp_zero>:
    24b2:	e8 94       	clt

000024b4 <__fp_szero>:
    24b4:	bb 27       	eor	r27, r27
    24b6:	66 27       	eor	r22, r22
    24b8:	77 27       	eor	r23, r23
    24ba:	cb 01       	movw	r24, r22
    24bc:	97 f9       	bld	r25, 7
    24be:	08 95       	ret

000024c0 <__mulsf3>:
    24c0:	0e 94 73 12 	call	0x24e6	; 0x24e6 <__mulsf3x>
    24c4:	0c 94 26 12 	jmp	0x244c	; 0x244c <__fp_round>
    24c8:	0e 94 18 12 	call	0x2430	; 0x2430 <__fp_pscA>
    24cc:	38 f0       	brcs	.+14     	; 0x24dc <__mulsf3+0x1c>
    24ce:	0e 94 1f 12 	call	0x243e	; 0x243e <__fp_pscB>
    24d2:	20 f0       	brcs	.+8      	; 0x24dc <__mulsf3+0x1c>
    24d4:	95 23       	and	r25, r21
    24d6:	11 f0       	breq	.+4      	; 0x24dc <__mulsf3+0x1c>
    24d8:	0c 94 0f 12 	jmp	0x241e	; 0x241e <__fp_inf>
    24dc:	0c 94 15 12 	jmp	0x242a	; 0x242a <__fp_nan>
    24e0:	11 24       	eor	r1, r1
    24e2:	0c 94 5a 12 	jmp	0x24b4	; 0x24b4 <__fp_szero>

000024e6 <__mulsf3x>:
    24e6:	0e 94 37 12 	call	0x246e	; 0x246e <__fp_split3>
    24ea:	70 f3       	brcs	.-36     	; 0x24c8 <__mulsf3+0x8>

000024ec <__mulsf3_pse>:
    24ec:	95 9f       	mul	r25, r21
    24ee:	c1 f3       	breq	.-16     	; 0x24e0 <__mulsf3+0x20>
    24f0:	95 0f       	add	r25, r21
    24f2:	50 e0       	ldi	r21, 0x00	; 0
    24f4:	55 1f       	adc	r21, r21
    24f6:	62 9f       	mul	r22, r18
    24f8:	f0 01       	movw	r30, r0
    24fa:	72 9f       	mul	r23, r18
    24fc:	bb 27       	eor	r27, r27
    24fe:	f0 0d       	add	r31, r0
    2500:	b1 1d       	adc	r27, r1
    2502:	63 9f       	mul	r22, r19
    2504:	aa 27       	eor	r26, r26
    2506:	f0 0d       	add	r31, r0
    2508:	b1 1d       	adc	r27, r1
    250a:	aa 1f       	adc	r26, r26
    250c:	64 9f       	mul	r22, r20
    250e:	66 27       	eor	r22, r22
    2510:	b0 0d       	add	r27, r0
    2512:	a1 1d       	adc	r26, r1
    2514:	66 1f       	adc	r22, r22
    2516:	82 9f       	mul	r24, r18
    2518:	22 27       	eor	r18, r18
    251a:	b0 0d       	add	r27, r0
    251c:	a1 1d       	adc	r26, r1
    251e:	62 1f       	adc	r22, r18
    2520:	73 9f       	mul	r23, r19
    2522:	b0 0d       	add	r27, r0
    2524:	a1 1d       	adc	r26, r1
    2526:	62 1f       	adc	r22, r18
    2528:	83 9f       	mul	r24, r19
    252a:	a0 0d       	add	r26, r0
    252c:	61 1d       	adc	r22, r1
    252e:	22 1f       	adc	r18, r18
    2530:	74 9f       	mul	r23, r20
    2532:	33 27       	eor	r19, r19
    2534:	a0 0d       	add	r26, r0
    2536:	61 1d       	adc	r22, r1
    2538:	23 1f       	adc	r18, r19
    253a:	84 9f       	mul	r24, r20
    253c:	60 0d       	add	r22, r0
    253e:	21 1d       	adc	r18, r1
    2540:	82 2f       	mov	r24, r18
    2542:	76 2f       	mov	r23, r22
    2544:	6a 2f       	mov	r22, r26
    2546:	11 24       	eor	r1, r1
    2548:	9f 57       	subi	r25, 0x7F	; 127
    254a:	50 40       	sbci	r21, 0x00	; 0
    254c:	9a f0       	brmi	.+38     	; 0x2574 <__mulsf3_pse+0x88>
    254e:	f1 f0       	breq	.+60     	; 0x258c <__mulsf3_pse+0xa0>
    2550:	88 23       	and	r24, r24
    2552:	4a f0       	brmi	.+18     	; 0x2566 <__mulsf3_pse+0x7a>
    2554:	ee 0f       	add	r30, r30
    2556:	ff 1f       	adc	r31, r31
    2558:	bb 1f       	adc	r27, r27
    255a:	66 1f       	adc	r22, r22
    255c:	77 1f       	adc	r23, r23
    255e:	88 1f       	adc	r24, r24
    2560:	91 50       	subi	r25, 0x01	; 1
    2562:	50 40       	sbci	r21, 0x00	; 0
    2564:	a9 f7       	brne	.-22     	; 0x2550 <__mulsf3_pse+0x64>
    2566:	9e 3f       	cpi	r25, 0xFE	; 254
    2568:	51 05       	cpc	r21, r1
    256a:	80 f0       	brcs	.+32     	; 0x258c <__mulsf3_pse+0xa0>
    256c:	0c 94 0f 12 	jmp	0x241e	; 0x241e <__fp_inf>
    2570:	0c 94 5a 12 	jmp	0x24b4	; 0x24b4 <__fp_szero>
    2574:	5f 3f       	cpi	r21, 0xFF	; 255
    2576:	e4 f3       	brlt	.-8      	; 0x2570 <__mulsf3_pse+0x84>
    2578:	98 3e       	cpi	r25, 0xE8	; 232
    257a:	d4 f3       	brlt	.-12     	; 0x2570 <__mulsf3_pse+0x84>
    257c:	86 95       	lsr	r24
    257e:	77 95       	ror	r23
    2580:	67 95       	ror	r22
    2582:	b7 95       	ror	r27
    2584:	f7 95       	ror	r31
    2586:	e7 95       	ror	r30
    2588:	9f 5f       	subi	r25, 0xFF	; 255
    258a:	c1 f7       	brne	.-16     	; 0x257c <__mulsf3_pse+0x90>
    258c:	fe 2b       	or	r31, r30
    258e:	88 0f       	add	r24, r24
    2590:	91 1d       	adc	r25, r1
    2592:	96 95       	lsr	r25
    2594:	87 95       	ror	r24
    2596:	97 f9       	bld	r25, 7
    2598:	08 95       	ret

0000259a <__divmodhi4>:
    259a:	97 fb       	bst	r25, 7
    259c:	07 2e       	mov	r0, r23
    259e:	16 f4       	brtc	.+4      	; 0x25a4 <__divmodhi4+0xa>
    25a0:	00 94       	com	r0
    25a2:	07 d0       	rcall	.+14     	; 0x25b2 <__divmodhi4_neg1>
    25a4:	77 fd       	sbrc	r23, 7
    25a6:	09 d0       	rcall	.+18     	; 0x25ba <__divmodhi4_neg2>
    25a8:	0e 94 e1 12 	call	0x25c2	; 0x25c2 <__udivmodhi4>
    25ac:	07 fc       	sbrc	r0, 7
    25ae:	05 d0       	rcall	.+10     	; 0x25ba <__divmodhi4_neg2>
    25b0:	3e f4       	brtc	.+14     	; 0x25c0 <__divmodhi4_exit>

000025b2 <__divmodhi4_neg1>:
    25b2:	90 95       	com	r25
    25b4:	81 95       	neg	r24
    25b6:	9f 4f       	sbci	r25, 0xFF	; 255
    25b8:	08 95       	ret

000025ba <__divmodhi4_neg2>:
    25ba:	70 95       	com	r23
    25bc:	61 95       	neg	r22
    25be:	7f 4f       	sbci	r23, 0xFF	; 255

000025c0 <__divmodhi4_exit>:
    25c0:	08 95       	ret

000025c2 <__udivmodhi4>:
    25c2:	aa 1b       	sub	r26, r26
    25c4:	bb 1b       	sub	r27, r27
    25c6:	51 e1       	ldi	r21, 0x11	; 17
    25c8:	07 c0       	rjmp	.+14     	; 0x25d8 <__udivmodhi4_ep>

000025ca <__udivmodhi4_loop>:
    25ca:	aa 1f       	adc	r26, r26
    25cc:	bb 1f       	adc	r27, r27
    25ce:	a6 17       	cp	r26, r22
    25d0:	b7 07       	cpc	r27, r23
    25d2:	10 f0       	brcs	.+4      	; 0x25d8 <__udivmodhi4_ep>
    25d4:	a6 1b       	sub	r26, r22
    25d6:	b7 0b       	sbc	r27, r23

000025d8 <__udivmodhi4_ep>:
    25d8:	88 1f       	adc	r24, r24
    25da:	99 1f       	adc	r25, r25
    25dc:	5a 95       	dec	r21
    25de:	a9 f7       	brne	.-22     	; 0x25ca <__udivmodhi4_loop>
    25e0:	80 95       	com	r24
    25e2:	90 95       	com	r25
    25e4:	bc 01       	movw	r22, r24
    25e6:	cd 01       	movw	r24, r26
    25e8:	08 95       	ret

000025ea <malloc>:
    25ea:	0f 93       	push	r16
    25ec:	1f 93       	push	r17
    25ee:	cf 93       	push	r28
    25f0:	df 93       	push	r29
    25f2:	82 30       	cpi	r24, 0x02	; 2
    25f4:	91 05       	cpc	r25, r1
    25f6:	10 f4       	brcc	.+4      	; 0x25fc <malloc+0x12>
    25f8:	82 e0       	ldi	r24, 0x02	; 2
    25fa:	90 e0       	ldi	r25, 0x00	; 0
    25fc:	e0 91 da 02 	lds	r30, 0x02DA	; 0x8002da <__flp>
    2600:	f0 91 db 02 	lds	r31, 0x02DB	; 0x8002db <__flp+0x1>
    2604:	20 e0       	ldi	r18, 0x00	; 0
    2606:	30 e0       	ldi	r19, 0x00	; 0
    2608:	a0 e0       	ldi	r26, 0x00	; 0
    260a:	b0 e0       	ldi	r27, 0x00	; 0
    260c:	30 97       	sbiw	r30, 0x00	; 0
    260e:	19 f1       	breq	.+70     	; 0x2656 <malloc+0x6c>
    2610:	40 81       	ld	r20, Z
    2612:	51 81       	ldd	r21, Z+1	; 0x01
    2614:	02 81       	ldd	r16, Z+2	; 0x02
    2616:	13 81       	ldd	r17, Z+3	; 0x03
    2618:	48 17       	cp	r20, r24
    261a:	59 07       	cpc	r21, r25
    261c:	c8 f0       	brcs	.+50     	; 0x2650 <malloc+0x66>
    261e:	84 17       	cp	r24, r20
    2620:	95 07       	cpc	r25, r21
    2622:	69 f4       	brne	.+26     	; 0x263e <malloc+0x54>
    2624:	10 97       	sbiw	r26, 0x00	; 0
    2626:	31 f0       	breq	.+12     	; 0x2634 <malloc+0x4a>
    2628:	12 96       	adiw	r26, 0x02	; 2
    262a:	0c 93       	st	X, r16
    262c:	12 97       	sbiw	r26, 0x02	; 2
    262e:	13 96       	adiw	r26, 0x03	; 3
    2630:	1c 93       	st	X, r17
    2632:	27 c0       	rjmp	.+78     	; 0x2682 <malloc+0x98>
    2634:	00 93 da 02 	sts	0x02DA, r16	; 0x8002da <__flp>
    2638:	10 93 db 02 	sts	0x02DB, r17	; 0x8002db <__flp+0x1>
    263c:	22 c0       	rjmp	.+68     	; 0x2682 <malloc+0x98>
    263e:	21 15       	cp	r18, r1
    2640:	31 05       	cpc	r19, r1
    2642:	19 f0       	breq	.+6      	; 0x264a <malloc+0x60>
    2644:	42 17       	cp	r20, r18
    2646:	53 07       	cpc	r21, r19
    2648:	18 f4       	brcc	.+6      	; 0x2650 <malloc+0x66>
    264a:	9a 01       	movw	r18, r20
    264c:	bd 01       	movw	r22, r26
    264e:	ef 01       	movw	r28, r30
    2650:	df 01       	movw	r26, r30
    2652:	f8 01       	movw	r30, r16
    2654:	db cf       	rjmp	.-74     	; 0x260c <malloc+0x22>
    2656:	21 15       	cp	r18, r1
    2658:	31 05       	cpc	r19, r1
    265a:	f9 f0       	breq	.+62     	; 0x269a <malloc+0xb0>
    265c:	28 1b       	sub	r18, r24
    265e:	39 0b       	sbc	r19, r25
    2660:	24 30       	cpi	r18, 0x04	; 4
    2662:	31 05       	cpc	r19, r1
    2664:	80 f4       	brcc	.+32     	; 0x2686 <malloc+0x9c>
    2666:	8a 81       	ldd	r24, Y+2	; 0x02
    2668:	9b 81       	ldd	r25, Y+3	; 0x03
    266a:	61 15       	cp	r22, r1
    266c:	71 05       	cpc	r23, r1
    266e:	21 f0       	breq	.+8      	; 0x2678 <malloc+0x8e>
    2670:	fb 01       	movw	r30, r22
    2672:	93 83       	std	Z+3, r25	; 0x03
    2674:	82 83       	std	Z+2, r24	; 0x02
    2676:	04 c0       	rjmp	.+8      	; 0x2680 <malloc+0x96>
    2678:	90 93 db 02 	sts	0x02DB, r25	; 0x8002db <__flp+0x1>
    267c:	80 93 da 02 	sts	0x02DA, r24	; 0x8002da <__flp>
    2680:	fe 01       	movw	r30, r28
    2682:	32 96       	adiw	r30, 0x02	; 2
    2684:	44 c0       	rjmp	.+136    	; 0x270e <malloc+0x124>
    2686:	fe 01       	movw	r30, r28
    2688:	e2 0f       	add	r30, r18
    268a:	f3 1f       	adc	r31, r19
    268c:	81 93       	st	Z+, r24
    268e:	91 93       	st	Z+, r25
    2690:	22 50       	subi	r18, 0x02	; 2
    2692:	31 09       	sbc	r19, r1
    2694:	39 83       	std	Y+1, r19	; 0x01
    2696:	28 83       	st	Y, r18
    2698:	3a c0       	rjmp	.+116    	; 0x270e <malloc+0x124>
    269a:	20 91 d8 02 	lds	r18, 0x02D8	; 0x8002d8 <__brkval>
    269e:	30 91 d9 02 	lds	r19, 0x02D9	; 0x8002d9 <__brkval+0x1>
    26a2:	23 2b       	or	r18, r19
    26a4:	41 f4       	brne	.+16     	; 0x26b6 <malloc+0xcc>
    26a6:	20 91 02 01 	lds	r18, 0x0102	; 0x800102 <__malloc_heap_start>
    26aa:	30 91 03 01 	lds	r19, 0x0103	; 0x800103 <__malloc_heap_start+0x1>
    26ae:	30 93 d9 02 	sts	0x02D9, r19	; 0x8002d9 <__brkval+0x1>
    26b2:	20 93 d8 02 	sts	0x02D8, r18	; 0x8002d8 <__brkval>
    26b6:	20 91 00 01 	lds	r18, 0x0100	; 0x800100 <__data_start>
    26ba:	30 91 01 01 	lds	r19, 0x0101	; 0x800101 <__data_start+0x1>
    26be:	21 15       	cp	r18, r1
    26c0:	31 05       	cpc	r19, r1
    26c2:	41 f4       	brne	.+16     	; 0x26d4 <malloc+0xea>
    26c4:	2d b7       	in	r18, 0x3d	; 61
    26c6:	3e b7       	in	r19, 0x3e	; 62
    26c8:	40 91 04 01 	lds	r20, 0x0104	; 0x800104 <__malloc_margin>
    26cc:	50 91 05 01 	lds	r21, 0x0105	; 0x800105 <__malloc_margin+0x1>
    26d0:	24 1b       	sub	r18, r20
    26d2:	35 0b       	sbc	r19, r21
    26d4:	e0 91 d8 02 	lds	r30, 0x02D8	; 0x8002d8 <__brkval>
    26d8:	f0 91 d9 02 	lds	r31, 0x02D9	; 0x8002d9 <__brkval+0x1>
    26dc:	e2 17       	cp	r30, r18
    26de:	f3 07       	cpc	r31, r19
    26e0:	a0 f4       	brcc	.+40     	; 0x270a <malloc+0x120>
    26e2:	2e 1b       	sub	r18, r30
    26e4:	3f 0b       	sbc	r19, r31
    26e6:	28 17       	cp	r18, r24
    26e8:	39 07       	cpc	r19, r25
    26ea:	78 f0       	brcs	.+30     	; 0x270a <malloc+0x120>
    26ec:	ac 01       	movw	r20, r24
    26ee:	4e 5f       	subi	r20, 0xFE	; 254
    26f0:	5f 4f       	sbci	r21, 0xFF	; 255
    26f2:	24 17       	cp	r18, r20
    26f4:	35 07       	cpc	r19, r21
    26f6:	48 f0       	brcs	.+18     	; 0x270a <malloc+0x120>
    26f8:	4e 0f       	add	r20, r30
    26fa:	5f 1f       	adc	r21, r31
    26fc:	50 93 d9 02 	sts	0x02D9, r21	; 0x8002d9 <__brkval+0x1>
    2700:	40 93 d8 02 	sts	0x02D8, r20	; 0x8002d8 <__brkval>
    2704:	81 93       	st	Z+, r24
    2706:	91 93       	st	Z+, r25
    2708:	02 c0       	rjmp	.+4      	; 0x270e <malloc+0x124>
    270a:	e0 e0       	ldi	r30, 0x00	; 0
    270c:	f0 e0       	ldi	r31, 0x00	; 0
    270e:	cf 01       	movw	r24, r30
    2710:	df 91       	pop	r29
    2712:	cf 91       	pop	r28
    2714:	1f 91       	pop	r17
    2716:	0f 91       	pop	r16
    2718:	08 95       	ret

0000271a <free>:
    271a:	cf 93       	push	r28
    271c:	df 93       	push	r29
    271e:	00 97       	sbiw	r24, 0x00	; 0
    2720:	09 f4       	brne	.+2      	; 0x2724 <free+0xa>
    2722:	81 c0       	rjmp	.+258    	; 0x2826 <free+0x10c>
    2724:	fc 01       	movw	r30, r24
    2726:	32 97       	sbiw	r30, 0x02	; 2
    2728:	13 82       	std	Z+3, r1	; 0x03
    272a:	12 82       	std	Z+2, r1	; 0x02
    272c:	a0 91 da 02 	lds	r26, 0x02DA	; 0x8002da <__flp>
    2730:	b0 91 db 02 	lds	r27, 0x02DB	; 0x8002db <__flp+0x1>
    2734:	10 97       	sbiw	r26, 0x00	; 0
    2736:	81 f4       	brne	.+32     	; 0x2758 <free+0x3e>
    2738:	20 81       	ld	r18, Z
    273a:	31 81       	ldd	r19, Z+1	; 0x01
    273c:	82 0f       	add	r24, r18
    273e:	93 1f       	adc	r25, r19
    2740:	20 91 d8 02 	lds	r18, 0x02D8	; 0x8002d8 <__brkval>
    2744:	30 91 d9 02 	lds	r19, 0x02D9	; 0x8002d9 <__brkval+0x1>
    2748:	28 17       	cp	r18, r24
    274a:	39 07       	cpc	r19, r25
    274c:	51 f5       	brne	.+84     	; 0x27a2 <free+0x88>
    274e:	f0 93 d9 02 	sts	0x02D9, r31	; 0x8002d9 <__brkval+0x1>
    2752:	e0 93 d8 02 	sts	0x02D8, r30	; 0x8002d8 <__brkval>
    2756:	67 c0       	rjmp	.+206    	; 0x2826 <free+0x10c>
    2758:	ed 01       	movw	r28, r26
    275a:	20 e0       	ldi	r18, 0x00	; 0
    275c:	30 e0       	ldi	r19, 0x00	; 0
    275e:	ce 17       	cp	r28, r30
    2760:	df 07       	cpc	r29, r31
    2762:	40 f4       	brcc	.+16     	; 0x2774 <free+0x5a>
    2764:	4a 81       	ldd	r20, Y+2	; 0x02
    2766:	5b 81       	ldd	r21, Y+3	; 0x03
    2768:	9e 01       	movw	r18, r28
    276a:	41 15       	cp	r20, r1
    276c:	51 05       	cpc	r21, r1
    276e:	f1 f0       	breq	.+60     	; 0x27ac <free+0x92>
    2770:	ea 01       	movw	r28, r20
    2772:	f5 cf       	rjmp	.-22     	; 0x275e <free+0x44>
    2774:	d3 83       	std	Z+3, r29	; 0x03
    2776:	c2 83       	std	Z+2, r28	; 0x02
    2778:	40 81       	ld	r20, Z
    277a:	51 81       	ldd	r21, Z+1	; 0x01
    277c:	84 0f       	add	r24, r20
    277e:	95 1f       	adc	r25, r21
    2780:	c8 17       	cp	r28, r24
    2782:	d9 07       	cpc	r29, r25
    2784:	59 f4       	brne	.+22     	; 0x279c <free+0x82>
    2786:	88 81       	ld	r24, Y
    2788:	99 81       	ldd	r25, Y+1	; 0x01
    278a:	84 0f       	add	r24, r20
    278c:	95 1f       	adc	r25, r21
    278e:	02 96       	adiw	r24, 0x02	; 2
    2790:	91 83       	std	Z+1, r25	; 0x01
    2792:	80 83       	st	Z, r24
    2794:	8a 81       	ldd	r24, Y+2	; 0x02
    2796:	9b 81       	ldd	r25, Y+3	; 0x03
    2798:	93 83       	std	Z+3, r25	; 0x03
    279a:	82 83       	std	Z+2, r24	; 0x02
    279c:	21 15       	cp	r18, r1
    279e:	31 05       	cpc	r19, r1
    27a0:	29 f4       	brne	.+10     	; 0x27ac <free+0x92>
    27a2:	f0 93 db 02 	sts	0x02DB, r31	; 0x8002db <__flp+0x1>
    27a6:	e0 93 da 02 	sts	0x02DA, r30	; 0x8002da <__flp>
    27aa:	3d c0       	rjmp	.+122    	; 0x2826 <free+0x10c>
    27ac:	e9 01       	movw	r28, r18
    27ae:	fb 83       	std	Y+3, r31	; 0x03
    27b0:	ea 83       	std	Y+2, r30	; 0x02
    27b2:	49 91       	ld	r20, Y+
    27b4:	59 91       	ld	r21, Y+
    27b6:	c4 0f       	add	r28, r20
    27b8:	d5 1f       	adc	r29, r21
    27ba:	ec 17       	cp	r30, r28
    27bc:	fd 07       	cpc	r31, r29
    27be:	61 f4       	brne	.+24     	; 0x27d8 <free+0xbe>
    27c0:	80 81       	ld	r24, Z
    27c2:	91 81       	ldd	r25, Z+1	; 0x01
    27c4:	84 0f       	add	r24, r20
    27c6:	95 1f       	adc	r25, r21
    27c8:	02 96       	adiw	r24, 0x02	; 2
    27ca:	e9 01       	movw	r28, r18
    27cc:	99 83       	std	Y+1, r25	; 0x01
    27ce:	88 83       	st	Y, r24
    27d0:	82 81       	ldd	r24, Z+2	; 0x02
    27d2:	93 81       	ldd	r25, Z+3	; 0x03
    27d4:	9b 83       	std	Y+3, r25	; 0x03
    27d6:	8a 83       	std	Y+2, r24	; 0x02
    27d8:	e0 e0       	ldi	r30, 0x00	; 0
    27da:	f0 e0       	ldi	r31, 0x00	; 0
    27dc:	12 96       	adiw	r26, 0x02	; 2
    27de:	8d 91       	ld	r24, X+
    27e0:	9c 91       	ld	r25, X
    27e2:	13 97       	sbiw	r26, 0x03	; 3
    27e4:	00 97       	sbiw	r24, 0x00	; 0
    27e6:	19 f0       	breq	.+6      	; 0x27ee <free+0xd4>
    27e8:	fd 01       	movw	r30, r26
    27ea:	dc 01       	movw	r26, r24
    27ec:	f7 cf       	rjmp	.-18     	; 0x27dc <free+0xc2>
    27ee:	8d 91       	ld	r24, X+
    27f0:	9c 91       	ld	r25, X
    27f2:	11 97       	sbiw	r26, 0x01	; 1
    27f4:	9d 01       	movw	r18, r26
    27f6:	2e 5f       	subi	r18, 0xFE	; 254
    27f8:	3f 4f       	sbci	r19, 0xFF	; 255
    27fa:	82 0f       	add	r24, r18
    27fc:	93 1f       	adc	r25, r19
    27fe:	20 91 d8 02 	lds	r18, 0x02D8	; 0x8002d8 <__brkval>
    2802:	30 91 d9 02 	lds	r19, 0x02D9	; 0x8002d9 <__brkval+0x1>
    2806:	28 17       	cp	r18, r24
    2808:	39 07       	cpc	r19, r25
    280a:	69 f4       	brne	.+26     	; 0x2826 <free+0x10c>
    280c:	30 97       	sbiw	r30, 0x00	; 0
    280e:	29 f4       	brne	.+10     	; 0x281a <free+0x100>
    2810:	10 92 db 02 	sts	0x02DB, r1	; 0x8002db <__flp+0x1>
    2814:	10 92 da 02 	sts	0x02DA, r1	; 0x8002da <__flp>
    2818:	02 c0       	rjmp	.+4      	; 0x281e <free+0x104>
    281a:	13 82       	std	Z+3, r1	; 0x03
    281c:	12 82       	std	Z+2, r1	; 0x02
    281e:	b0 93 d9 02 	sts	0x02D9, r27	; 0x8002d9 <__brkval+0x1>
    2822:	a0 93 d8 02 	sts	0x02D8, r26	; 0x8002d8 <__brkval>
    2826:	df 91       	pop	r29
    2828:	cf 91       	pop	r28
    282a:	08 95       	ret

0000282c <strcmp>:
    282c:	fb 01       	movw	r30, r22
    282e:	dc 01       	movw	r26, r24
    2830:	8d 91       	ld	r24, X+
    2832:	01 90       	ld	r0, Z+
    2834:	80 19       	sub	r24, r0
    2836:	01 10       	cpse	r0, r1
    2838:	d9 f3       	breq	.-10     	; 0x2830 <strcmp+0x4>
    283a:	99 0b       	sbc	r25, r25
    283c:	08 95       	ret

0000283e <fdevopen>:
    283e:	0f 93       	push	r16
    2840:	1f 93       	push	r17
    2842:	cf 93       	push	r28
    2844:	df 93       	push	r29
    2846:	00 97       	sbiw	r24, 0x00	; 0
    2848:	31 f4       	brne	.+12     	; 0x2856 <fdevopen+0x18>
    284a:	61 15       	cp	r22, r1
    284c:	71 05       	cpc	r23, r1
    284e:	19 f4       	brne	.+6      	; 0x2856 <fdevopen+0x18>
    2850:	80 e0       	ldi	r24, 0x00	; 0
    2852:	90 e0       	ldi	r25, 0x00	; 0
    2854:	3a c0       	rjmp	.+116    	; 0x28ca <fdevopen+0x8c>
    2856:	8b 01       	movw	r16, r22
    2858:	ec 01       	movw	r28, r24
    285a:	6e e0       	ldi	r22, 0x0E	; 14
    285c:	70 e0       	ldi	r23, 0x00	; 0
    285e:	81 e0       	ldi	r24, 0x01	; 1
    2860:	90 e0       	ldi	r25, 0x00	; 0
    2862:	0e 94 91 16 	call	0x2d22	; 0x2d22 <calloc>
    2866:	fc 01       	movw	r30, r24
    2868:	89 2b       	or	r24, r25
    286a:	91 f3       	breq	.-28     	; 0x2850 <fdevopen+0x12>
    286c:	80 e8       	ldi	r24, 0x80	; 128
    286e:	83 83       	std	Z+3, r24	; 0x03
    2870:	01 15       	cp	r16, r1
    2872:	11 05       	cpc	r17, r1
    2874:	71 f0       	breq	.+28     	; 0x2892 <fdevopen+0x54>
    2876:	13 87       	std	Z+11, r17	; 0x0b
    2878:	02 87       	std	Z+10, r16	; 0x0a
    287a:	81 e8       	ldi	r24, 0x81	; 129
    287c:	83 83       	std	Z+3, r24	; 0x03
    287e:	80 91 dc 02 	lds	r24, 0x02DC	; 0x8002dc <__iob>
    2882:	90 91 dd 02 	lds	r25, 0x02DD	; 0x8002dd <__iob+0x1>
    2886:	89 2b       	or	r24, r25
    2888:	21 f4       	brne	.+8      	; 0x2892 <fdevopen+0x54>
    288a:	f0 93 dd 02 	sts	0x02DD, r31	; 0x8002dd <__iob+0x1>
    288e:	e0 93 dc 02 	sts	0x02DC, r30	; 0x8002dc <__iob>
    2892:	20 97       	sbiw	r28, 0x00	; 0
    2894:	c9 f0       	breq	.+50     	; 0x28c8 <fdevopen+0x8a>
    2896:	d1 87       	std	Z+9, r29	; 0x09
    2898:	c0 87       	std	Z+8, r28	; 0x08
    289a:	83 81       	ldd	r24, Z+3	; 0x03
    289c:	82 60       	ori	r24, 0x02	; 2
    289e:	83 83       	std	Z+3, r24	; 0x03
    28a0:	80 91 de 02 	lds	r24, 0x02DE	; 0x8002de <__iob+0x2>
    28a4:	90 91 df 02 	lds	r25, 0x02DF	; 0x8002df <__iob+0x3>
    28a8:	89 2b       	or	r24, r25
    28aa:	71 f4       	brne	.+28     	; 0x28c8 <fdevopen+0x8a>
    28ac:	f0 93 df 02 	sts	0x02DF, r31	; 0x8002df <__iob+0x3>
    28b0:	e0 93 de 02 	sts	0x02DE, r30	; 0x8002de <__iob+0x2>
    28b4:	80 91 e0 02 	lds	r24, 0x02E0	; 0x8002e0 <__iob+0x4>
    28b8:	90 91 e1 02 	lds	r25, 0x02E1	; 0x8002e1 <__iob+0x5>
    28bc:	89 2b       	or	r24, r25
    28be:	21 f4       	brne	.+8      	; 0x28c8 <fdevopen+0x8a>
    28c0:	f0 93 e1 02 	sts	0x02E1, r31	; 0x8002e1 <__iob+0x5>
    28c4:	e0 93 e0 02 	sts	0x02E0, r30	; 0x8002e0 <__iob+0x4>
    28c8:	cf 01       	movw	r24, r30
    28ca:	df 91       	pop	r29
    28cc:	cf 91       	pop	r28
    28ce:	1f 91       	pop	r17
    28d0:	0f 91       	pop	r16
    28d2:	08 95       	ret

000028d4 <printf>:
    28d4:	a0 e0       	ldi	r26, 0x00	; 0
    28d6:	b0 e0       	ldi	r27, 0x00	; 0
    28d8:	e0 e7       	ldi	r30, 0x70	; 112
    28da:	f4 e1       	ldi	r31, 0x14	; 20
    28dc:	0c 94 74 17 	jmp	0x2ee8	; 0x2ee8 <__prologue_saves__+0x20>
    28e0:	ae 01       	movw	r20, r28
    28e2:	4b 5f       	subi	r20, 0xFB	; 251
    28e4:	5f 4f       	sbci	r21, 0xFF	; 255
    28e6:	fa 01       	movw	r30, r20
    28e8:	61 91       	ld	r22, Z+
    28ea:	71 91       	ld	r23, Z+
    28ec:	af 01       	movw	r20, r30
    28ee:	80 91 de 02 	lds	r24, 0x02DE	; 0x8002de <__iob+0x2>
    28f2:	90 91 df 02 	lds	r25, 0x02DF	; 0x8002df <__iob+0x3>
    28f6:	0e 94 b0 14 	call	0x2960	; 0x2960 <vfprintf>
    28fa:	e2 e0       	ldi	r30, 0x02	; 2
    28fc:	0c 94 90 17 	jmp	0x2f20	; 0x2f20 <__epilogue_restores__+0x20>

00002900 <puts>:
    2900:	0f 93       	push	r16
    2902:	1f 93       	push	r17
    2904:	cf 93       	push	r28
    2906:	df 93       	push	r29
    2908:	e0 91 de 02 	lds	r30, 0x02DE	; 0x8002de <__iob+0x2>
    290c:	f0 91 df 02 	lds	r31, 0x02DF	; 0x8002df <__iob+0x3>
    2910:	23 81       	ldd	r18, Z+3	; 0x03
    2912:	21 ff       	sbrs	r18, 1
    2914:	1b c0       	rjmp	.+54     	; 0x294c <puts+0x4c>
    2916:	8c 01       	movw	r16, r24
    2918:	d0 e0       	ldi	r29, 0x00	; 0
    291a:	c0 e0       	ldi	r28, 0x00	; 0
    291c:	f8 01       	movw	r30, r16
    291e:	81 91       	ld	r24, Z+
    2920:	8f 01       	movw	r16, r30
    2922:	60 91 de 02 	lds	r22, 0x02DE	; 0x8002de <__iob+0x2>
    2926:	70 91 df 02 	lds	r23, 0x02DF	; 0x8002df <__iob+0x3>
    292a:	db 01       	movw	r26, r22
    292c:	18 96       	adiw	r26, 0x08	; 8
    292e:	ed 91       	ld	r30, X+
    2930:	fc 91       	ld	r31, X
    2932:	19 97       	sbiw	r26, 0x09	; 9
    2934:	88 23       	and	r24, r24
    2936:	31 f0       	breq	.+12     	; 0x2944 <puts+0x44>
    2938:	09 95       	icall
    293a:	89 2b       	or	r24, r25
    293c:	79 f3       	breq	.-34     	; 0x291c <puts+0x1c>
    293e:	df ef       	ldi	r29, 0xFF	; 255
    2940:	cf ef       	ldi	r28, 0xFF	; 255
    2942:	ec cf       	rjmp	.-40     	; 0x291c <puts+0x1c>
    2944:	8a e0       	ldi	r24, 0x0A	; 10
    2946:	09 95       	icall
    2948:	89 2b       	or	r24, r25
    294a:	19 f0       	breq	.+6      	; 0x2952 <puts+0x52>
    294c:	8f ef       	ldi	r24, 0xFF	; 255
    294e:	9f ef       	ldi	r25, 0xFF	; 255
    2950:	02 c0       	rjmp	.+4      	; 0x2956 <puts+0x56>
    2952:	8d 2f       	mov	r24, r29
    2954:	9c 2f       	mov	r25, r28
    2956:	df 91       	pop	r29
    2958:	cf 91       	pop	r28
    295a:	1f 91       	pop	r17
    295c:	0f 91       	pop	r16
    295e:	08 95       	ret

00002960 <vfprintf>:
    2960:	ab e0       	ldi	r26, 0x0B	; 11
    2962:	b0 e0       	ldi	r27, 0x00	; 0
    2964:	e6 eb       	ldi	r30, 0xB6	; 182
    2966:	f4 e1       	ldi	r31, 0x14	; 20
    2968:	0c 94 64 17 	jmp	0x2ec8	; 0x2ec8 <__prologue_saves__>
    296c:	6c 01       	movw	r12, r24
    296e:	7b 01       	movw	r14, r22
    2970:	8a 01       	movw	r16, r20
    2972:	fc 01       	movw	r30, r24
    2974:	17 82       	std	Z+7, r1	; 0x07
    2976:	16 82       	std	Z+6, r1	; 0x06
    2978:	83 81       	ldd	r24, Z+3	; 0x03
    297a:	81 ff       	sbrs	r24, 1
    297c:	cc c1       	rjmp	.+920    	; 0x2d16 <vfprintf+0x3b6>
    297e:	ce 01       	movw	r24, r28
    2980:	01 96       	adiw	r24, 0x01	; 1
    2982:	3c 01       	movw	r6, r24
    2984:	f6 01       	movw	r30, r12
    2986:	93 81       	ldd	r25, Z+3	; 0x03
    2988:	f7 01       	movw	r30, r14
    298a:	93 fd       	sbrc	r25, 3
    298c:	85 91       	lpm	r24, Z+
    298e:	93 ff       	sbrs	r25, 3
    2990:	81 91       	ld	r24, Z+
    2992:	7f 01       	movw	r14, r30
    2994:	88 23       	and	r24, r24
    2996:	09 f4       	brne	.+2      	; 0x299a <vfprintf+0x3a>
    2998:	ba c1       	rjmp	.+884    	; 0x2d0e <vfprintf+0x3ae>
    299a:	85 32       	cpi	r24, 0x25	; 37
    299c:	39 f4       	brne	.+14     	; 0x29ac <vfprintf+0x4c>
    299e:	93 fd       	sbrc	r25, 3
    29a0:	85 91       	lpm	r24, Z+
    29a2:	93 ff       	sbrs	r25, 3
    29a4:	81 91       	ld	r24, Z+
    29a6:	7f 01       	movw	r14, r30
    29a8:	85 32       	cpi	r24, 0x25	; 37
    29aa:	29 f4       	brne	.+10     	; 0x29b6 <vfprintf+0x56>
    29ac:	b6 01       	movw	r22, r12
    29ae:	90 e0       	ldi	r25, 0x00	; 0
    29b0:	0e 94 ca 16 	call	0x2d94	; 0x2d94 <fputc>
    29b4:	e7 cf       	rjmp	.-50     	; 0x2984 <vfprintf+0x24>
    29b6:	91 2c       	mov	r9, r1
    29b8:	21 2c       	mov	r2, r1
    29ba:	31 2c       	mov	r3, r1
    29bc:	ff e1       	ldi	r31, 0x1F	; 31
    29be:	f3 15       	cp	r31, r3
    29c0:	d8 f0       	brcs	.+54     	; 0x29f8 <vfprintf+0x98>
    29c2:	8b 32       	cpi	r24, 0x2B	; 43
    29c4:	79 f0       	breq	.+30     	; 0x29e4 <vfprintf+0x84>
    29c6:	38 f4       	brcc	.+14     	; 0x29d6 <vfprintf+0x76>
    29c8:	80 32       	cpi	r24, 0x20	; 32
    29ca:	79 f0       	breq	.+30     	; 0x29ea <vfprintf+0x8a>
    29cc:	83 32       	cpi	r24, 0x23	; 35
    29ce:	a1 f4       	brne	.+40     	; 0x29f8 <vfprintf+0x98>
    29d0:	23 2d       	mov	r18, r3
    29d2:	20 61       	ori	r18, 0x10	; 16
    29d4:	1d c0       	rjmp	.+58     	; 0x2a10 <vfprintf+0xb0>
    29d6:	8d 32       	cpi	r24, 0x2D	; 45
    29d8:	61 f0       	breq	.+24     	; 0x29f2 <vfprintf+0x92>
    29da:	80 33       	cpi	r24, 0x30	; 48
    29dc:	69 f4       	brne	.+26     	; 0x29f8 <vfprintf+0x98>
    29de:	23 2d       	mov	r18, r3
    29e0:	21 60       	ori	r18, 0x01	; 1
    29e2:	16 c0       	rjmp	.+44     	; 0x2a10 <vfprintf+0xb0>
    29e4:	83 2d       	mov	r24, r3
    29e6:	82 60       	ori	r24, 0x02	; 2
    29e8:	38 2e       	mov	r3, r24
    29ea:	e3 2d       	mov	r30, r3
    29ec:	e4 60       	ori	r30, 0x04	; 4
    29ee:	3e 2e       	mov	r3, r30
    29f0:	2a c0       	rjmp	.+84     	; 0x2a46 <vfprintf+0xe6>
    29f2:	f3 2d       	mov	r31, r3
    29f4:	f8 60       	ori	r31, 0x08	; 8
    29f6:	1d c0       	rjmp	.+58     	; 0x2a32 <vfprintf+0xd2>
    29f8:	37 fc       	sbrc	r3, 7
    29fa:	2d c0       	rjmp	.+90     	; 0x2a56 <vfprintf+0xf6>
    29fc:	20 ed       	ldi	r18, 0xD0	; 208
    29fe:	28 0f       	add	r18, r24
    2a00:	2a 30       	cpi	r18, 0x0A	; 10
    2a02:	40 f0       	brcs	.+16     	; 0x2a14 <vfprintf+0xb4>
    2a04:	8e 32       	cpi	r24, 0x2E	; 46
    2a06:	b9 f4       	brne	.+46     	; 0x2a36 <vfprintf+0xd6>
    2a08:	36 fc       	sbrc	r3, 6
    2a0a:	81 c1       	rjmp	.+770    	; 0x2d0e <vfprintf+0x3ae>
    2a0c:	23 2d       	mov	r18, r3
    2a0e:	20 64       	ori	r18, 0x40	; 64
    2a10:	32 2e       	mov	r3, r18
    2a12:	19 c0       	rjmp	.+50     	; 0x2a46 <vfprintf+0xe6>
    2a14:	36 fe       	sbrs	r3, 6
    2a16:	06 c0       	rjmp	.+12     	; 0x2a24 <vfprintf+0xc4>
    2a18:	8a e0       	ldi	r24, 0x0A	; 10
    2a1a:	98 9e       	mul	r9, r24
    2a1c:	20 0d       	add	r18, r0
    2a1e:	11 24       	eor	r1, r1
    2a20:	92 2e       	mov	r9, r18
    2a22:	11 c0       	rjmp	.+34     	; 0x2a46 <vfprintf+0xe6>
    2a24:	ea e0       	ldi	r30, 0x0A	; 10
    2a26:	2e 9e       	mul	r2, r30
    2a28:	20 0d       	add	r18, r0
    2a2a:	11 24       	eor	r1, r1
    2a2c:	22 2e       	mov	r2, r18
    2a2e:	f3 2d       	mov	r31, r3
    2a30:	f0 62       	ori	r31, 0x20	; 32
    2a32:	3f 2e       	mov	r3, r31
    2a34:	08 c0       	rjmp	.+16     	; 0x2a46 <vfprintf+0xe6>
    2a36:	8c 36       	cpi	r24, 0x6C	; 108
    2a38:	21 f4       	brne	.+8      	; 0x2a42 <vfprintf+0xe2>
    2a3a:	83 2d       	mov	r24, r3
    2a3c:	80 68       	ori	r24, 0x80	; 128
    2a3e:	38 2e       	mov	r3, r24
    2a40:	02 c0       	rjmp	.+4      	; 0x2a46 <vfprintf+0xe6>
    2a42:	88 36       	cpi	r24, 0x68	; 104
    2a44:	41 f4       	brne	.+16     	; 0x2a56 <vfprintf+0xf6>
    2a46:	f7 01       	movw	r30, r14
    2a48:	93 fd       	sbrc	r25, 3
    2a4a:	85 91       	lpm	r24, Z+
    2a4c:	93 ff       	sbrs	r25, 3
    2a4e:	81 91       	ld	r24, Z+
    2a50:	7f 01       	movw	r14, r30
    2a52:	81 11       	cpse	r24, r1
    2a54:	b3 cf       	rjmp	.-154    	; 0x29bc <vfprintf+0x5c>
    2a56:	98 2f       	mov	r25, r24
    2a58:	9f 7d       	andi	r25, 0xDF	; 223
    2a5a:	95 54       	subi	r25, 0x45	; 69
    2a5c:	93 30       	cpi	r25, 0x03	; 3
    2a5e:	28 f4       	brcc	.+10     	; 0x2a6a <vfprintf+0x10a>
    2a60:	0c 5f       	subi	r16, 0xFC	; 252
    2a62:	1f 4f       	sbci	r17, 0xFF	; 255
    2a64:	9f e3       	ldi	r25, 0x3F	; 63
    2a66:	99 83       	std	Y+1, r25	; 0x01
    2a68:	0d c0       	rjmp	.+26     	; 0x2a84 <vfprintf+0x124>
    2a6a:	83 36       	cpi	r24, 0x63	; 99
    2a6c:	31 f0       	breq	.+12     	; 0x2a7a <vfprintf+0x11a>
    2a6e:	83 37       	cpi	r24, 0x73	; 115
    2a70:	71 f0       	breq	.+28     	; 0x2a8e <vfprintf+0x12e>
    2a72:	83 35       	cpi	r24, 0x53	; 83
    2a74:	09 f0       	breq	.+2      	; 0x2a78 <vfprintf+0x118>
    2a76:	59 c0       	rjmp	.+178    	; 0x2b2a <vfprintf+0x1ca>
    2a78:	21 c0       	rjmp	.+66     	; 0x2abc <vfprintf+0x15c>
    2a7a:	f8 01       	movw	r30, r16
    2a7c:	80 81       	ld	r24, Z
    2a7e:	89 83       	std	Y+1, r24	; 0x01
    2a80:	0e 5f       	subi	r16, 0xFE	; 254
    2a82:	1f 4f       	sbci	r17, 0xFF	; 255
    2a84:	88 24       	eor	r8, r8
    2a86:	83 94       	inc	r8
    2a88:	91 2c       	mov	r9, r1
    2a8a:	53 01       	movw	r10, r6
    2a8c:	13 c0       	rjmp	.+38     	; 0x2ab4 <vfprintf+0x154>
    2a8e:	28 01       	movw	r4, r16
    2a90:	f2 e0       	ldi	r31, 0x02	; 2
    2a92:	4f 0e       	add	r4, r31
    2a94:	51 1c       	adc	r5, r1
    2a96:	f8 01       	movw	r30, r16
    2a98:	a0 80       	ld	r10, Z
    2a9a:	b1 80       	ldd	r11, Z+1	; 0x01
    2a9c:	36 fe       	sbrs	r3, 6
    2a9e:	03 c0       	rjmp	.+6      	; 0x2aa6 <vfprintf+0x146>
    2aa0:	69 2d       	mov	r22, r9
    2aa2:	70 e0       	ldi	r23, 0x00	; 0
    2aa4:	02 c0       	rjmp	.+4      	; 0x2aaa <vfprintf+0x14a>
    2aa6:	6f ef       	ldi	r22, 0xFF	; 255
    2aa8:	7f ef       	ldi	r23, 0xFF	; 255
    2aaa:	c5 01       	movw	r24, r10
    2aac:	0e 94 bf 16 	call	0x2d7e	; 0x2d7e <strnlen>
    2ab0:	4c 01       	movw	r8, r24
    2ab2:	82 01       	movw	r16, r4
    2ab4:	f3 2d       	mov	r31, r3
    2ab6:	ff 77       	andi	r31, 0x7F	; 127
    2ab8:	3f 2e       	mov	r3, r31
    2aba:	16 c0       	rjmp	.+44     	; 0x2ae8 <vfprintf+0x188>
    2abc:	28 01       	movw	r4, r16
    2abe:	22 e0       	ldi	r18, 0x02	; 2
    2ac0:	42 0e       	add	r4, r18
    2ac2:	51 1c       	adc	r5, r1
    2ac4:	f8 01       	movw	r30, r16
    2ac6:	a0 80       	ld	r10, Z
    2ac8:	b1 80       	ldd	r11, Z+1	; 0x01
    2aca:	36 fe       	sbrs	r3, 6
    2acc:	03 c0       	rjmp	.+6      	; 0x2ad4 <vfprintf+0x174>
    2ace:	69 2d       	mov	r22, r9
    2ad0:	70 e0       	ldi	r23, 0x00	; 0
    2ad2:	02 c0       	rjmp	.+4      	; 0x2ad8 <vfprintf+0x178>
    2ad4:	6f ef       	ldi	r22, 0xFF	; 255
    2ad6:	7f ef       	ldi	r23, 0xFF	; 255
    2ad8:	c5 01       	movw	r24, r10
    2ada:	0e 94 ad 16 	call	0x2d5a	; 0x2d5a <strnlen_P>
    2ade:	4c 01       	movw	r8, r24
    2ae0:	f3 2d       	mov	r31, r3
    2ae2:	f0 68       	ori	r31, 0x80	; 128
    2ae4:	3f 2e       	mov	r3, r31
    2ae6:	82 01       	movw	r16, r4
    2ae8:	33 fc       	sbrc	r3, 3
    2aea:	1b c0       	rjmp	.+54     	; 0x2b22 <vfprintf+0x1c2>
    2aec:	82 2d       	mov	r24, r2
    2aee:	90 e0       	ldi	r25, 0x00	; 0
    2af0:	88 16       	cp	r8, r24
    2af2:	99 06       	cpc	r9, r25
    2af4:	b0 f4       	brcc	.+44     	; 0x2b22 <vfprintf+0x1c2>
    2af6:	b6 01       	movw	r22, r12
    2af8:	80 e2       	ldi	r24, 0x20	; 32
    2afa:	90 e0       	ldi	r25, 0x00	; 0
    2afc:	0e 94 ca 16 	call	0x2d94	; 0x2d94 <fputc>
    2b00:	2a 94       	dec	r2
    2b02:	f4 cf       	rjmp	.-24     	; 0x2aec <vfprintf+0x18c>
    2b04:	f5 01       	movw	r30, r10
    2b06:	37 fc       	sbrc	r3, 7
    2b08:	85 91       	lpm	r24, Z+
    2b0a:	37 fe       	sbrs	r3, 7
    2b0c:	81 91       	ld	r24, Z+
    2b0e:	5f 01       	movw	r10, r30
    2b10:	b6 01       	movw	r22, r12
    2b12:	90 e0       	ldi	r25, 0x00	; 0
    2b14:	0e 94 ca 16 	call	0x2d94	; 0x2d94 <fputc>
    2b18:	21 10       	cpse	r2, r1
    2b1a:	2a 94       	dec	r2
    2b1c:	21 e0       	ldi	r18, 0x01	; 1
    2b1e:	82 1a       	sub	r8, r18
    2b20:	91 08       	sbc	r9, r1
    2b22:	81 14       	cp	r8, r1
    2b24:	91 04       	cpc	r9, r1
    2b26:	71 f7       	brne	.-36     	; 0x2b04 <vfprintf+0x1a4>
    2b28:	e8 c0       	rjmp	.+464    	; 0x2cfa <vfprintf+0x39a>
    2b2a:	84 36       	cpi	r24, 0x64	; 100
    2b2c:	11 f0       	breq	.+4      	; 0x2b32 <vfprintf+0x1d2>
    2b2e:	89 36       	cpi	r24, 0x69	; 105
    2b30:	41 f5       	brne	.+80     	; 0x2b82 <vfprintf+0x222>
    2b32:	f8 01       	movw	r30, r16
    2b34:	37 fe       	sbrs	r3, 7
    2b36:	07 c0       	rjmp	.+14     	; 0x2b46 <vfprintf+0x1e6>
    2b38:	60 81       	ld	r22, Z
    2b3a:	71 81       	ldd	r23, Z+1	; 0x01
    2b3c:	82 81       	ldd	r24, Z+2	; 0x02
    2b3e:	93 81       	ldd	r25, Z+3	; 0x03
    2b40:	0c 5f       	subi	r16, 0xFC	; 252
    2b42:	1f 4f       	sbci	r17, 0xFF	; 255
    2b44:	08 c0       	rjmp	.+16     	; 0x2b56 <vfprintf+0x1f6>
    2b46:	60 81       	ld	r22, Z
    2b48:	71 81       	ldd	r23, Z+1	; 0x01
    2b4a:	07 2e       	mov	r0, r23
    2b4c:	00 0c       	add	r0, r0
    2b4e:	88 0b       	sbc	r24, r24
    2b50:	99 0b       	sbc	r25, r25
    2b52:	0e 5f       	subi	r16, 0xFE	; 254
    2b54:	1f 4f       	sbci	r17, 0xFF	; 255
    2b56:	f3 2d       	mov	r31, r3
    2b58:	ff 76       	andi	r31, 0x6F	; 111
    2b5a:	3f 2e       	mov	r3, r31
    2b5c:	97 ff       	sbrs	r25, 7
    2b5e:	09 c0       	rjmp	.+18     	; 0x2b72 <vfprintf+0x212>
    2b60:	90 95       	com	r25
    2b62:	80 95       	com	r24
    2b64:	70 95       	com	r23
    2b66:	61 95       	neg	r22
    2b68:	7f 4f       	sbci	r23, 0xFF	; 255
    2b6a:	8f 4f       	sbci	r24, 0xFF	; 255
    2b6c:	9f 4f       	sbci	r25, 0xFF	; 255
    2b6e:	f0 68       	ori	r31, 0x80	; 128
    2b70:	3f 2e       	mov	r3, r31
    2b72:	2a e0       	ldi	r18, 0x0A	; 10
    2b74:	30 e0       	ldi	r19, 0x00	; 0
    2b76:	a3 01       	movw	r20, r6
    2b78:	0e 94 06 17 	call	0x2e0c	; 0x2e0c <__ultoa_invert>
    2b7c:	88 2e       	mov	r8, r24
    2b7e:	86 18       	sub	r8, r6
    2b80:	45 c0       	rjmp	.+138    	; 0x2c0c <vfprintf+0x2ac>
    2b82:	85 37       	cpi	r24, 0x75	; 117
    2b84:	31 f4       	brne	.+12     	; 0x2b92 <vfprintf+0x232>
    2b86:	23 2d       	mov	r18, r3
    2b88:	2f 7e       	andi	r18, 0xEF	; 239
    2b8a:	b2 2e       	mov	r11, r18
    2b8c:	2a e0       	ldi	r18, 0x0A	; 10
    2b8e:	30 e0       	ldi	r19, 0x00	; 0
    2b90:	25 c0       	rjmp	.+74     	; 0x2bdc <vfprintf+0x27c>
    2b92:	93 2d       	mov	r25, r3
    2b94:	99 7f       	andi	r25, 0xF9	; 249
    2b96:	b9 2e       	mov	r11, r25
    2b98:	8f 36       	cpi	r24, 0x6F	; 111
    2b9a:	c1 f0       	breq	.+48     	; 0x2bcc <vfprintf+0x26c>
    2b9c:	18 f4       	brcc	.+6      	; 0x2ba4 <vfprintf+0x244>
    2b9e:	88 35       	cpi	r24, 0x58	; 88
    2ba0:	79 f0       	breq	.+30     	; 0x2bc0 <vfprintf+0x260>
    2ba2:	b5 c0       	rjmp	.+362    	; 0x2d0e <vfprintf+0x3ae>
    2ba4:	80 37       	cpi	r24, 0x70	; 112
    2ba6:	19 f0       	breq	.+6      	; 0x2bae <vfprintf+0x24e>
    2ba8:	88 37       	cpi	r24, 0x78	; 120
    2baa:	21 f0       	breq	.+8      	; 0x2bb4 <vfprintf+0x254>
    2bac:	b0 c0       	rjmp	.+352    	; 0x2d0e <vfprintf+0x3ae>
    2bae:	e9 2f       	mov	r30, r25
    2bb0:	e0 61       	ori	r30, 0x10	; 16
    2bb2:	be 2e       	mov	r11, r30
    2bb4:	b4 fe       	sbrs	r11, 4
    2bb6:	0d c0       	rjmp	.+26     	; 0x2bd2 <vfprintf+0x272>
    2bb8:	fb 2d       	mov	r31, r11
    2bba:	f4 60       	ori	r31, 0x04	; 4
    2bbc:	bf 2e       	mov	r11, r31
    2bbe:	09 c0       	rjmp	.+18     	; 0x2bd2 <vfprintf+0x272>
    2bc0:	34 fe       	sbrs	r3, 4
    2bc2:	0a c0       	rjmp	.+20     	; 0x2bd8 <vfprintf+0x278>
    2bc4:	29 2f       	mov	r18, r25
    2bc6:	26 60       	ori	r18, 0x06	; 6
    2bc8:	b2 2e       	mov	r11, r18
    2bca:	06 c0       	rjmp	.+12     	; 0x2bd8 <vfprintf+0x278>
    2bcc:	28 e0       	ldi	r18, 0x08	; 8
    2bce:	30 e0       	ldi	r19, 0x00	; 0
    2bd0:	05 c0       	rjmp	.+10     	; 0x2bdc <vfprintf+0x27c>
    2bd2:	20 e1       	ldi	r18, 0x10	; 16
    2bd4:	30 e0       	ldi	r19, 0x00	; 0
    2bd6:	02 c0       	rjmp	.+4      	; 0x2bdc <vfprintf+0x27c>
    2bd8:	20 e1       	ldi	r18, 0x10	; 16
    2bda:	32 e0       	ldi	r19, 0x02	; 2
    2bdc:	f8 01       	movw	r30, r16
    2bde:	b7 fe       	sbrs	r11, 7
    2be0:	07 c0       	rjmp	.+14     	; 0x2bf0 <vfprintf+0x290>
    2be2:	60 81       	ld	r22, Z
    2be4:	71 81       	ldd	r23, Z+1	; 0x01
    2be6:	82 81       	ldd	r24, Z+2	; 0x02
    2be8:	93 81       	ldd	r25, Z+3	; 0x03
    2bea:	0c 5f       	subi	r16, 0xFC	; 252
    2bec:	1f 4f       	sbci	r17, 0xFF	; 255
    2bee:	06 c0       	rjmp	.+12     	; 0x2bfc <vfprintf+0x29c>
    2bf0:	60 81       	ld	r22, Z
    2bf2:	71 81       	ldd	r23, Z+1	; 0x01
    2bf4:	80 e0       	ldi	r24, 0x00	; 0
    2bf6:	90 e0       	ldi	r25, 0x00	; 0
    2bf8:	0e 5f       	subi	r16, 0xFE	; 254
    2bfa:	1f 4f       	sbci	r17, 0xFF	; 255
    2bfc:	a3 01       	movw	r20, r6
    2bfe:	0e 94 06 17 	call	0x2e0c	; 0x2e0c <__ultoa_invert>
    2c02:	88 2e       	mov	r8, r24
    2c04:	86 18       	sub	r8, r6
    2c06:	fb 2d       	mov	r31, r11
    2c08:	ff 77       	andi	r31, 0x7F	; 127
    2c0a:	3f 2e       	mov	r3, r31
    2c0c:	36 fe       	sbrs	r3, 6
    2c0e:	0d c0       	rjmp	.+26     	; 0x2c2a <vfprintf+0x2ca>
    2c10:	23 2d       	mov	r18, r3
    2c12:	2e 7f       	andi	r18, 0xFE	; 254
    2c14:	a2 2e       	mov	r10, r18
    2c16:	89 14       	cp	r8, r9
    2c18:	58 f4       	brcc	.+22     	; 0x2c30 <vfprintf+0x2d0>
    2c1a:	34 fe       	sbrs	r3, 4
    2c1c:	0b c0       	rjmp	.+22     	; 0x2c34 <vfprintf+0x2d4>
    2c1e:	32 fc       	sbrc	r3, 2
    2c20:	09 c0       	rjmp	.+18     	; 0x2c34 <vfprintf+0x2d4>
    2c22:	83 2d       	mov	r24, r3
    2c24:	8e 7e       	andi	r24, 0xEE	; 238
    2c26:	a8 2e       	mov	r10, r24
    2c28:	05 c0       	rjmp	.+10     	; 0x2c34 <vfprintf+0x2d4>
    2c2a:	b8 2c       	mov	r11, r8
    2c2c:	a3 2c       	mov	r10, r3
    2c2e:	03 c0       	rjmp	.+6      	; 0x2c36 <vfprintf+0x2d6>
    2c30:	b8 2c       	mov	r11, r8
    2c32:	01 c0       	rjmp	.+2      	; 0x2c36 <vfprintf+0x2d6>
    2c34:	b9 2c       	mov	r11, r9
    2c36:	a4 fe       	sbrs	r10, 4
    2c38:	0f c0       	rjmp	.+30     	; 0x2c58 <vfprintf+0x2f8>
    2c3a:	fe 01       	movw	r30, r28
    2c3c:	e8 0d       	add	r30, r8
    2c3e:	f1 1d       	adc	r31, r1
    2c40:	80 81       	ld	r24, Z
    2c42:	80 33       	cpi	r24, 0x30	; 48
    2c44:	21 f4       	brne	.+8      	; 0x2c4e <vfprintf+0x2ee>
    2c46:	9a 2d       	mov	r25, r10
    2c48:	99 7e       	andi	r25, 0xE9	; 233
    2c4a:	a9 2e       	mov	r10, r25
    2c4c:	09 c0       	rjmp	.+18     	; 0x2c60 <vfprintf+0x300>
    2c4e:	a2 fe       	sbrs	r10, 2
    2c50:	06 c0       	rjmp	.+12     	; 0x2c5e <vfprintf+0x2fe>
    2c52:	b3 94       	inc	r11
    2c54:	b3 94       	inc	r11
    2c56:	04 c0       	rjmp	.+8      	; 0x2c60 <vfprintf+0x300>
    2c58:	8a 2d       	mov	r24, r10
    2c5a:	86 78       	andi	r24, 0x86	; 134
    2c5c:	09 f0       	breq	.+2      	; 0x2c60 <vfprintf+0x300>
    2c5e:	b3 94       	inc	r11
    2c60:	a3 fc       	sbrc	r10, 3
    2c62:	11 c0       	rjmp	.+34     	; 0x2c86 <vfprintf+0x326>
    2c64:	a0 fe       	sbrs	r10, 0
    2c66:	06 c0       	rjmp	.+12     	; 0x2c74 <vfprintf+0x314>
    2c68:	b2 14       	cp	r11, r2
    2c6a:	88 f4       	brcc	.+34     	; 0x2c8e <vfprintf+0x32e>
    2c6c:	28 0c       	add	r2, r8
    2c6e:	92 2c       	mov	r9, r2
    2c70:	9b 18       	sub	r9, r11
    2c72:	0e c0       	rjmp	.+28     	; 0x2c90 <vfprintf+0x330>
    2c74:	b2 14       	cp	r11, r2
    2c76:	60 f4       	brcc	.+24     	; 0x2c90 <vfprintf+0x330>
    2c78:	b6 01       	movw	r22, r12
    2c7a:	80 e2       	ldi	r24, 0x20	; 32
    2c7c:	90 e0       	ldi	r25, 0x00	; 0
    2c7e:	0e 94 ca 16 	call	0x2d94	; 0x2d94 <fputc>
    2c82:	b3 94       	inc	r11
    2c84:	f7 cf       	rjmp	.-18     	; 0x2c74 <vfprintf+0x314>
    2c86:	b2 14       	cp	r11, r2
    2c88:	18 f4       	brcc	.+6      	; 0x2c90 <vfprintf+0x330>
    2c8a:	2b 18       	sub	r2, r11
    2c8c:	02 c0       	rjmp	.+4      	; 0x2c92 <vfprintf+0x332>
    2c8e:	98 2c       	mov	r9, r8
    2c90:	21 2c       	mov	r2, r1
    2c92:	a4 fe       	sbrs	r10, 4
    2c94:	10 c0       	rjmp	.+32     	; 0x2cb6 <vfprintf+0x356>
    2c96:	b6 01       	movw	r22, r12
    2c98:	80 e3       	ldi	r24, 0x30	; 48
    2c9a:	90 e0       	ldi	r25, 0x00	; 0
    2c9c:	0e 94 ca 16 	call	0x2d94	; 0x2d94 <fputc>
    2ca0:	a2 fe       	sbrs	r10, 2
    2ca2:	17 c0       	rjmp	.+46     	; 0x2cd2 <vfprintf+0x372>
    2ca4:	a1 fc       	sbrc	r10, 1
    2ca6:	03 c0       	rjmp	.+6      	; 0x2cae <vfprintf+0x34e>
    2ca8:	88 e7       	ldi	r24, 0x78	; 120
    2caa:	90 e0       	ldi	r25, 0x00	; 0
    2cac:	02 c0       	rjmp	.+4      	; 0x2cb2 <vfprintf+0x352>
    2cae:	88 e5       	ldi	r24, 0x58	; 88
    2cb0:	90 e0       	ldi	r25, 0x00	; 0
    2cb2:	b6 01       	movw	r22, r12
    2cb4:	0c c0       	rjmp	.+24     	; 0x2cce <vfprintf+0x36e>
    2cb6:	8a 2d       	mov	r24, r10
    2cb8:	86 78       	andi	r24, 0x86	; 134
    2cba:	59 f0       	breq	.+22     	; 0x2cd2 <vfprintf+0x372>
    2cbc:	a1 fe       	sbrs	r10, 1
    2cbe:	02 c0       	rjmp	.+4      	; 0x2cc4 <vfprintf+0x364>
    2cc0:	8b e2       	ldi	r24, 0x2B	; 43
    2cc2:	01 c0       	rjmp	.+2      	; 0x2cc6 <vfprintf+0x366>
    2cc4:	80 e2       	ldi	r24, 0x20	; 32
    2cc6:	a7 fc       	sbrc	r10, 7
    2cc8:	8d e2       	ldi	r24, 0x2D	; 45
    2cca:	b6 01       	movw	r22, r12
    2ccc:	90 e0       	ldi	r25, 0x00	; 0
    2cce:	0e 94 ca 16 	call	0x2d94	; 0x2d94 <fputc>
    2cd2:	89 14       	cp	r8, r9
    2cd4:	38 f4       	brcc	.+14     	; 0x2ce4 <vfprintf+0x384>
    2cd6:	b6 01       	movw	r22, r12
    2cd8:	80 e3       	ldi	r24, 0x30	; 48
    2cda:	90 e0       	ldi	r25, 0x00	; 0
    2cdc:	0e 94 ca 16 	call	0x2d94	; 0x2d94 <fputc>
    2ce0:	9a 94       	dec	r9
    2ce2:	f7 cf       	rjmp	.-18     	; 0x2cd2 <vfprintf+0x372>
    2ce4:	8a 94       	dec	r8
    2ce6:	f3 01       	movw	r30, r6
    2ce8:	e8 0d       	add	r30, r8
    2cea:	f1 1d       	adc	r31, r1
    2cec:	80 81       	ld	r24, Z
    2cee:	b6 01       	movw	r22, r12
    2cf0:	90 e0       	ldi	r25, 0x00	; 0
    2cf2:	0e 94 ca 16 	call	0x2d94	; 0x2d94 <fputc>
    2cf6:	81 10       	cpse	r8, r1
    2cf8:	f5 cf       	rjmp	.-22     	; 0x2ce4 <vfprintf+0x384>
    2cfa:	22 20       	and	r2, r2
    2cfc:	09 f4       	brne	.+2      	; 0x2d00 <vfprintf+0x3a0>
    2cfe:	42 ce       	rjmp	.-892    	; 0x2984 <vfprintf+0x24>
    2d00:	b6 01       	movw	r22, r12
    2d02:	80 e2       	ldi	r24, 0x20	; 32
    2d04:	90 e0       	ldi	r25, 0x00	; 0
    2d06:	0e 94 ca 16 	call	0x2d94	; 0x2d94 <fputc>
    2d0a:	2a 94       	dec	r2
    2d0c:	f6 cf       	rjmp	.-20     	; 0x2cfa <vfprintf+0x39a>
    2d0e:	f6 01       	movw	r30, r12
    2d10:	86 81       	ldd	r24, Z+6	; 0x06
    2d12:	97 81       	ldd	r25, Z+7	; 0x07
    2d14:	02 c0       	rjmp	.+4      	; 0x2d1a <vfprintf+0x3ba>
    2d16:	8f ef       	ldi	r24, 0xFF	; 255
    2d18:	9f ef       	ldi	r25, 0xFF	; 255
    2d1a:	2b 96       	adiw	r28, 0x0b	; 11
    2d1c:	e2 e1       	ldi	r30, 0x12	; 18
    2d1e:	0c 94 80 17 	jmp	0x2f00	; 0x2f00 <__epilogue_restores__>

00002d22 <calloc>:
    2d22:	0f 93       	push	r16
    2d24:	1f 93       	push	r17
    2d26:	cf 93       	push	r28
    2d28:	df 93       	push	r29
    2d2a:	86 9f       	mul	r24, r22
    2d2c:	80 01       	movw	r16, r0
    2d2e:	87 9f       	mul	r24, r23
    2d30:	10 0d       	add	r17, r0
    2d32:	96 9f       	mul	r25, r22
    2d34:	10 0d       	add	r17, r0
    2d36:	11 24       	eor	r1, r1
    2d38:	c8 01       	movw	r24, r16
    2d3a:	0e 94 f5 12 	call	0x25ea	; 0x25ea <malloc>
    2d3e:	ec 01       	movw	r28, r24
    2d40:	00 97       	sbiw	r24, 0x00	; 0
    2d42:	29 f0       	breq	.+10     	; 0x2d4e <calloc+0x2c>
    2d44:	a8 01       	movw	r20, r16
    2d46:	60 e0       	ldi	r22, 0x00	; 0
    2d48:	70 e0       	ldi	r23, 0x00	; 0
    2d4a:	0e 94 b8 16 	call	0x2d70	; 0x2d70 <memset>
    2d4e:	ce 01       	movw	r24, r28
    2d50:	df 91       	pop	r29
    2d52:	cf 91       	pop	r28
    2d54:	1f 91       	pop	r17
    2d56:	0f 91       	pop	r16
    2d58:	08 95       	ret

00002d5a <strnlen_P>:
    2d5a:	fc 01       	movw	r30, r24
    2d5c:	05 90       	lpm	r0, Z+
    2d5e:	61 50       	subi	r22, 0x01	; 1
    2d60:	70 40       	sbci	r23, 0x00	; 0
    2d62:	01 10       	cpse	r0, r1
    2d64:	d8 f7       	brcc	.-10     	; 0x2d5c <strnlen_P+0x2>
    2d66:	80 95       	com	r24
    2d68:	90 95       	com	r25
    2d6a:	8e 0f       	add	r24, r30
    2d6c:	9f 1f       	adc	r25, r31
    2d6e:	08 95       	ret

00002d70 <memset>:
    2d70:	dc 01       	movw	r26, r24
    2d72:	01 c0       	rjmp	.+2      	; 0x2d76 <memset+0x6>
    2d74:	6d 93       	st	X+, r22
    2d76:	41 50       	subi	r20, 0x01	; 1
    2d78:	50 40       	sbci	r21, 0x00	; 0
    2d7a:	e0 f7       	brcc	.-8      	; 0x2d74 <memset+0x4>
    2d7c:	08 95       	ret

00002d7e <strnlen>:
    2d7e:	fc 01       	movw	r30, r24
    2d80:	61 50       	subi	r22, 0x01	; 1
    2d82:	70 40       	sbci	r23, 0x00	; 0
    2d84:	01 90       	ld	r0, Z+
    2d86:	01 10       	cpse	r0, r1
    2d88:	d8 f7       	brcc	.-10     	; 0x2d80 <strnlen+0x2>
    2d8a:	80 95       	com	r24
    2d8c:	90 95       	com	r25
    2d8e:	8e 0f       	add	r24, r30
    2d90:	9f 1f       	adc	r25, r31
    2d92:	08 95       	ret

00002d94 <fputc>:
    2d94:	0f 93       	push	r16
    2d96:	1f 93       	push	r17
    2d98:	cf 93       	push	r28
    2d9a:	df 93       	push	r29
    2d9c:	fb 01       	movw	r30, r22
    2d9e:	23 81       	ldd	r18, Z+3	; 0x03
    2da0:	21 fd       	sbrc	r18, 1
    2da2:	03 c0       	rjmp	.+6      	; 0x2daa <fputc+0x16>
    2da4:	8f ef       	ldi	r24, 0xFF	; 255
    2da6:	9f ef       	ldi	r25, 0xFF	; 255
    2da8:	2c c0       	rjmp	.+88     	; 0x2e02 <fputc+0x6e>
    2daa:	22 ff       	sbrs	r18, 2
    2dac:	16 c0       	rjmp	.+44     	; 0x2dda <fputc+0x46>
    2dae:	46 81       	ldd	r20, Z+6	; 0x06
    2db0:	57 81       	ldd	r21, Z+7	; 0x07
    2db2:	24 81       	ldd	r18, Z+4	; 0x04
    2db4:	35 81       	ldd	r19, Z+5	; 0x05
    2db6:	42 17       	cp	r20, r18
    2db8:	53 07       	cpc	r21, r19
    2dba:	44 f4       	brge	.+16     	; 0x2dcc <fputc+0x38>
    2dbc:	a0 81       	ld	r26, Z
    2dbe:	b1 81       	ldd	r27, Z+1	; 0x01
    2dc0:	9d 01       	movw	r18, r26
    2dc2:	2f 5f       	subi	r18, 0xFF	; 255
    2dc4:	3f 4f       	sbci	r19, 0xFF	; 255
    2dc6:	31 83       	std	Z+1, r19	; 0x01
    2dc8:	20 83       	st	Z, r18
    2dca:	8c 93       	st	X, r24
    2dcc:	26 81       	ldd	r18, Z+6	; 0x06
    2dce:	37 81       	ldd	r19, Z+7	; 0x07
    2dd0:	2f 5f       	subi	r18, 0xFF	; 255
    2dd2:	3f 4f       	sbci	r19, 0xFF	; 255
    2dd4:	37 83       	std	Z+7, r19	; 0x07
    2dd6:	26 83       	std	Z+6, r18	; 0x06
    2dd8:	14 c0       	rjmp	.+40     	; 0x2e02 <fputc+0x6e>
    2dda:	8b 01       	movw	r16, r22
    2ddc:	ec 01       	movw	r28, r24
    2dde:	fb 01       	movw	r30, r22
    2de0:	00 84       	ldd	r0, Z+8	; 0x08
    2de2:	f1 85       	ldd	r31, Z+9	; 0x09
    2de4:	e0 2d       	mov	r30, r0
    2de6:	09 95       	icall
    2de8:	89 2b       	or	r24, r25
    2dea:	e1 f6       	brne	.-72     	; 0x2da4 <fputc+0x10>
    2dec:	d8 01       	movw	r26, r16
    2dee:	16 96       	adiw	r26, 0x06	; 6
    2df0:	8d 91       	ld	r24, X+
    2df2:	9c 91       	ld	r25, X
    2df4:	17 97       	sbiw	r26, 0x07	; 7
    2df6:	01 96       	adiw	r24, 0x01	; 1
    2df8:	17 96       	adiw	r26, 0x07	; 7
    2dfa:	9c 93       	st	X, r25
    2dfc:	8e 93       	st	-X, r24
    2dfe:	16 97       	sbiw	r26, 0x06	; 6
    2e00:	ce 01       	movw	r24, r28
    2e02:	df 91       	pop	r29
    2e04:	cf 91       	pop	r28
    2e06:	1f 91       	pop	r17
    2e08:	0f 91       	pop	r16
    2e0a:	08 95       	ret

00002e0c <__ultoa_invert>:
    2e0c:	fa 01       	movw	r30, r20
    2e0e:	aa 27       	eor	r26, r26
    2e10:	28 30       	cpi	r18, 0x08	; 8
    2e12:	51 f1       	breq	.+84     	; 0x2e68 <__ultoa_invert+0x5c>
    2e14:	20 31       	cpi	r18, 0x10	; 16
    2e16:	81 f1       	breq	.+96     	; 0x2e78 <__ultoa_invert+0x6c>
    2e18:	e8 94       	clt
    2e1a:	6f 93       	push	r22
    2e1c:	6e 7f       	andi	r22, 0xFE	; 254
    2e1e:	6e 5f       	subi	r22, 0xFE	; 254
    2e20:	7f 4f       	sbci	r23, 0xFF	; 255
    2e22:	8f 4f       	sbci	r24, 0xFF	; 255
    2e24:	9f 4f       	sbci	r25, 0xFF	; 255
    2e26:	af 4f       	sbci	r26, 0xFF	; 255
    2e28:	b1 e0       	ldi	r27, 0x01	; 1
    2e2a:	3e d0       	rcall	.+124    	; 0x2ea8 <__ultoa_invert+0x9c>
    2e2c:	b4 e0       	ldi	r27, 0x04	; 4
    2e2e:	3c d0       	rcall	.+120    	; 0x2ea8 <__ultoa_invert+0x9c>
    2e30:	67 0f       	add	r22, r23
    2e32:	78 1f       	adc	r23, r24
    2e34:	89 1f       	adc	r24, r25
    2e36:	9a 1f       	adc	r25, r26
    2e38:	a1 1d       	adc	r26, r1
    2e3a:	68 0f       	add	r22, r24
    2e3c:	79 1f       	adc	r23, r25
    2e3e:	8a 1f       	adc	r24, r26
    2e40:	91 1d       	adc	r25, r1
    2e42:	a1 1d       	adc	r26, r1
    2e44:	6a 0f       	add	r22, r26
    2e46:	71 1d       	adc	r23, r1
    2e48:	81 1d       	adc	r24, r1
    2e4a:	91 1d       	adc	r25, r1
    2e4c:	a1 1d       	adc	r26, r1
    2e4e:	20 d0       	rcall	.+64     	; 0x2e90 <__ultoa_invert+0x84>
    2e50:	09 f4       	brne	.+2      	; 0x2e54 <__ultoa_invert+0x48>
    2e52:	68 94       	set
    2e54:	3f 91       	pop	r19
    2e56:	2a e0       	ldi	r18, 0x0A	; 10
    2e58:	26 9f       	mul	r18, r22
    2e5a:	11 24       	eor	r1, r1
    2e5c:	30 19       	sub	r19, r0
    2e5e:	30 5d       	subi	r19, 0xD0	; 208
    2e60:	31 93       	st	Z+, r19
    2e62:	de f6       	brtc	.-74     	; 0x2e1a <__ultoa_invert+0xe>
    2e64:	cf 01       	movw	r24, r30
    2e66:	08 95       	ret
    2e68:	46 2f       	mov	r20, r22
    2e6a:	47 70       	andi	r20, 0x07	; 7
    2e6c:	40 5d       	subi	r20, 0xD0	; 208
    2e6e:	41 93       	st	Z+, r20
    2e70:	b3 e0       	ldi	r27, 0x03	; 3
    2e72:	0f d0       	rcall	.+30     	; 0x2e92 <__ultoa_invert+0x86>
    2e74:	c9 f7       	brne	.-14     	; 0x2e68 <__ultoa_invert+0x5c>
    2e76:	f6 cf       	rjmp	.-20     	; 0x2e64 <__ultoa_invert+0x58>
    2e78:	46 2f       	mov	r20, r22
    2e7a:	4f 70       	andi	r20, 0x0F	; 15
    2e7c:	40 5d       	subi	r20, 0xD0	; 208
    2e7e:	4a 33       	cpi	r20, 0x3A	; 58
    2e80:	18 f0       	brcs	.+6      	; 0x2e88 <__ultoa_invert+0x7c>
    2e82:	49 5d       	subi	r20, 0xD9	; 217
    2e84:	31 fd       	sbrc	r19, 1
    2e86:	40 52       	subi	r20, 0x20	; 32
    2e88:	41 93       	st	Z+, r20
    2e8a:	02 d0       	rcall	.+4      	; 0x2e90 <__ultoa_invert+0x84>
    2e8c:	a9 f7       	brne	.-22     	; 0x2e78 <__ultoa_invert+0x6c>
    2e8e:	ea cf       	rjmp	.-44     	; 0x2e64 <__ultoa_invert+0x58>
    2e90:	b4 e0       	ldi	r27, 0x04	; 4
    2e92:	a6 95       	lsr	r26
    2e94:	97 95       	ror	r25
    2e96:	87 95       	ror	r24
    2e98:	77 95       	ror	r23
    2e9a:	67 95       	ror	r22
    2e9c:	ba 95       	dec	r27
    2e9e:	c9 f7       	brne	.-14     	; 0x2e92 <__ultoa_invert+0x86>
    2ea0:	00 97       	sbiw	r24, 0x00	; 0
    2ea2:	61 05       	cpc	r22, r1
    2ea4:	71 05       	cpc	r23, r1
    2ea6:	08 95       	ret
    2ea8:	9b 01       	movw	r18, r22
    2eaa:	ac 01       	movw	r20, r24
    2eac:	0a 2e       	mov	r0, r26
    2eae:	06 94       	lsr	r0
    2eb0:	57 95       	ror	r21
    2eb2:	47 95       	ror	r20
    2eb4:	37 95       	ror	r19
    2eb6:	27 95       	ror	r18
    2eb8:	ba 95       	dec	r27
    2eba:	c9 f7       	brne	.-14     	; 0x2eae <__ultoa_invert+0xa2>
    2ebc:	62 0f       	add	r22, r18
    2ebe:	73 1f       	adc	r23, r19
    2ec0:	84 1f       	adc	r24, r20
    2ec2:	95 1f       	adc	r25, r21
    2ec4:	a0 1d       	adc	r26, r0
    2ec6:	08 95       	ret

00002ec8 <__prologue_saves__>:
    2ec8:	2f 92       	push	r2
    2eca:	3f 92       	push	r3
    2ecc:	4f 92       	push	r4
    2ece:	5f 92       	push	r5
    2ed0:	6f 92       	push	r6
    2ed2:	7f 92       	push	r7
    2ed4:	8f 92       	push	r8
    2ed6:	9f 92       	push	r9
    2ed8:	af 92       	push	r10
    2eda:	bf 92       	push	r11
    2edc:	cf 92       	push	r12
    2ede:	df 92       	push	r13
    2ee0:	ef 92       	push	r14
    2ee2:	ff 92       	push	r15
    2ee4:	0f 93       	push	r16
    2ee6:	1f 93       	push	r17
    2ee8:	cf 93       	push	r28
    2eea:	df 93       	push	r29
    2eec:	cd b7       	in	r28, 0x3d	; 61
    2eee:	de b7       	in	r29, 0x3e	; 62
    2ef0:	ca 1b       	sub	r28, r26
    2ef2:	db 0b       	sbc	r29, r27
    2ef4:	0f b6       	in	r0, 0x3f	; 63
    2ef6:	f8 94       	cli
    2ef8:	de bf       	out	0x3e, r29	; 62
    2efa:	0f be       	out	0x3f, r0	; 63
    2efc:	cd bf       	out	0x3d, r28	; 61
    2efe:	09 94       	ijmp

00002f00 <__epilogue_restores__>:
    2f00:	2a 88       	ldd	r2, Y+18	; 0x12
    2f02:	39 88       	ldd	r3, Y+17	; 0x11
    2f04:	48 88       	ldd	r4, Y+16	; 0x10
    2f06:	5f 84       	ldd	r5, Y+15	; 0x0f
    2f08:	6e 84       	ldd	r6, Y+14	; 0x0e
    2f0a:	7d 84       	ldd	r7, Y+13	; 0x0d
    2f0c:	8c 84       	ldd	r8, Y+12	; 0x0c
    2f0e:	9b 84       	ldd	r9, Y+11	; 0x0b
    2f10:	aa 84       	ldd	r10, Y+10	; 0x0a
    2f12:	b9 84       	ldd	r11, Y+9	; 0x09
    2f14:	c8 84       	ldd	r12, Y+8	; 0x08
    2f16:	df 80       	ldd	r13, Y+7	; 0x07
    2f18:	ee 80       	ldd	r14, Y+6	; 0x06
    2f1a:	fd 80       	ldd	r15, Y+5	; 0x05
    2f1c:	0c 81       	ldd	r16, Y+4	; 0x04
    2f1e:	1b 81       	ldd	r17, Y+3	; 0x03
    2f20:	aa 81       	ldd	r26, Y+2	; 0x02
    2f22:	b9 81       	ldd	r27, Y+1	; 0x01
    2f24:	ce 0f       	add	r28, r30
    2f26:	d1 1d       	adc	r29, r1
    2f28:	0f b6       	in	r0, 0x3f	; 63
    2f2a:	f8 94       	cli
    2f2c:	de bf       	out	0x3e, r29	; 62
    2f2e:	0f be       	out	0x3f, r0	; 63
    2f30:	cd bf       	out	0x3d, r28	; 61
    2f32:	ed 01       	movw	r28, r26
    2f34:	08 95       	ret

00002f36 <_exit>:
    2f36:	f8 94       	cli

00002f38 <__stop_program>:
    2f38:	ff cf       	rjmp	.-2      	; 0x2f38 <__stop_program>
